<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&oldid=1569 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:19:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="robots" content="noindex,nofollow" />
		<meta name="keywords" content="Magic2" />
		<link rel="shortcut icon" href="http://wwwhomes.doc.ic.ac.uk/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/opensearch_desc.php" title="Rashed Karim Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Rashed Karim Wiki RSS Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Rashed Karim Wiki Atom Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Magic2 - Rashed Karim Wiki</title>
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/monobook/main.css?207" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE50Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE55Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE60Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE70Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/~rkarim/mediawiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/~rkarim/mediawiki/skins";
		var wgArticlePath = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=$1";
		var wgScriptPath = "/~rkarim/mediawiki";
		var wgScript = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://wwwhomes.doc.ic.ac.uk/";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Magic2";
		var wgTitle = "Magic2";
		var wgAction = "view";
		var wgArticleId = 193;
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 1569;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/ajax.js?207"></script>
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Magic2 skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">Magic2</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Rashed Karim Wiki</h3>
			<div id="contentSub">
				<div id="mw-revision-info">Revision as of 21:40, 10 August 2012 by <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:Admin&amp;action=edit&amp;redlink=1" class="new mw-userlink" title="User:Admin (page does not exist)">Admin</a>  <span class="mw-usertoollinks">(<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:Admin&amp;action=edit&amp;redlink=1" class="new" title="User talk:Admin (page does not exist)">Talk</a>&#32;|&#32;<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Contributions/Admin" title="Special:Contributions/Admin">contribs</a>)</span></div>

				<div id="mw-revision-nav">(<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;diff=prev&amp;oldid=1569" title="Magic2">diff</a>) <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;direction=prev&amp;oldid=1569" title="Magic2">← Older revision</a>&#32;|&#32;Current revision (diff)&#32;|&#32;Newer revision → (diff)</div>
			</div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<a name="Version" id="Version"></a><h2> <span class="mw-headline"> Version </span></h2>
<p>Magic2 runs on the latest libraries (2011) of ITK, VTK and OpenCV. However, note that it has functions that are different from <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic" class="external text" title="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic" rel="nofollow">Magic1</a>. 
</p>
<a name="Usage" id="Usage"></a><h2> <span class="mw-headline"> Usage </span></h2>
<ul><li> Staple 
<ul><li> <b>Obtain STAPLE of segmentation</b>: Specify the staple output (from <a href="http://crl.med.harvard.edu/software/STAPLE/index.php" class="external text" title="http://crl.med.harvard.edu/software/STAPLE/index.php" rel="nofollow">crlSTaple</a>) and use the <b>--staple</b> switch
</li><li> An alternative ITK implementation of STAPLE <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=ITK_staple" class="external text" title="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=ITK_staple" rel="nofollow">here</a> 
</li><li> Code for comparing segmentations with Staple outputs using Dice <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Staple_dice" class="external text" title="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Staple_dice" rel="nofollow">here</a>
</li><li> A question I had once asked on the ITK mailing list <a href="http://old.nabble.com/STAPLE-question-td30806614.html" class="external text" title="http://old.nabble.com/STAPLE-question-td30806614.html" rel="nofollow">here</a>
</li></ul>
</li></ul>
<p><br />
</p>
<ul><li> Connected components 
<ul><li> <b>Obtain connected component index output image</b>: Specify the binary image and first use the <b>-concomp</b> switch to obtain the connected component output. The output is from the <a href="http://www.itk.org/Doxygen/html/classitk_1_1HardConnectedComponentImageFilter.html" class="external text" title="http://www.itk.org/Doxygen/html/classitk_1_1HardConnectedComponentImageFilter.html" rel="nofollow">itk</a> HardConnectedComponentImageFilter. Each pixel in the binary image is indexed in the output image. This is the index of the connected component it belongs to 
</li><li> <b>Filter connected components based on top N</b>: You can obtain the top N percent (in terms of size) connected components using the <b>-concompfilter</b> switch. 
</li></ul>
</li></ul>
<a name="Source_code" id="Source_code"></a><h2> <span class="mw-headline"> Source code </span></h2>
<pre>
#include &quot;rk_test4.h&quot;


int main(int argc, char **argv)
{
	int option;
	bool foundArgs=false; 
	irtkRealImage img1, img2; 
	irtkGreyImage img3; 
	char* input_f1=&quot;&quot;, *output_f=&quot;&quot;, *input_f2=&quot;&quot;, *observer_abb=&quot;&quot;, *working_dir=&quot;&quot;, *prefix=&quot;&quot;, *ext=&quot;&quot;;;
	int t1, t2, t3; 

	if (argc &gt;= 1)
	{
		for (int i = 1; i &lt; argc; i++) {
			if (i + 1&nbsp;!= argc) {
				if (string(argv[i]) == &quot;-i1&quot;) {
					input_f1 = argv[i+1]; 
					foundArgs = true;	
				} else if (string(argv[i]) == &quot;-i2&quot;) {
					input_f2 = argv[i+1]; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;-o&quot;) {
					output_f = argv[i+1];
					foundArgs = true;  
				}
				else if (string(argv[i]) == &quot;-t1&quot;) {
					t1 = atoi(argv[i+1]);
					foundArgs = true;  
				}
				else if (string(argv[i]) == &quot;-t2&quot;) {
					t2 = atoi(argv[i+1]);
					foundArgs = true;  
				}
				else if (string(argv[i]) == &quot;-t3&quot;) {
					t3 = atoi(argv[i+1]);
					foundArgs = true;  
				}
				
				 // all method switches here 
				else if (string(argv[i]) == &quot;--icp&quot;) {
					option = 1; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--chbin&quot;) {
					option = 2; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--molli1&quot;) {
					option = 3; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--molli2&quot;) {
					option = 4; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--molli3&quot;) 
				{
					option = 9; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--concomp&quot;) {
					option = 5; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--concompfilter&quot;) {
					option = 6; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--staple&quot;) {
					option = 7; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--toCGAL&quot;) {
					option = 8; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--postseg&quot;) {
					option = 9; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--clean&quot;) {
					option = 10; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--cleanall&quot;) {
					option = 11; 
					foundArgs = true; 
				}
				else if (string(argv[i]) == &quot;--segmask&quot;) {
					option = 12; 
					foundArgs = true; 
				}
			

			}
		}
	}

	if (foundArgs == false)
	{
		cout &lt;&lt; &quot;\n\nUsage: rk_magic \n\n\tArguments:&quot;
			&quot;\n\n\tFunction: Iterative closest point transform (switch = --icp x)\n\t1) -i1&nbsp;: Target surface in VTK\n\t2) -i2&nbsp;: Source surface in VTK \n\t3) -o&nbsp;: Output filename. Note the target surface is transformed into source (also in VTK)&quot;
			&quot;\n\n\tFunction: Change binary seg pixel value (switch = --chbin x)\n\t1) -i1&nbsp;: Binary image \n\t2) -o&nbsp;: Output filename\n\r 3) -t1: pixel value\n\t4) -t2: new pixel value&quot;
			&quot;\n\n\tFunction: Connected component (switch = --concomp x)\n\t1) -i1&nbsp;: Binary image \n\t2) -o&nbsp;: Output filename\n\r&quot;
			&quot;\n\n\tFunction: Connected component filter (switch = --concompfilter x)\n\t1) -i1&nbsp;: connected component image filter output \n\t2) -o&nbsp;: Output filename\n\r 3) -t1 top N largest components, N as a percent, for example top 90 percent&quot;
			&quot;\n\n\tFunction: MOLLI Function 1: Gets the mean and std. dev of mask across all timepoints. Expects exactly 11 timepoints (switch --molli1)\n\t1) -i1&nbsp;: Combined t1 to t11 molli image stack. \n\t2) -i2&nbsp;: Segmented mask. \n\t3) -t1&nbsp;: label value in mask \n\t4) -o&nbsp;: output text file&quot;
			&quot;\n\n\tFunction: MOLLI Function 2: Gets the epi- and endo-cardial borders from a manual segmentation of the myocardium (switch --molli1)\n\t1) -i1&nbsp;: Segmented mask. \n\t2) -t1&nbsp;: label value in mask for myocardium \n\t3) -o&nbsp;: output file containing epi- and endo-&quot;
			&quot;\n\n\tFunction: MOLLI Function 3: Computes the error between epi- and endo-cardial boundaries \n\t1) -i1&nbsp;: Segmented mask. \n\t2) -t1&nbsp;: label value in mask for myocardium \n\t3) -o&nbsp;: output file containing epi- and endo-&quot;
			&quot;\n\n\tFunction: STAPLE (switch = --staple x)&nbsp;: Rescales the output of STAPLE algorithm of S. Warfield and writes prob. values to 3D re-scaled (0-100)\n\t1) -i1&nbsp;: Output 4D image from STAPLE program. \n\t2) -i2&nbsp;: Segmentation mask on which staple was run\n\t3) -o&nbsp;: output 3D filename&quot;
			&quot;\n\n\tFunction: CGAL (switch = --toCGAL x)&nbsp;: \n\t 1) -i1&nbsp;: VTK file\n\t2) -o&nbsp;: New CGAL filename (.off)&quot;
			&quot;\n\n\tFunction: PostSeg (switch = --postseg x)&nbsp;: \n\t 1) -i1&nbsp;: model update log file\n\t&quot;
			&quot;\n\nPost seg clean functions: (must be run afer postscar3d.bat\ns=========================\n&quot;
			&quot;\n\n\tFunction: PostSeg Clean (switch = --clean x)&nbsp;: \n\t 1) -t1&nbsp;: Num of _gc_seg_outs\n\t2) -t2&nbsp;: Num (ie. index) of optimal segmentation\n\t3) -o&nbsp;: Rename _Gc_seg_out_final to&nbsp;??\n\t4) -ext&nbsp;: file extension (gipl or nii)&quot;
			&quot;\n\n\tFunction: PostSeg Clean (switch = --cleanall x)&nbsp;: \n\t 1) -t1&nbsp;: Num of _gc_seg_outs\n\t2) -t2&nbsp;: Num (i.e. index) of optimal segmentation \n\t3) -o&nbsp;: Rename _Gc_seg_out_final to&nbsp;??\n\t4) -ext&nbsp;: file extension (gipl or nii)&quot;
			&quot;\n\n\tFunction: Segmask (switch = --segmask x)&nbsp;: \n\t 1) -i1&nbsp;: binary mask file \n\t2) -i2&nbsp;: binary segmentation file \n\t3) -o&nbsp;: output binary segmentation filename \n&quot;


			&quot;\n\n\n\t--h for help&quot; &lt;&lt; endl;
		exit(0);
	}

	if (option == 1) 
	{
		ICPDriver(input_f1, input_f2, output_f, 100); 
	}
	else if (option == 2)
	{
		img1.Read(input_f1); 
		changeBinPixelValue(&amp;img1, t1, t2,output_f);
	}
	else if (option == 3) 
	{
		img1.Read(input_f1); 
		img2.Read(input_f2); 
		GetMeanAndSDevOfMask_MOLLI_1(&amp;img1, &amp;img2, output_f, t1); 
	}
	else if (option == 4) 
	{
		img1.Read(input_f1); 
		//img2.Read(input_f2); 
		GetEpiAndEndo_MOLLI_2(&amp;img1, output_f, t1); 
	}
	else if (option == 5) 
	{
		GetConnectedComponents(input_f1, output_f);
	}
	else if (option == 6) 
	{
		img3.Read(input_f1); 
		GetTopNConnectedComponents(&amp;img3, output_f, t1); 
	}
	else if (option == 7) 
	{
		img1.Read(input_f1); 
		img2.Read(input_f2); 
		StapleAnalyze(&amp;img1, &amp;img2, output_f); 
	}
	else if (option == 8) 
	{
		cout &lt;&lt; &quot;CGAL adapter: Converting to CGAL&quot; &lt;&lt; endl;
		CGALAdapter(input_f1, output_f, 1);
	} 
	else if (option == 9) 
	{
		img1.Read(input_f1); 
		//img2.Read(input_f2); 
		
		ComputeError_MOLLI_3(&amp;img1, t1, t2, t3, output_f); 
	} 
	else if (option == 10 || option == 11) 
	{
		if (strlen(ext) == 0)
			ext = &quot;gipl&quot;; 
		if (option == 10) 
			cleanPostSegProcessing(t1, t2, output_f, ext, false); 
		else 
			cleanPostSegProcessing(t1, t2, output_f, ext, true); 
		cout &lt;&lt; &quot;Post-seg process file clean&quot; &lt;&lt; endl;
		
	}
	else if (option == 12) 
	{
		segmask(input_f1, input_f2, output_f); 
		cout &lt;&lt; &quot;Segmask running .. &quot; &lt;&lt; endl;
	}
	
		
}

static void changeBinPixelValue(irtkRealImage* bin_image, int t, int new_pixel_value, char* output_f) 
{
	irtkRealPixel* p; 

	p = bin_image-&gt;GetPointerToVoxels(); 

	for (int i=0;i&lt;bin_image-&gt;GetNumberOfVoxels();i++)
	{
		if (*p == t)
			*p = new_pixel_value; 
		p++;
	}

	bin_image-&gt;Write(output_f);

}

static void CentreOfGravityAlignment(vtkPolyData* targetPoly, vtkPolyData* sourcePoly, vtkPolyData* transformedSourcePoly)
{
	
}

static void generateVertices(vtkPolyData* inPoly, vtkPolyData* outPoly) 
{
	int numpoints; 
	numpoints = inPoly-&gt;GetPointData()-&gt;GetNumberOfTuples(); 
	cout &lt;&lt; &quot;Number of points in this polydata = &quot; &lt;&lt; numpoints &lt;&lt; endl &lt;&lt; endl;
	vtkSmartPointer&lt;vtkMaskPoints&gt; maskPoints = vtkSmartPointer&lt;vtkMaskPoints&gt;::New();
	maskPoints-&gt;SetInput(inPoly);
	maskPoints-&gt;SetMaximumNumberOfPoints(numpoints);
	maskPoints-&gt;GenerateVerticesOn();
	maskPoints-&gt;SetOutput(outPoly); 
}

static void ICPDriver(char* target_f, char* source_f, char* output_f, int iterations) 
{
	vtkSmartPointer&lt;vtkPolyData&gt; target = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 
	vtkSmartPointer&lt;vtkPolyData&gt; source = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 

	vtkSmartPointer&lt;vtkPolyData&gt; temp_target = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 
	vtkSmartPointer&lt;vtkPolyData&gt; temp_source = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 

	vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New(); 
	reader-&gt;SetFileName(target_f); 
	reader-&gt;Update(); 
	target-&gt;DeepCopy(reader-&gt;GetOutput()); 

	reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New(); 
	reader-&gt;SetFileName(source_f); 
	reader-&gt;Update(); 
	source-&gt;DeepCopy(reader-&gt;GetOutput());


/*
	generateVertices(temp_target, target); 
	generateVertices(temp_source, source); */
	if (!target-&gt;GetNumberOfPoints() ||&nbsp;!source-&gt;GetNumberOfPoints()) 
	{
		cout &lt;&lt; &quot;Target num points = &quot; &lt;&lt; target-&gt;GetNumberOfPoints() &lt;&lt; endl;
		cout &lt;&lt; &quot;Source num points = &quot; &lt;&lt; source-&gt;GetNumberOfPoints() &lt;&lt; endl;
		cerr &lt;&lt; &quot;Cannot run ICP as either the source of target has no points&quot; &lt;&lt; endl;
		return;
	}
	
	 vtkSmartPointer&lt;vtkIterativeClosestPointTransform&gt; icp = vtkSmartPointer&lt;vtkIterativeClosestPointTransform&gt;::New();
	  icp-&gt;SetSource(target);
	  icp-&gt;SetTarget(source);
	  icp-&gt;GetLandmarkTransform()-&gt;SetModeToRigidBody();
	  icp-&gt;SetMaximumNumberOfIterations(iterations);
	  //icp-&gt;StartByMatchingCentroidsOn();
	  icp-&gt;Modified();
	  icp-&gt;Update();

	   vtkSmartPointer&lt;vtkMatrix4x4&gt; m = icp-&gt;GetMatrix();
	  std::cout &lt;&lt; &quot;The resulting matrix is: &quot; &lt;&lt; *m &lt;&lt; std::endl;
	 
	  // Transform the source points by the ICP solution
	  vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; icpTransformFilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
	  icpTransformFilter-&gt;SetInput(source);
	  icpTransformFilter-&gt;SetTransform(icp);
	  icpTransformFilter-&gt;Update();

	  vtkSmartPointer&lt;vtkPolyDataWriter&gt; writer = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New(); 
	  writer-&gt;SetInput(icpTransformFilter-&gt;GetOutput()); 
	  writer-&gt;SetFileName(output_f); 
	  writer-&gt;Update();
}

static bool MolliFileCheck(irtkRealImage* molli_stack, irtkRealImage* mask) 
{

	if (mask-&gt;GetX()&nbsp;!= molli_stack-&gt;GetX() &amp;&amp; mask-&gt;GetY()&nbsp;!= molli_stack-&gt;GetY() &amp;&amp; mask-&gt;GetZ()&nbsp;!= molli_stack-&gt;GetZ())
	{
		std::cerr &lt;&lt; &quot;Dimensions of molli time stack and mask don't agree .. exiting&quot; &lt;&lt; endl; 
		return false; 
	}
	else 
		return true; 
}

static int MolliGetTimePointAtWhichMaskAvailable(irtkRealImage* mask, int label)
{
	int mask_at_timepoint=-1; 
	bool isFoundMaskVoxel = false; 
	// first we find the time-point where the mask is available 
	for (int i=0;i&lt;mask-&gt;GetX() &amp;&amp;&nbsp;!isFoundMaskVoxel;i++)
	{
		for (int j=0;j&lt;mask-&gt;GetY() &amp;&amp;&nbsp;!isFoundMaskVoxel;j++)
		{
			for (int k=0;k&lt;mask-&gt;GetZ() &amp;&amp;&nbsp;!isFoundMaskVoxel;k++)
			{
				if (mask-&gt;Get(i,j,k) == label) { 
					isFoundMaskVoxel =&nbsp;!isFoundMaskVoxel; 
					mask_at_timepoint = k; 
				}
			}
		}
	}

	if (mask_at_timepoint &lt; 0) 
		cerr &lt;&lt; &quot;A segmentation was not found in the mask provided!&quot; &lt;&lt; endl;
	return mask_at_timepoint; 
}

static void GetMeanAndSDevOfMask_MOLLI_1(irtkRealImage* molli_stack, irtkRealImage* mask, char* outputfile, int label)
{
	int mask_at_timepoint=-1; 
	double mean, variance; 
	
	vector&lt;double&gt; signals; 
	ofstream out; 
	out.open(outputfile); 

	if (!MolliFileCheck(molli_stack, mask)) 
		return; 
	
	mask_at_timepoint = MolliGetTimePointAtWhichMaskAvailable(mask, label); 
	if (mask_at_timepoint &lt; 0) 
		return; 
	
	for (int k=0;k&lt;molli_stack-&gt;GetZ();k++)		// run through all time points 
	{
		for (int i=0;i&lt;molli_stack-&gt;GetX();i++)
		{
			for (int j=0;j&lt;molli_stack-&gt;GetY();j++)
			{
				if (mask-&gt;Get(i,j,mask_at_timepoint) == label) 
				{
					signals.push_back(molli_stack-&gt;Get(i,j,k));
				}
			}
		}
		MathBox::getMeanVariance(signals, mean, variance);		
		out &lt;&lt; k &lt;&lt; &quot;\t&quot; &lt;&lt; mean &lt;&lt; &quot;\t&quot; &lt;&lt; variance &lt;&lt; endl;
		signals.clear();
		signals.resize(0);
		mean = -1; variance = -1;

	}

}

static void GetEpiAndEndo_MOLLI_2(irtkRealImage* mask, char* outputfile, int label)
{
	int maxX, maxY, k; 
	int mask_at_timepoint; 
	irtkRealImage output_im; 

	mask_at_timepoint = MolliGetTimePointAtWhichMaskAvailable(mask, label); 
	if (mask_at_timepoint &lt; 0) 
		return; 
	
	output_im =* mask; 
	irtkRealPixel* p; 
	p = output_im.GetPointerToVoxels(); 
	for (int i=0;i&lt;output_im.GetNumberOfVoxels();i++) 
	{
		*p = 0;		// reset the output image 
		p++;
	}

	
	maxX = mask-&gt;GetX(); maxY = mask-&gt;GetY(); 
	
	// find boundary voxels
	k = mask_at_timepoint;			// the mask is only available at a certain time point 
	for (int i=0;i&lt;maxX; i++)
	{
		for (int j=0;j&lt;maxY; j++)
		{
			if (i-1 &gt; 0 &amp;&amp; i+1 &lt;maxX &amp;&amp; j-1 &gt; 0 &amp;&amp; j+1 &lt; maxY)
			{
				if (mask-&gt;Get(i,j,k) == label)			// first find labelled voxel in mask 
				{
					if (mask-&gt;Get(i+1,j,k) == 0 ||		// now look around its neighbours to find if its a boundary voxel 
						mask-&gt;Get(i-1,j,k) == 0 || 
						mask-&gt;Get(i,j+1,k) == 0 || 
						mask-&gt;Get(i,j-1,k) == 0) 
					{
						output_im.Put(i,j,k, 1); 
					}
				}
			}
	
		}
	}
	output_im.Write(outputfile);
	
}

static void ComputeError_MOLLI_3_helper(vector&lt;int*&gt; epi_or_endo, int x, int y, int&amp; min_pos, double&amp; min_dist)
{
	double dist;
	min_dist = 1e9; 
	double *p1 = new double[2]; 
	double *p2 = new double[2]; 
	for (int i=0;i&lt;epi_or_endo.size();i++)
	{
		p1[0] = x; 
		p1[1] = y; 
		p2[0] = epi_or_endo[i][0]; 
		p2[1] = epi_or_endo[i][1]; 
		dist = MathBox::getEuclideanDistanceIn3D(p1, p2); 
		if (dist &lt; min_dist) { 
			min_dist = dist; 
			min_pos = i; 
		}
	}
	
	delete p1; 
	delete p2; 
}

static void ComputeError_MOLLI_3(irtkRealImage* epi_and_endo_mask, int epi_value, int endo_value, int reference_slice, char* outputFile)
{
	ofstream out(outputFile); 
	double tot_error_epi, tot_error_endo, min_dist; 
	int min_pos, slice_offset; 
	double tot_pixels_epi, tot_pixels_endo;
	vector&lt;int*&gt; ref_epi; 
	vector&lt;int*&gt; ref_endo; 
	vector&lt;double&gt; tot_distance_errors_at_nth_slice_epi;
	vector&lt;double&gt; mean_distance_errors_at_nth_slice_epi;
	vector&lt;double&gt; mean_distance_errors_at_nth_slice_endo;
	vector&lt;double&gt; tot_distance_errors_at_nth_slice_endo;

	int maxX, maxY, maxZ; 

	maxX = epi_and_endo_mask-&gt;GetX(); 
	maxY = epi_and_endo_mask-&gt;GetY(); 
	maxZ = epi_and_endo_mask-&gt;GetZ(); 

	// locate the epi and endo points and store their co-ordinates for computing distance differences later
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			if (epi_and_endo_mask-&gt;Get(i,j,reference_slice-1) == epi_value) { 
				ref_epi.push_back(new int[2]); 
				ref_epi[ref_epi.size()-1][0] = i;			// store the x and y co-ordinates for this epi boundary point 
				ref_epi[ref_epi.size()-1][1] = j;
				
			}
			else if (epi_and_endo_mask-&gt;Get(i,j,reference_slice-1) == endo_value) { 
				ref_endo.push_back(new int[2]); 
				ref_endo[ref_endo.size()-1][0] = i;			// store the x and y co-ordinates for this endo boundary point
				ref_endo[ref_endo.size()-1][1] = j;
			}
		}
	}

	for (int k=0;k&lt;maxZ;k++)
	{
		tot_error_epi = 0; 
		tot_error_endo = 0; 
		tot_pixels_epi = 0; 
		tot_pixels_endo = 0; 

		//if (k&nbsp;!= reference_slice-1)	{			// dont compute error for the reference slice itself ofcourse

			for (int i=0;i&lt;maxX;i++)
			{
				for (int j=0;j&lt;maxY;j++)
				{
					if (epi_and_endo_mask-&gt;Get(i,j,k) == epi_value) { 
						ComputeError_MOLLI_3_helper(ref_epi, i,j, min_pos, min_dist); 
						tot_error_epi += min_dist; 
						tot_pixels_epi++; 
					}
					else if (epi_and_endo_mask-&gt;Get(i,j,k) == endo_value) { 
						ComputeError_MOLLI_3_helper(ref_endo, i,j, min_pos, min_dist); 
						tot_error_endo += min_dist; 
						tot_pixels_endo++;
					}
				}
			}
			tot_distance_errors_at_nth_slice_epi.push_back(tot_error_epi); 
			tot_distance_errors_at_nth_slice_endo.push_back(tot_error_endo); 
			mean_distance_errors_at_nth_slice_epi.push_back(tot_error_epi/tot_pixels_epi); 
			mean_distance_errors_at_nth_slice_endo.push_back(tot_error_endo/tot_pixels_endo); 

		//}
	}

	
	out &lt;&lt; &quot;Slice number\tTotal Error\tMean Error\n&quot;; 
	out &lt;&lt; &quot;============\t===========\t==========\n&quot;; 
	for (int n=0;n&lt;=1;n++)
	{
		slice_offset = 1;
		if (n==0) out &lt;&lt; &quot;Epicardium:\n&quot;; 
		else if (n==1) out &lt;&lt; &quot;\n\nEndocardium:\n&quot;; 
		for (int i=0;i&lt;tot_distance_errors_at_nth_slice_epi.size();i++)
		{
			
				
				if (n==0)
				{
					if (i!= reference_slice - 1)
					out &lt;&lt; i +1&lt;&lt;  &quot;\t\t&quot; &lt;&lt; tot_distance_errors_at_nth_slice_epi[i] &lt;&lt; &quot;\t\t&quot; &lt;&lt; mean_distance_errors_at_nth_slice_epi[i] &lt;&lt; endl; 
				}
				else if (n==1)
				{
					if (i!= reference_slice - 1)
					out &lt;&lt; i+1 &lt;&lt; &quot;\t\t&quot; &lt;&lt; tot_distance_errors_at_nth_slice_endo[i] &lt;&lt; &quot;\t\t&quot; &lt;&lt; mean_distance_errors_at_nth_slice_endo[i] &lt;&lt; endl; 
				}
			
		}
	}
	out.close();
}

static void StapleAnalyze(irtkRealImage* img1, irtkRealImage* img2, char* filename) 
{
	int maxX, maxY, maxZ, maxT; 
	maxX  = img1-&gt;GetX(); 
	maxY = img1-&gt;GetY(); 
	maxZ = img1-&gt;GetZ(); 
	maxT = img1-&gt;GetT(); 
cout &lt;&lt; &quot;Running staple analyze .. maxX = &quot; &lt;&lt; maxX &lt;&lt; &quot;, maxY = &quot; &lt;&lt; maxY &lt;&lt; &quot;, maxZ = &quot; &lt;&lt; maxZ &lt;&lt; endl;
	for (int i=0;i&lt;maxX; i++)
	{
		for (int j=0;j&lt;maxY; j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				
				if (img1-&gt;Get(i,j,k,1) &gt; 0)
					img2-&gt;Put(i,j,k, 100*img1-&gt;Get(i,j,k,1));
				else 
					img2-&gt;Put(i,j,k,0);
				
			}
		}
	}

	img2-&gt;Write(filename); 
}

static void CGALAdapter(char* filename1, char* filename2, int option) 
{

	if (option == 1) 
	{
		// convert from VTK to CGAL mesh 
		iblVTKAdapters* adapter = new iblVTKAdapters();
		adapter-&gt;SetVTKPoly(filename1); 
		adapter-&gt;SetVTKAnadGetExternal(filename1, filename2, CGALPolyhedra);
	}
}

/*
*	connected components in image
*/
	
static void GetConnectedComponents(char* input_f, char* output_f)
{
  typedef itk::Image&lt;bool,3&gt; InputImageType;
  typedef itk::Image&lt;unsigned short,3&gt; OutputImageType;
  typedef InputImageType::IndexType IndexType;

  typedef itk::ImageFileReader&lt; InputImageType  &gt;  ReaderType;
  typedef itk::ImageFileWriter&lt; OutputImageType  &gt;  WriterType;

  InputImageType::Pointer inputimg = InputImageType::New();
  OutputImageType::Pointer outputimg = OutputImageType::New();

  ReaderType::Pointer reader = ReaderType::New();
  WriterType::Pointer writer = WriterType::New();
 
  
  reader-&gt;SetFileName( input_f  );
  writer-&gt;SetFileName( output_f );
  reader-&gt;Update(); 
  inputimg = reader-&gt;GetOutput(); 

 
  itk::HardConnectedComponentImageFilter&lt;InputImageType, OutputImageType&gt;::Pointer 
	  filter = itk::HardConnectedComponentImageFilter&lt;InputImageType, OutputImageType&gt;::New();
  filter-&gt;SetInput(inputimg); 
  filter-&gt;Update(); 
  outputimg = filter-&gt;GetOutput(); 

  writer-&gt;SetInput(outputimg); 
  writer-&gt;Update();


}

static void GetTopNConnectedComponents(irtkGreyImage* in_img, char* output_f, double t) 
{
	double N, N_t; 
	int* bins;
	int* bins_copy, *bins_index, *thresholded_index; 
	irtkGreyPixel* min, *max; 
	min = new irtkGreyPixel(); 
	max = new irtkGreyPixel();
	in_img-&gt;GetMinMax(min, max); 
	cout &lt;&lt; &quot;Running top connected component filter ... min = &quot; &lt;&lt; *min &lt;&lt; &quot;, max = &quot; &lt;&lt; *max &lt;&lt; endl;
	N = *max; 
	bins = new int[N+1]; 
	bins_index = new int[N+1]; 
	bins_copy = new int[N+1]; 
	thresholded_index = new int[N+1];
	
	for (int i=0;i&lt;N+1;i++)
	{
		bins[i] = 0;		// resetting the connected component indexes , this array will store the size of the connected components 
		bins_copy[i] = 0; 
		bins_index[i] = i; 
		thresholded_index[i] = 0;			// this array will specify which connected components have passed the user specified threshold 
	}

	irtkGreyPixel* p; 
	p = in_img-&gt;GetPointerToVoxels(); 
	for (int i=0;i&lt;in_img-&gt;GetNumberOfVoxels();i++) 
	{
		if (*p &gt; 0 &amp;&amp; *p &lt;= *max) {
			bins[*p]++; 
			bins_copy[*p]++; 
		}
		p++;
	}

	// now bubble sort 
	bubble_sort_helper(bins_copy, bins_index, N+1);	// bins index contains the re-arranged array indices after sorting 

	N_t = round((t/100.0)*N);		// but the user only wants the top t percent 
cout &lt;&lt; &quot;Only &quot; &lt;&lt; N_t &lt;&lt; &quot; connected components will thus be selected &quot; &lt;&lt; endl;

	for (int i=0;i&lt;N_t;i++)
	{
		thresholded_index[bins_index[i]] = 1;			// specifying after sorting, which connected components have passed and indexing them 
	}

	// now only filtering connected components in image (based on their entries in thresholded index)
	p = in_img-&gt;GetPointerToVoxels(); 
	for (int i=0;i&lt;in_img-&gt;GetNumberOfVoxels();i++) 
	{
		if (*p &gt; 0) 
			if (thresholded_index[*p] == 1)
				*p = 1; 
			else 
				*p = 0; 
		p++;
	}

	in_img-&gt;Write(output_f); 

}

static void bubble_sort_helper(int* vals, int* indexes, int arrayLength){
	int i, j, flag = 1;    // set flag to 1 to begin initial pass
	double temp;             // holding variable
	

     for(i = 1; (i &lt;= arrayLength) &amp;&amp; flag; i++)
     {
         flag = 0;
         for (j=0; j &lt; (arrayLength -1); j++)
         {
              if (vals[j+1] &gt; vals[j])      // ascending order simply changes to &lt;
              { 
                    temp = vals[j];             // swap elements
                    vals[j] = vals[j+1];
                    vals[j+1] = temp;
					
					// now the indexes of the array 
					temp = indexes[j]; 
					indexes[j] = indexes[j+1]; 
					indexes[j+1] = temp; 
                    flag = 1;               // indicates that a swap occurred.
               }
          }
     }
     return;   //arrays are passed to functions by address; nothing is returned
}


static void Scar3dPostSegProcessing(char* model_log) 
{
	ifstream* istream; 
	istream = new ifstream();
	istream-&gt;open(model_log); 
	string line_in_file; 
	char* line;
	char* tok; 
	double *prev_model_at_i = new double[3]; 
	double *curr_model_at_i = new double[3]; 
	int k=0, line_num=0, min_mean_gradient_pos;
	double min_mean_gradient = 1e9, mean_gradient; 


	if (istream-&gt;is_open())
	{
		while (!istream-&gt;eof())
		{
			getline(*istream, line_in_file);  
			line = new char[line_in_file.size()]; 
			strcpy(line, line_in_file.c_str()); 

			tok = strtok(line, &quot;\t&quot;); 
			k = 0;
			while (tok&nbsp;!= NULL)
			{
				curr_model_at_i[k++] = atof(tok); 
				tok = strtok(NULL, &quot;\t&quot;);	
			}
			
			if (line_num &gt; 0) { 
				mean_gradient = (curr_model_at_i[1]-prev_model_at_i[1])/prev_model_at_i[1];
				cout &lt;&lt; &quot;\nmean gradient at &quot; &lt;&lt; line_num &lt;&lt; &quot; = &quot; &lt;&lt; mean_gradient;
				if (min_mean_gradient &gt; mean_gradient) {
					min_mean_gradient = mean_gradient;
					min_mean_gradient_pos = line_num;
				}
			}
			
			for (int i=0;i&lt;3;i++)
			{
				prev_model_at_i[i] = curr_model_at_i[i];
			}
			
			//for (int i=0;i&lt;3;i++) delete line[i]; 
			line_num++;

		}
	}
	istream-&gt;close(); 

	cout &lt;&lt; &quot;\n\nMin gradient = &quot; &lt;&lt; min_mean_gradient &lt;&lt; &quot;\noptimal segmntation = _gc_seg_out_&quot; &lt;&lt; min_mean_gradient_pos+1 &lt;&lt; &quot;.gipl&quot; &lt;&lt; endl;
}


static void delete_file(string filename)
{
	/*
	if(boost::filesystem::exists(filename))
		boost::filesystem::remove(filename);*/
}


static void cleanPostSegProcessing(int num_gc_outs, int optimal_one, char* output_f, string file_extension, bool delete_le_and_gad)
{
	string fileNameToDelete; 
	std::stringstream s_str; 
	string fn=&quot;&quot;; 

	for (int i=1;i&lt;=num_gc_outs;i++)
	{
		if (i&nbsp;!= optimal_one)
		{
			
			s_str &lt;&lt; &quot;_gc_seg_out_&quot; &lt;&lt; i &lt;&lt; &quot;.&quot; &lt;&lt; file_extension; 
			delete_file(s_str.str());
		}
		
		s_str.str(&quot;&quot;);
	}
	
	
	fn = &quot;_prob_map&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_spatial_prior&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_truncated_dilated_seg&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_marrouche_aw&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_atrial_wall&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_blood_pool&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_dilated_seg&quot;; delete_file(fn+&quot;.&quot;+file_extension);
	fn = &quot;_mask.nii.gz&quot;;delete_file(fn+&quot;.&quot;+file_extension);

	s_str.str(&quot;&quot;); 
	s_str &lt;&lt; output_f &lt;&lt; &quot;.&quot;+file_extension; 
	fn = &quot;_gc_seg_out_final&quot;;
	//if(boost::filesystem::exists(fn+&quot;.&quot;+file_extension))
	//	boost::filesystem::rename(fn+&quot;.&quot;+file_extension, s_str.str());
	

	if (delete_le_and_gad)
	{
		fn = &quot;_le&quot;; delete_file(fn+&quot;.&quot;+file_extension); 
		fn = &quot;_gad_seg&quot;; delete_file(fn+&quot;.&quot;+file_extension); 
	}
	
}


static void segmask(char* img1,  char* img2, char* output_f)
{
	short temp1, temp2; 
	int n =0; 
	typedef short     PixelType;
	const   unsigned int        Dimension = 3;
	typedef itk::Image&lt; PixelType, Dimension &gt;    ImageType;
	typedef itk::ImageFileReader&lt; ImageType &gt;  ReaderType;
	typedef itk::ImageFileWriter&lt; ImageType &gt;  WriterType;
	typedef itk::ImageRegionIterator&lt; ImageType&gt;       IteratorType; 

	ReaderType::Pointer reader1 = ReaderType::New();
	ReaderType::Pointer reader2 = ReaderType::New();
	

	reader1-&gt;SetFileName( img1  );
	reader1-&gt;Update();
	reader2-&gt;SetFileName( img2  );
	reader2-&gt;Update();

	ImageType::Pointer im1 = reader1-&gt;GetOutput();
	ImageType::Pointer im2 = reader2-&gt;GetOutput();

	IteratorType  it1( im1, im1-&gt;GetRequestedRegion() );
	IteratorType  it2( im2, im2-&gt;GetRequestedRegion() );
	  
	it1.GoToBegin();
	it2.GoToBegin();

	while(&nbsp;!it1.IsAtEnd() &amp;&amp;&nbsp;!it2.IsAtEnd() )
	{
		temp1 = it1.Get(); 
		temp2 = it2.Get(); 

		if (temp1 &lt;= 0 &amp;&amp; temp2 &gt; 0) 
		{
			it2.Set(0); 
			n++; 
		}

		++it1; ++it2; 
	}

	WriterType::Pointer writer = WriterType::New();
	writer-&gt;SetFileName(output_f); 
	writer-&gt;SetInput(im2); 
	writer-&gt;Update();
	cout &lt;&lt; &quot;Total voxels that were found to be outside mask and still in segmentation = &quot; &lt;&lt; n &lt;&lt; endl;

	
}
</pre>
<a name="Header_file" id="Header_file"></a><h2> <span class="mw-headline"> Header file </span></h2>
<pre>
#define HAS_VTK 1
#define _IS_DEBUG 1

#include &quot;vtkPointData.h&quot;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkCommand.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkContourFilter.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkImageToPolyDataFilter.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkCallbackCommand.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkImagePlaneWidget.h&gt;
#include &lt;vtkImageActor.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkPolyDataWriter.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkIterativeClosestPointTransform.h&gt;
#include &lt;vtkLandmarkTransform.h&gt;
#include &lt;vtkMath.h&gt;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkMaskPoints.h&gt;

#include &lt;irtkImage.h&gt;


#include &lt;stdio.h&gt;    // to get &quot;printf&quot; function
#include &lt;stdlib.h&gt;   // to get &quot;free&quot; function

// itk libraries

#include &quot;itkHardConnectedComponentImageFilter.h&quot;
#include &quot;itkImageRegionIterator.h&quot;

#include &quot;itkImage.h&quot;
#include &quot;itkImageFileReader.h&quot;
#include &quot;itkImageFileWriter.h&quot;


// my libs 
#include &lt;mathBoxCore.h&gt;
#include &quot;iblVTKAdapters.h&quot; 
//#include &lt;boost/filesystem.hpp&gt; 

static void ICPDriver(char* target_f, char* source_f, char* output_f, int iterations);
static void generateVertices(vtkPolyData* inPoly, vtkPolyData* outPoly);

// All Molli routines
static void GetMeanAndSDevOfMask_MOLLI_1(irtkRealImage* molli_stack, irtkRealImage* mask, char* outputfile, int label);
static int MolliGetTimePointAtWhichMaskAvailable(irtkRealImage* mask, int label); 
static bool MolliFileCheck(irtkRealImage* molli_stack, irtkRealImage* mask);

static void GetEpiAndEndo_MOLLI_2(irtkRealImage* mask, char* outputfile, int label);
static void GetConnectedComponents(char* input_f, char* output_f);
static void GetTopNConnectedComponents(irtkGreyImage* in_img, char* output_f, double t);
static void bubble_sort_helper(int* vals, int* indexes, int size);
static void changeBinPixelValue(irtkRealImage* bin_image, int t, int new_pixel_value, char* output_f)&nbsp;;
static void StapleAnalyze(irtkRealImage* img1, irtkRealImage* img2, char* filename)&nbsp;;
static void CGALAdapter(char* filename1, char* filename2, int option)&nbsp;;
static void ComputeError_MOLLI_3_helper(vector&lt;int*&gt; epi_or_endo, int x, int y, int&amp; min_pos, double&amp; min_dist);
static void ComputeError_MOLLI_3(irtkRealImage* epi_and_endo_mask, int epi_value, int endo_value, int reference_slice, char* outputFile);
static void Scar3dPostSegProcessing(char* out);
static void cleanPostSegProcessing(int num_gc_outs, int optimal_one, char* output_f, string file_extension, bool delete_le_and_gad);
</pre>

<!-- 
NewPP limit report
Preprocessor node count: 11/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key rkarim:pcache:idhash:193-0!1!0!!en!2!edit=0 and timestamp 20180312122820 -->
<div class="printfooter">
Retrieved from "<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2">http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Talk:Magic2&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-anonuserpage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:159.92.151.128" title="The user page for the ip you&#039;re editing as [.]" accesskey="." class="new">159.92.151.128</a></li>
				<li id="pt-anontalk"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:159.92.151.128" title="Discussion about edits from this IP address [n]" accesskey="n" class="new">Talk for this IP</a></li>
				<li id="pt-anonlogin"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:UserLogin&amp;returnto=Magic2" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/images/myWikiLogo.gif);" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki">Main Page</a></li>
				<li id="n-Home"><a href="http://www.doc.ic.ac.uk/~rkarim/">Home</a></li>
				<li id="n-currentevents"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Rashed Karim Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:WhatLinksHere/Magic2" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChangesLinked/Magic2" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;oldid=1569&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&amp;oldid=1569" title="Permanent link to this revision of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="privacy"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Privacy_policy" title="Rashed Karim Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:About" title="Rashed Karim Wiki:About">About Rashed Karim Wiki</a></li>
					<li id="disclaimer"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:General_disclaimer" title="Rashed Karim Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.462 secs. --></body>
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Magic2&oldid=1569 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:19:08 GMT -->
</html>
