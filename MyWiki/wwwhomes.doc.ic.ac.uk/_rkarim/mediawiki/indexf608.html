<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&oldid=1370 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:49:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="robots" content="noindex,nofollow" />
		<meta name="keywords" content="P3DImageTools Source" />
		<link rel="shortcut icon" href="http://wwwhomes.doc.ic.ac.uk/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/opensearch_desc.php" title="Rashed Karim Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Rashed Karim Wiki RSS Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Rashed Karim Wiki Atom Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>P3DImageTools Source - Rashed Karim Wiki</title>
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/monobook/main.css?207" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE50Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE55Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE60Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE70Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/~rkarim/mediawiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/~rkarim/mediawiki/skins";
		var wgArticlePath = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=$1";
		var wgScriptPath = "/~rkarim/mediawiki";
		var wgScript = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://wwwhomes.doc.ic.ac.uk/";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "P3DImageTools_Source";
		var wgTitle = "P3DImageTools Source";
		var wgAction = "view";
		var wgArticleId = 228;
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 1370;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/ajax.js?207"></script>
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-P3DImageTools_Source skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">P3DImageTools Source</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Rashed Karim Wiki</h3>
			<div id="contentSub">
				<div id="mw-revision-info">Revision as of 19:29, 15 April 2012 by <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:Admin&amp;action=edit&amp;redlink=1" class="new mw-userlink" title="User:Admin (page does not exist)">Admin</a>  <span class="mw-usertoollinks">(<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:Admin&amp;action=edit&amp;redlink=1" class="new" title="User talk:Admin (page does not exist)">Talk</a>&#32;|&#32;<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Contributions/Admin" title="Special:Contributions/Admin">contribs</a>)</span></div>

				<div id="mw-revision-nav">(diff) ← Older revision&#32;|&#32;Current revision (diff)&#32;|&#32;Newer revision → (diff)</div>
			</div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<pre>
#include &quot;p3DImageTools.h&quot;


p3DProcessDriver::p3DProcessDriver() 
{
	// constructor 
	_GetSliceNameParametersSuccess = false; 
	_isPortOpen = false; 
	_isSliceFolderPathSet = false; 
	_isImageDisplayedFirstTime = true; 

	_numInitSteps = 2; 
	_zeroesPaddedInSliceFileName = 5; 
	_sliceFileNamePrefix = &quot;ring_halfcut_scaled&quot;; 
	_sliceFilenameExt = &quot;png&quot;; 
	_TempImageSliceRepositoryName = &quot;temp&quot;;
	_currentInitViewState = 0;
	_currentNotInitViewState = 1;
	_waitTimeBetweenSerialComm = 14000;
	_waitTimeBetweenInitSlices = 15000;
	_waitTimeBetweenUAndD = 2000;
	_rgb_r = 142; 
	_rgb_g = 142;
	_rgb_b = 142; 

	 poly = vtkSmartPointer&lt;vtkPolyData&gt;::New();

	 _resolution_width = 1024; 
	_resolution_height = 768;
	_resolution_numSlices = 20;

	isZSlicingMinMaxOverride = false; 
	_zMin = -1e9; 
	_zMax = 1e9; 
	
	//defaults 	
	SetInitOverride(&quot;s,15,x,1,T,u,A,B,t&quot;);
	SetSliceOverride(&quot;W,25,x,1,T,u,A,B,t&quot;);
	_numberOfSlices = 109;
	openSerialComms();


} 

void p3DProcessDriver::SetNumInitSteps(int n) { _numInitSteps = n; }
void p3DProcessDriver::SetZeroesPaddedInSliceFileName(int n) { _zeroesPaddedInSliceFileName = n; }
void p3DProcessDriver::SetWaitTimeBetweenSerialComm(double t) { _waitTimeBetweenSerialComm = t*1000; }
void p3DProcessDriver::SetWaitTimeBetweenInitSlices(double t) { _waitTimeBetweenInitSlices = t*1000; } 
void p3DProcessDriver::SetGreyScale(int s) { _rgb_r = s; _rgb_g = s; _rgb_b = s; ConvertGreyScaleToHexColor();}
void p3DProcessDriver::SetSliceFileNamePrefix(string s) { _sliceFileNamePrefix = s;  }
void p3DProcessDriver::SetSliceFilenameExt(string s)  {	 _sliceFilenameExt = s;  }
void p3DProcessDriver::SetTempImageSliceRepositoryName(string s) { _TempImageSliceRepositoryName = s&nbsp;; }
void p3DProcessDriver::SetUseInitSlices(bool useInit)
{
	if (useInit)
		_currentInitViewState = 0;
	else
		_currentInitViewState = _numInitSteps+1;		
}

void p3DProcessDriver::SetZSlicingMin(double min)
{
	_zMin = min; 
	if (_zMin &gt; -1e9 &amp;&amp; _zMax &lt; 1e9)
		isZSlicingMinMaxOverride = true; 
}

void p3DProcessDriver::SetZSlicingMax(double max)
{
	_zMax = max; 
	if (_zMin &gt; -1e9 &amp;&amp; _zMax &lt; 1e9)
		isZSlicingMinMaxOverride = true; 
}




void p3DProcessDriver::SetSlicePath(string s)			// deprecated 
{
	_isSliceFolderPathSet = true; 
	std::replace( s.begin(), s.end(), '\\', '/');
	_sliceFolderPath = s; 
	
}

void p3DProcessDriver::SetSliceFolder(string s)
{
	stringstream ss; 
	_isSliceFolderPathSet = true; 
	std::replace( s.begin(), s.end(), '\\', '/');
	//_sliceFolderPath = s; 
	
	//ss &lt;&lt; s &lt;&lt; &quot;/&quot; &lt;&lt; _TempImageSliceRepositoryName;
	_directoryPathOfSlices = s;
	
}

void p3DProcessDriver::Set3DModelFilePath(string s)
{
	stringstream ss; 
	//std::replace( s.begin(), s.end(), '\\', '\');
	
	_3DModelFilePath = s;
	
}

	
bool p3DProcessDriver::Driver()
{
	bool b =true,c; 
	
	if (_isSliceFolderPathSet) 
	{
		cout &lt;&lt; &quot;Going in .. &quot; &lt;&lt; endl;
		c = this-&gt;Driver(_sliceFolderPath.c_str(), 1);
			cout &lt;&lt; &quot;Value of b = &quot; &lt;&lt; b &lt;&lt; endl;
			
		while (b) {
			cout &lt;&lt; &quot;Value of b = &quot; &lt;&lt; b &lt;&lt; endl;
			b = this-&gt;Driver(_sliceFolderPath.c_str(), 2);
		}
		return true; 
	}
	else 
		return false; 

}

void p3DProcessDriver::SetSlicingResolutionWidth(int w) { _resolution_width = w; } 
void p3DProcessDriver::SetSlicingResolutionHeight(int h) { _resolution_height = h; }  
void p3DProcessDriver::SetTotalSlicesInSlicing(int h) { 
	_resolution_numSlices  = h;
	cout &lt;&lt; &quot;Resolution of slicing changed to &quot; &lt;&lt; _resolution_numSlices &lt;&lt; endl; 
	_slice_spacing  = _resolution_numSlices; 
	_slice_spacing = (_zMax - _zMin)/_slice_spacing;
} 

bool p3DProcessDriver::Driver(int processStage) 
{
	stringstream ss; 
	int isProcessRunning=-1; 
	if (processStage == 3) 
	{
		ss &lt;&lt; &quot;slice.exe &quot; &lt;&lt; &quot; -o &quot; &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt &lt;&lt; &quot; -w &quot; &lt;&lt; _resolution_width &lt;&lt; &quot; -h &quot; &lt;&lt; _resolution_height &lt;&lt; &quot; -z &quot; &lt;&lt; _zMin &lt;&lt; &quot;,&quot; &lt;&lt; _zMax &lt;&lt; &quot;,&quot; &lt;&lt; _slice_spacing &lt;&lt; &quot; --core=#8E8E8E &quot; &lt;&lt; &quot;--cavity=#000000 --background=#000000 &quot; &lt;&lt; _3DModelFilePath&nbsp;;
		cout &lt;&lt; ss.str() &lt;&lt; endl;
		//GetSliceNameParameters(firstSliceFilePath); 
		
		CreateDirectory(_directoryPathOfSlices);
		current_path(_directoryPathOfSlices); 
		system(ss.str().c_str());
		
		
	}
	else if (processStage == 4) 
	{
		current_path(_directoryPathOfSlices); 
		GetTotalNumberOfSlicesAfterSlicing();
		RenameSlicesFromFreeSteelCOUK();
		CreateInitSlices();
//		CreateCVWindow();
		/*Beep(523,500);
		isProcessRunning = ReadNextSliceFromRepositoryAndDisplay();
		
		while (isProcessRunning&gt;0)
			isProcessRunning = ReadNextSliceFromRepositoryAndDisplay();*/
	}

	return true;	// reserved for shooting error messages up the tier 
}

bool p3DProcessDriver::Driver(const char* firstSliceFilePath, int processStage) 
{
	int isProcessRunning;
	stringstream ss; 
	if (processStage == 1) { 
		GetSliceNameParameters(firstSliceFilePath); 
		GetTotalNumberOfSlices();
		//ReadNextSlice();
		ss &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; _TempImageSliceRepositoryName;
		
		CreateDirectory(ss.str());
		ConvertSliceToGreyScale();
cout &lt;&lt; &quot;Now creating cv window .. &quot; &lt;&lt; endl;
		CreateCVWindow();
		cout &lt;&lt; &quot;Created cv window &quot; &lt;&lt; endl;
		return true;
	}
	else if (processStage == 2) 
	{
		Beep(523,500);
		isProcessRunning = ReadNextSliceFromRepositoryAndDisplay();

		
	//	SendSerialComm(&quot;U&quot;);
	//	SendSerialComm(&quot;D&quot;);
		if (isProcessRunning == -1)
			return false; 
		else 
			return true;


	}
	


}


/*
*	Deprecated 
*/
void p3DProcessDriver::GetSliceNameParameters(const char* firstSliceFilePath) 
{
	string firstSliceFilePathStr; 
	//string directoryPathOfFile;
	string::size_type pos;
	string fileNameExt;

	firstSliceFilePathStr = firstSliceFilePath; 
	pos = firstSliceFilePathStr.find_last_of( '/' );
	cout &lt;&lt; &quot;Slice path read = &quot; &lt;&lt; firstSliceFilePath &lt;&lt; endl;
	if (pos&nbsp;!= -1)
	{
		_directoryPathOfSlices = firstSliceFilePathStr.substr(0, pos); 
		
		// some hard-coding 
		_GetSliceNameParametersSuccess = true; 
		cout &lt;&lt; &quot;Original path to file: &quot; &lt;&lt; firstSliceFilePathStr &lt;&lt; &quot;\nFolder path: &quot; &lt;&lt; _directoryPathOfSlices &lt;&lt; endl;
		//cout &lt;&lt; &quot;Total slices in this folder = &quot; &lt;&lt; GetTotalNumberOfSlices() &lt;&lt; endl;
		
	}
	
}



void p3DProcessDriver::ReadNextSlice()
{
	stringstream fileNameStream; 
	for (int i=1;i&lt;=_numberOfSlices;i++)
	{
		fileNameStream &lt;&lt; _directoryPathOfSlices &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; i &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt &lt;&lt;endl;
		cout &lt;&lt; fileNameStream.str();
		fileNameStream.str(&quot;&quot;);
		fileNameStream.clear();
	}
}


void p3DProcessDriver::GetTotalNumberOfSlices() 
{
	// taken from http://stackoverflow.com/questions/6050298/how-do-i-count-the-number-of-files-in-a-directory-using-boostfilesystem
	if (_GetSliceNameParametersSuccess) { 
		path the_path( _directoryPathOfSlices);

		int cnt = std::count_if(
			directory_iterator(the_path),
			directory_iterator(),
			bind( static_cast&lt;bool(*)(const path&amp;)&gt;(is_regular_file), 
			bind( &amp;directory_entry::path, _1 ) ) 
			);
	    
		// a little explanation is required here,
		// we need to use static_cast to specify which 
		// version of is_regular_file function we intend to use

		_numberOfSlices =cnt; 
	}
	else {
		cerr &lt;&lt; &quot;Cannot get number of slices without determining slice fodler path. Invoke to GetSliceNameParameters is necessary or wasnt a success&quot; &lt;&lt; endl;
		_numberOfSlices = -1;
	}
}

void p3DProcessDriver::CreateDirectory(string dir_name)
{
	boost::filesystem::path dir(dir_name);
	if (boost::filesystem::is_directory(dir))		// if directory exists delete it 
		boost::filesystem::remove_all(dir); 

	if (boost::filesystem::create_directory(dir))
		std::cout &lt;&lt; &quot;Directory &quot; &lt;&lt; dir_name &lt;&lt; &quot; was successfully created&quot; &lt;&lt; &quot;\n&quot;;
}

void p3DProcessDriver::CreateInitSlices() 
{
	CvScalar s; 
	stringstream outputfilename, inputfilename; 
		
	//ofstream out; 
	IplImage* img;
	cout &lt;&lt; &quot;I got here, init steps = &quot; &lt;&lt; _numInitSteps &lt;&lt; endl;
	// the first init slices
	for (int k=1;k&lt;=_numInitSteps;k++)
	{
		outputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
		inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt; 
		cout &lt;&lt; &quot;Reading slices for creating init slices &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
		img = cvLoadImage(inputfilename.str().c_str());
		for (int i = 0; i &lt; img-&gt;height; i++)
		{
			for (int j = 0; j &lt; img-&gt;width; j++)
			{
				if (k == 1)
					cvSet2D(img,i,j,cvScalar(_rgb_r,_rgb_g,_rgb_b));
				else 
					cvSet2D(img,i,j,cvScalar(0,0,0));
			}
		}
		imwrite(outputfilename.str().c_str(), img);
		cout &lt;&lt; &quot;Init slices written to &quot; &lt;&lt; outputfilename.str().c_str() &lt;&lt; endl;
		//out.close();
		//cvReleaseImage(&amp;img);
		outputfilename.str(&quot;&quot;); outputfilename.clear(); 
		inputfilename.str(&quot;&quot;); inputfilename.clear();

	}
}




void p3DProcessDriver::ConvertSliceToGreyScale() 
{
	
	CvScalar s; 
	stringstream outputfilename, inputfilename; 
	IplImage* img;
	
	CreateInitSlices();
	for (int k=1;k&lt;=_numberOfSlices;k++)
	{
		outputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; _TempImageSliceRepositoryName &lt;&lt; &quot;/&quot; &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; &quot;png&quot;;
		inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; _sliceFileNamePrefix &lt;&lt;&quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt; 

		cout &lt;&lt; &quot;Input filename: &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
		cout &lt;&lt; &quot;Output filename: &quot; &lt;&lt; outputfilename.str().c_str() &lt;&lt; endl;

		//out.open(outputfilename.str().c_str());
		img = cvLoadImage(inputfilename.str().c_str());

		for (int i = 0; i &lt; img-&gt;height; i++)
		{
			for (int j = 0; j &lt; img-&gt;width; j++)
			{
				s=cvGet2D(img,i,j); 

				if (s.val[0] &gt; 0) {
					// use rgb this works 156,142,142
					cvSet2D(img,i,j,cvScalar(_rgb_r,_rgb_g,_rgb_b));
					//cvSet2D(img,i,j,cvScalar(255,255,255));
				}
				else if (s.val[0] == 0)
					cvSet2D(img,i,j,cvScalar(0,0,0));

			}
		}
		
		imwrite(outputfilename.str().c_str(), img);
		//out.close();
		cvReleaseImage(&amp;img);
		outputfilename.str(&quot;&quot;); outputfilename.clear(); 
		inputfilename.str(&quot;&quot;); inputfilename.clear();
		

	}
	
}





void p3DProcessDriver::SendSerialComm(string s) 
{
	cout &lt;&lt; &quot;Outputting to COM, character &quot; &lt;&lt; s &lt;&lt; endl;
	
	if (!_isPortOpen){
	    try {
			serial = new TimeoutSerial(&quot;COM7&quot;,9600);
			serial-&gt;setTimeout(boost::posix_time::seconds(0));
		}
		catch(boost::system::system_error&amp; e)
		{
			cout&lt;&lt;&quot;Error opening COM7 &quot;&lt;&lt;e.what()&lt;&lt;endl;
		}

		_isPortOpen = true;
	 }

	 
	 if (s == &quot;C&quot;) 
	 {
		serial-&gt;close();
	 }
	 else 
	 {
		try {
			serial-&gt;writeString(s);
		}
		catch(boost::system::system_error&amp; e)
		{
			cout&lt;&lt;&quot;Error writing&quot; &lt;&lt; s &lt;&lt; &quot;to port, error caused due to&nbsp;: &quot; &lt;&lt;e.what()&lt;&lt;endl;
		}
	 }
}

void p3DProcessDriver::WaitBetweenProcess(double secs)
{
	//Sleep(secs);
	 cvWaitKey(secs);
	
}

int p3DProcessDriver::ReadNextSliceFromRepositoryAndDisplay()
{
	stringstream inputfilename, inputfilename2;
	int k;
	IplImage* img, *img2;
	cout &lt;&lt; &quot;I should be displaying slices .. init state completed = &quot; &lt;&lt; _currentInitViewState &lt;&lt; &quot;, total = &quot; &lt;&lt; _numInitSteps &lt;&lt; endl;
	if (_currentInitViewState &lt; _numInitSteps)
	{
		// display init slices
		//vtkSmartPointer&lt;vtkImageData&gt; vtkData = vtkSmartPointer&lt;vtkImageData&gt;::New();
		k = 1;

		inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
		cout &lt;&lt; &quot;Displaying init slice &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
		img = cvLoadImage(inputfilename.str().c_str());
		//ConvertFromIpl2Vtk(img, vtkData);
		//DisplayVtkImage(vtkData, fl_vtk_window, renWin);
		DisplayCVImage(img);
		RemoveCVWindowBorder(img);
		cvReleaseImage(&amp;img);
		WaitBetweenProcess(_waitTimeBetweenInitSlices);
		inputfilename.str(&quot;&quot;); inputfilename.clear();

		k=2;
		inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
		//vtkData = vtkSmartPointer&lt;vtkImageData&gt;::New();
		img = cvLoadImage(inputfilename.str().c_str());
		//ConvertFromIpl2Vtk(img, vtkData);
		//DisplayVtkImage(vtkData, fl_vtk_window, renWin);
		DisplayCVImage(img);
		cvReleaseImage(&amp;img);
		cout &lt;&lt; &quot;Displaying init slice &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
		inputfilename.str(&quot;&quot;); inputfilename.clear();
		SendSerialComm(&quot;U&quot;);
		SendSerialComm(&quot;U&quot;);
		//WaitBetweenProcess(_waitTimeBetweenUAndD);
		SendSerialComm(&quot;D&quot;);
		SendSerialComm(&quot;D&quot;);
		WaitBetweenProcess(_waitTimeBetweenSerialComm);

		_currentInitViewState++;
		
		return 1;
	}
	else 
	{
		// display the actual slices 
		k = 2;
		if (_currentNotInitViewState &lt;= _numberOfSlices)
		{
			//vtkSmartPointer&lt;vtkImageData&gt; vtkData = vtkSmartPointer&lt;vtkImageData&gt;::New();
			inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot;  &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; _currentNotInitViewState &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
			inputfilename2 &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
			img = cvLoadImage(inputfilename.str().c_str());
			img2 = cvLoadImage(inputfilename2.str().c_str());
			//ConvertFromIpl2Vtk(img, vtkData);
			//DisplayVtkImage(vtkData, fl_vtk_window, renWin);
			DisplayCVImage(img);

			if (_isImageDisplayedFirstTime) {
				cout &lt;&lt; &quot;removing screen border .. &quot; &lt;&lt; endl;
				RemoveCVWindowBorder(img); 
				_isImageDisplayedFirstTime = false;
			}

			WaitBetweenProcess(_waitTimeBetweenInitSlices);
			cvReleaseImage(&amp;img);
			cout &lt;&lt; &quot;Displaying image slice &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
			
			DisplayCVImage(img2);
			SendSerialComm(&quot;U&quot;);
			SendSerialComm(&quot;U&quot;);
			//WaitBetweenProcess(_waitTimeBetweenUAndD);
			SendSerialComm(&quot;D&quot;);
			SendSerialComm(&quot;D&quot;);
			cout &lt;&lt; &quot;Displaying init slice &quot; &lt;&lt; inputfilename2.str().c_str() &lt;&lt; endl;
			WaitBetweenProcess(_waitTimeBetweenSerialComm);
			cvReleaseImage(&amp;img2);
			_currentNotInitViewState++;
			return 1; 
		}
		else
			return -1;
	}
}

void p3DProcessDriver::CreateCVWindow()
{
	
	cvNamedWindow(&quot;displayCVWindow&quot;, 0);
   cvSetWindowProperty(&quot;displayCVWindow&quot;, CV_WND_PROP_FULLSCREEN, CV_WINDOW_FULLSCREEN);

	// from stack overflow
	
   //cout &lt;&lt; &quot;I am here inside creating cv windows&quot; &lt;&lt; endl;
   /*
	cvNamedWindow(&quot;displayCVWindow&quot;, CV_WINDOW_AUTOSIZE);
	cvMoveWindow(&quot;displayCVWindow&quot;, 0, 0);
	cvSetWindowProperty(&quot;displayCVWindow&quot;, CV_WINDOW_FULLSCREEN, CV_WINDOW_FULLSCREEN);*/
}

void p3DProcessDriver::RemoveCVWindowBorder(IplImage* cv_img) 
{
	HWND win_handle = FindWindow(0, (LPCTSTR)&quot;displayCVWindow&quot;);
	if (!win_handle)
	{
		printf(&quot;Failed FindWindow\n&quot;);
	}

	// Resize
	
	unsigned int flags = (SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);
	flags &amp;= ~SWP_NOSIZE;
	unsigned int x = 0;
	unsigned int y = 0;
	unsigned int w = 1680;
	unsigned int h = 1050;
	SetWindowPos(win_handle, HWND_NOTOPMOST, x, y, w, h, flags);
	
	// Borderless
	//SetWindowLong(win_handle, GWL_STYLE, GetWindowLong(win_handle, GWL_EXSTYLE) | WS_EX_TOPMOST);
	SetWindowLong(win_handle, GWL_STYLE, 0);
	ShowWindow(win_handle, SW_SHOW);
}


void p3DProcessDriver::DisplayCVImage(IplImage* img)
{	
	cvShowImage(&quot;displayCVWindow&quot;, img);
}

bool p3DProcessDriver::ConvertFromIpl2Vtk( cv::Mat _src, vtkImageData* _dest )
{
    assert( _src.data&nbsp;!= NULL );

	//cv::Mat _src_flipped; 
	//cvFlip(&amp;_src, &amp;_src_flipped, -1); 
    vtkImageImport *importer = vtkImageImport::New();
    
	if ( _dest )
    {
        importer-&gt;SetOutput( _dest );
    }
    importer-&gt;SetDataSpacing( 1, 1, 1 );
    importer-&gt;SetDataOrigin( 0, 0, 0 );
    importer-&gt;SetWholeExtent(   0, _src.size().width-1, 0,_src.size().height-1, 0, 0 );
    importer-&gt;SetDataExtentToWholeExtent();
    importer-&gt;SetDataScalarTypeToUnsignedChar();
    importer-&gt;SetNumberOfScalarComponents( _src.channels() );
    importer-&gt;SetImportVoidPointer( _src.data );
    importer-&gt;Update();
    return true;
}

void  p3DProcessDriver::DisplayVtkImage(vtkImageData* vtkImgArr, vtkFlRenderWindowInteractor *&amp;fl_vtk_window, vtkRenderWindow* renWin)
{
	vtkSmartPointer&lt;vtkImageViewer2&gt; imageViewer2D = vtkSmartPointer&lt;vtkImageViewer2&gt;::New();
	imageViewer2D-&gt;SetInput(vtkImgArr);
	imageViewer2D-&gt;SetupInteractor(fl_vtk_window);
	imageViewer2D-&gt;SetRenderWindow(renWin);
	imageViewer2D-&gt;Render();
	imageViewer2D-&gt;GetRenderer()-&gt;ResetCamera();
}

void p3DProcessDriver::helloFromProcessClass()
{
	cout &lt;&lt; &quot;Hello from Process Class&quot; &lt;&lt; endl;
}
void p3DProcessDriver::Read_3D_model_display(string STLFileName, double* zMinMax)
{
	double *xyz_min; 
	double *xyz_max; 
	Set3DModelFilePath(STLFileName);
	vtkSmartPointer&lt;vtkSTLReader&gt; reader = vtkSmartPointer&lt;vtkSTLReader&gt;::New();
	reader-&gt;SetFileName(STLFileName.c_str());
	reader-&gt;Update();
	poly-&gt;DeepCopy(reader-&gt;GetOutput());

	xyz_min = new double[3]; 
	xyz_max = new double[3]; 
	VizBoxCore::GetPolyBounds(poly, xyz_min, xyz_max); 

	if (!isZSlicingMinMaxOverride) { 
		_zMin = xyz_min[2]; 
		_zMax = xyz_max[2]; 
	}

	
	
	cout &lt;&lt; &quot;Bounds = (xMin,yMin,zMin) = &quot; &lt;&lt; xyz_min[0] &lt;&lt; &quot;.&quot; &lt;&lt; xyz_min[1] &lt;&lt; &quot;.&quot; &lt;&lt; xyz_min[2] &lt;&lt; &quot;, (xMax, yMax, zMax) = &quot; &lt;&lt; xyz_max[0] &lt;&lt; &quot;.&quot; &lt;&lt; xyz_max[1] &lt;&lt; &quot;.&quot; &lt;&lt; xyz_max[2] &lt;&lt; &quot;\n&quot;;
	zMinMax[0] = _zMin; 
	zMinMax[1] = _zMax;

	vtkSmartPointer&lt;vtkActor&gt; ModelActor = vtkSmartPointer&lt;vtkActor&gt;::New(); 

	vtkSmartPointer&lt;vtkRenderer&gt; renderer1 = vtkSmartPointer&lt;vtkRenderer&gt;::New();
	vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow1 = vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
	renderWindow1-&gt;AddRenderer(renderer1);
	renderWindowInteractor1 = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
	renderWindowInteractor1-&gt;SetRenderWindow(renderWindow1);
	vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt; interactorStyle1 = vtkSmartPointer&lt;vtkInteractorStyleTrackballCamera&gt;::New();
	renderWindowInteractor1-&gt;SetInteractorStyle(interactorStyle1);



	VizBoxCore::VBC_DisplayPolyNoFLTK(renderWindowInteractor1, poly, false, false, true, ModelActor); 
	ModelActor-&gt;GetProperty()-&gt;SetColor(1,1,0);
	renderer1-&gt;SetBackground(0,0,0); 
	renderWindow1-&gt;Render();
	renderWindowInteractor1-&gt;Start();

	
	

}

void p3DProcessDriver::ConvertGreyScaleToHexColor() 
{
	stringstream ss1; 
	stringstream ssHex; 
	ssHex &lt;&lt; hex &lt;&lt; _rgb_r; 
	ss1 &lt;&lt; &quot;#&quot; &lt;&lt; ssHex;
	ssHex.str(&quot;&quot;); 
	ssHex &lt;&lt; hex &lt;&lt; _rgb_g; 
	ss1 &lt;&lt; ssHex;
	ssHex.str(&quot;&quot;); 
	ssHex &lt;&lt; hex &lt;&lt; _rgb_b; 
	ss1 &lt;&lt; ssHex;
	_greyScaleHexColor = ss1.str();

	
}


void p3DProcessDriver::RenameSlicesFromFreeSteelCOUK()
{
	string str, newname; 
	stringstream strstr, strstr2;
	int first, second, first_i, second_i; 
	const path &amp; directory= _directoryPathOfSlices.c_str();;
	bool recurse_into_subdirs = false;
	

	if( exists( directory ) )
	{
		directory_iterator end&nbsp;;
		for( directory_iterator iter(directory)&nbsp;; iter&nbsp;!= end&nbsp;; ++iter ) {
			if (&nbsp;!is_directory( *iter ) )
			{
			
				// rename files 
				strstr &lt;&lt; iter-&gt;path(); 
				str = strstr.str();
				first = str.find(&quot;(&quot;);
				second = str.find(&quot;)&quot;);
				first_i = str.find(&quot;\&quot;&quot;); 
				second_i = str.find(&quot;\&quot;&quot;);
				//cout &lt;&lt; &quot;First = &quot; &lt;&lt; first &lt;&lt; &quot;, second = &quot; &lt;&lt; second &lt;&lt; endl;
				if (first &gt; 0 &amp;&amp; second &gt; 0) {
					strstr2 &lt;&lt; str.substr(0, first) &lt;&lt; str.substr(second+1, str.length());
					newname = strstr2.str();

					//cout &lt;&lt; &quot;Old name = &quot; &lt;&lt; strstr.str().substr(1,str.length()-2) &lt;&lt; endl;
					//cout &lt;&lt; &quot;New name = &quot; &lt;&lt; newname.substr(1,newname.length()-2) &lt;&lt; endl &lt;&lt; endl;
					if(boost::filesystem::exists(strstr.str().substr(1,str.length()-2)))
					{
						//cout &lt;&lt; &quot;String length = &quot; &lt;&lt; newname.length() &lt;&lt; endl;
						//cout &lt;&lt; &quot;Last occurence = &quot; &lt;&lt; newname.find_last_of(&quot;\\&quot;)+1 &lt;&lt; endl&nbsp;;
						//cout &lt;&lt; newname.substr( newname.find_last_of(&quot;\\&quot;)+1,13);
						boost::filesystem::rename(strstr.str().substr(1,str.length()-2), newname.substr( newname.find_last_of(&quot;\\&quot;)+1,13));
					}
					else 
						cout &lt;&lt; &quot;Cannot find file &quot; &lt;&lt; endl;
				}

			strstr2.str(&quot;&quot;);
			strstr.str(&quot;&quot;);
			}
		}
	}
}

void p3DProcessDriver::GetTotalNumberOfSlicesAfterSlicing()
{
	/*
	path the_path( _directoryPathOfSlices);

		int cnt = std::count_if(
			directory_iterator(the_path),
			directory_iterator(),
			bind( static_cast&lt;bool(*)(const path&amp;)&gt;(is_regular_file), 
			bind( &amp;directory_entry::path, _1 ) ) 
			);
	  */  
		// a little explanation is required here,
		// we need to use static_cast to specify which 
		// version of is_regular_file function we intend to use

		//_numberOfSlices =cnt&nbsp;; 
		_currentNotInitViewState = _numberOfSlices;
}

void p3DProcessDriver::TokenizeOverride(string processString)
{
	char delim = ','; 
	vector&lt;string&gt; tokens; 
	split(processString, delim, tokens); 
	for (int i=0;i&lt;tokens.size();i++)
	{
		cout &lt;&lt; tokens[i] &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}



void p3DProcessDriver::DisplayBlack() 
{
	stringstream inputfilename;
	int k=2; 
	inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
	//cout &lt;&lt; &quot;Displaying init slice &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
	DisplayGenericImage(inputfilename.str().c_str());

}

void p3DProcessDriver::SetWXGUIImageDisplayer(XylusImgDisplayFrameHelper* frame) 
{
	ImageDisplayer = frame; 
}

void p3DProcessDriver::DisplayGenericImage(const char* path)
{
	string s; 
	stringstream ss; 
	ss &lt;&lt; path;
	s = ss.str();
	std::replace( s.begin(), s.end(), '/', '\\');
	ImageDisplayer-&gt;SetImageFromFile(s); 
	if (_isImageDisplayedFirstTime) { 
		ImageDisplayer-&gt;MakeVisible(); 
		//ImageDisplayer-&gt;ShowFullScreen(true, wxFULLSCREEN_ALL);
		_isImageDisplayedFirstTime =&nbsp;!_isImageDisplayedFirstTime;
	}

	cout &lt;&lt; &quot;Displaying &quot; &lt;&lt; s &lt;&lt; endl;
	ImageDisplayer-&gt;RefreshImage();
	//ImageDisplayer-&gt;Update();
	
}

/*
void p3DProcessDriver::DisplayGenericImage(const char* path)
{
	IplImage* img;
	img = cvLoadImage(path);
	DisplayCVImage(img);
	if (_isImageDisplayedFirstTime) { 
		RemoveCVWindowBorder(img);
		_isImageDisplayedFirstTime =&nbsp;!_isImageDisplayedFirstTime;
	}
	cvReleaseImage(&amp;img);
}*/

void p3DProcessDriver::DisplayWhite() 
{
	stringstream inputfilename;
	int k=1; 
	inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot; &lt;&lt; &quot;init_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; k &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
	//cout &lt;&lt; &quot;Displaying init slice &quot; &lt;&lt; inputfilename.str().c_str() &lt;&lt; endl;
	DisplayGenericImage(inputfilename.str().c_str());

}

void p3DProcessDriver::openSerialComms()
{
	serial = new TimeoutSerial(&quot;COM7&quot;,9600);
	serial-&gt;setTimeout(boost::posix_time::seconds(10));
}

bool p3DProcessDriver::SendCommandUsingTimeOutSerial(char command) 
{
	string writeChar, readChar; 
	bool isTimeout; 
	writeChar = command; 
	try {
			//Text test
			//writeChar = writeChars.at(i);
			cout &lt;&lt; &quot;Sending &quot; &lt;&lt; writeChar &lt;&lt; &quot;, waiting for reply .. reply = &quot;;
			serial-&gt;writeString(writeChar); 
			isTimeout = false;
			while (readChar&nbsp;!= writeChar) {
				try { 
					readChar = serial-&gt;readString(1);				
				}
				catch (timeout_exception&amp; e)
				{
					readChar = writeChar;
					isTimeout = true; 
				}
			}

			if (!isTimeout) { 
				cout &lt;&lt; readChar &lt;&lt; endl;
				return true; 
			}
			else { 
				cout &lt;&lt; &quot;Nothing received but timeout, &quot; &lt;&lt; endl;
				return ResendCommandUsingTimeOutSerial(command);
			}
			

	 
		} catch(boost::system::system_error&amp; e)
		{
			cout&lt;&lt;&quot;Error: &quot;&lt;&lt;e.what()&lt;&lt;endl;
			return false;
		}
}

bool p3DProcessDriver::ResendCommandUsingTimeOutSerial(char command) 
{
	string writeChar, readChar; 
	bool isTimeout; 
	writeChar = command; 
	try {
			//Text test
			//writeChar = writeChars.at(i);
			cout &lt;&lt; &quot;***Re-Sending***&quot; &lt;&lt; writeChar &lt;&lt; &quot;, waiting for reply .. reply = &quot;;
			serial-&gt;writeString(writeChar); 
			isTimeout = false;
			while (readChar&nbsp;!= writeChar) {
				try { 
					readChar = serial-&gt;readString(1);				
				}
				catch (timeout_exception&amp; e)
				{
					readChar = writeChar;
					isTimeout = true; 
				}
			}

			if (!isTimeout) { 
				cout &lt;&lt; readChar &lt;&lt; endl;
				return true; 
			}
			else { 
				cout &lt;&lt; &quot;Nothing received but timeout&quot; &lt;&lt; endl;
			}
	 
		} catch(boost::system::system_error&amp; e)
		{
			cout&lt;&lt;&quot;Error: &quot;&lt;&lt;e.what()&lt;&lt;endl;
			return false; 
		}
}

bool p3DProcessDriver::SendCommand(char command)
{
	int retVal; 
	bool isTestMode = true; 
	if (!isTestMode) { 
		CString port(_T(&quot;COM7&quot;)); 
		stringstream ss; 
		ss &lt;&lt; command; 
		
		// send comamnd 
		cout &lt;&lt; &quot;Sending command = &quot; &lt;&lt; command &lt;&lt; &quot;, now waiting ... &quot;;
		//SendSerialComm(ss.str()); 
		MyWindowsHackWriteByte(port, command);
		
		// Now wait until eternity for command 
		retVal = MyWindowsHackReadByte(port);
		char cReceived = static_cast&lt;char&gt;(retVal);
		const char* cReceivedp = &amp;cReceived;
		const char* commandp = &amp;command; 
		cout &lt;&lt; &quot;Received = \&quot;&quot; &lt;&lt; cReceived &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;

		if (strcmp(cReceivedp, commandp) == 0)
			return true; 
		else	
			return false; 
	}
	else
	{
		Sleep(1000);
	}

}

void p3DProcessDriver::WaitForSeconds(int secs)
{
	/*
	boost::asio::io_service io;
	boost::asio::deadline_timer t(io, boost::posix_time::seconds(secs));
	t.wait();*/
	//cvWaitKey(secs*1000);
	Sleep(secs*1000);

}

void p3DProcessDriver::DisplayCurrentModelSlice()
{
	
	stringstream inputfilename; 
	
	inputfilename &lt;&lt; _directoryPathOfSlices &lt;&lt; &quot;/&quot;  &lt;&lt; _sliceFileNamePrefix &lt;&lt; &quot;_&quot; &lt;&lt; setfill('0') &lt;&lt; setw(_zeroesPaddedInSliceFileName) &lt;&lt; _currentNotInitViewState-- &lt;&lt; &quot;.&quot; &lt;&lt; _sliceFilenameExt;
	DisplayGenericImage(inputfilename.str().c_str());
}


std::vector&lt;std::string&gt;&amp; p3DProcessDriver::split(const std::string &amp;s, char delim, std::vector&lt;std::string&gt; &amp;elems) {
    std::stringstream ss(s);
    std::string item;
    while(std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


void p3DProcessDriver::ProcessOverrideDriver() 
{
	// first the init loop 
	
	bool isCommandSuccess;
	stringstream currentStatus;
	ofstream out, out2;
	time_t seconds1, seconds2; 
	long int seconds1_int, seconds2_int; 
	bool onlyOnce = true; 
	double time_for_one_slice, time_remaining; 
	
	//current_path(_directoryPathOfSlices); 
	GetTotalNumberOfSlicesAfterSlicing();
	//RenameSlicesFromFreeSteelCOUK();
	//CreateInitSlices();
	//CreateCVWindow();
	out.open(&quot;slicer_log.txt&quot;); 
	cout &lt;&lt; &quot;Total number of init commands = &quot; &lt;&lt; _initOverride.size() &lt;&lt; endl;
	cout &lt;&lt; &quot;Total number of slice commands = &quot; &lt;&lt; _sliceOverride.size() &lt;&lt; endl;
	cout &lt;&lt; &quot;Init loop = &quot; &lt;&lt; _initLoop &lt;&lt; endl;
	
	for (int i=0;i&lt;_initLoop;i++)
	{
		
		for (int j=0;j&lt;_initOverride.size();j++)
		{
			if (_initOverride[j] == &quot;X&quot; || _initOverride[j] == &quot;x&quot; )			/* Comamnd to show black image */
			{
				out &lt;&lt; &quot;\nProcess: B - printing black&quot;; 
				DisplayBlack();
			}
			else if (_initOverride[j] == &quot;W&quot; || _initOverride[j] == &quot;w&quot;)			/* Comamnd to show white/grey image */
			{
				out &lt;&lt; &quot;\nProcess: W - printing white&quot;; 
				DisplayWhite();

			}
			else if (std::string::npos&nbsp;!= _initOverride[j].find_first_of(&quot;0123456789&quot;))			/* Command to wait */
			{
				out &lt;&lt; &quot;\nProcess: wait - &quot; &lt;&lt; _initOverride[j] &lt;&lt; &quot; secs&quot;;
				WaitForSeconds(atoi(_initOverride[j].c_str()));
				
			}
			else if (std::string::npos&nbsp;!= _initOverride[j].find_first_of(&quot;ABiTtDdUu&quot;))				/* Command to move printer head */
			{
				out &lt;&lt; &quot;\nProcess: send command - &quot; &lt;&lt; _initOverride[j].at(0) &lt;&lt; &quot; .. waiting for response&quot;; 
				isCommandSuccess = SendCommandUsingTimeOutSerial(_initOverride[j].at(0));
				if (isCommandSuccess) out &lt;&lt; &quot;.. success!&quot; &lt;&lt; endl;
				else out &lt;&lt; &quot;.. failure! (received but not same)&quot; &lt;&lt; endl;

			}
		}
		
	}
Beep(523,500);
	for (int i=2;i&lt;_numberOfSlices;i++) // stearts from 2 as we are printing backwards for this prototype model. 
										// should start from 0 and then must make changes to DisplayCurrentModelSlice() so that slices 
										// are iterated in the correct order. Right now slices are iterated in reverse order 
	{
		
		for (int j=0;j&lt;_sliceOverride.size();j++)
		{
			if (_sliceOverride[j] == &quot;X&quot; || _sliceOverride[j] == &quot;x&quot; )			/* Comamnd to show black image */
			{
				out &lt;&lt; &quot;\nProcess: B - printing black&quot;; 
				DisplayBlack();
			}
			else if (_sliceOverride[j] == &quot;W&quot; || _sliceOverride[j] == &quot;w&quot;)			/* Comamnd to show white/grey image */
			{
				out &lt;&lt; &quot;\nProcess: W - pritning white&quot;; 
				DisplayWhite();

			}
			else if (_sliceOverride[j] == &quot;S&quot; || _sliceOverride[j] == &quot;s&quot; )			/* Comamnd to show black image */
			{
				out &lt;&lt; &quot;\nProcess: S - printing current slice of model - slice = &quot; &lt;&lt; _currentNotInitViewState - 1;
				DisplayCurrentModelSlice();
			}
			else if (std::string::npos&nbsp;!= _sliceOverride[j].find_first_of(&quot;0123456789&quot;))				/* Command to wait */
			{
				out &lt;&lt; &quot;\nProcess: wait - &quot; &lt;&lt; _sliceOverride[j] &lt;&lt; &quot; secs&quot;;
				WaitForSeconds(atoi(_sliceOverride[j].c_str()));
				
			}
			else if (std::string::npos&nbsp;!= _sliceOverride[j].find_first_of(&quot;ABiTtDdUu&quot;))				/* Command to move printer head */
			{
				out &lt;&lt; &quot;\nProcess: send command - &quot; &lt;&lt; _sliceOverride[j].at(0) &lt;&lt; &quot; .. waiting for response&quot;; 
				isCommandSuccess = SendCommandUsingTimeOutSerial(_initOverride[j].at(0));
				if (isCommandSuccess) out &lt;&lt; &quot;.. response same command as sent, success!&quot; &lt;&lt; endl;
				else out &lt;&lt; &quot;.. response received but not same command sa that sent&quot; &lt;&lt; endl;

			}

			
			
		}
	
	

	}

	out.close();
	

}

void p3DProcessDriver::SetInitOverride(string processString) 
{
	_initOverride.clear(); 
	split(processString, ',', _initOverride);
}

void p3DProcessDriver::SetSliceOverride(string processString) 
{
	_sliceOverride.clear();
	split(processString, ',', _sliceOverride);
}

void p3DProcessDriver::SetInitOverrideLoop(int ntimes)
{
	_initLoop = ntimes; 
}

// Taken from http://members.ee.net/brey/Serial.pdf
// Was not included in original TimeoutSerialCode. 
int p3DProcessDriver::MyWindowsHackReadByte(CString PortSpecifier)
{
	DCB dcb;
	int retVal;
	BYTE Byte;
	DWORD dwBytesTransferred;
	DWORD dwCommModemStatus;
	HANDLE hPort = CreateFile(PortSpecifier, GENERIC_READ,0, NULL, OPEN_EXISTING, 0, NULL);
	if (!GetCommState(hPort,&amp;dcb))
		return 0x100;
	
	dcb.BaudRate = CBR_9600; //9600 Baud
	dcb.ByteSize = 8; //8 data bits
	dcb.Parity = NOPARITY; //no parity
	dcb.StopBits = ONESTOPBIT; //1 stop
	if (!SetCommState(hPort,&amp;dcb))
		return 0x100;
	
	SetCommMask (hPort, EV_RXCHAR | EV_ERR); //receive character event
	WaitCommEvent (hPort, &amp;dwCommModemStatus, 0); //wait for character
	
	if (dwCommModemStatus &amp; EV_RXCHAR)
		ReadFile (hPort, &amp;Byte, 1, &amp;dwBytesTransferred, 0); //read 1
	else if (dwCommModemStatus &amp; EV_ERR)
	retVal = 0x101;
	retVal = Byte;
	CloseHandle(hPort);
	//cout &lt;&lt; &quot;got here&quot; &lt;&lt; endl;
	return retVal;
}

bool p3DProcessDriver::MyWindowsHackWriteByte(CString PortSpecifier, CString data)
{
	DCB dcb;
	DWORD byteswritten;
	HANDLE hPort = CreateFile(PortSpecifier,GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);
	if (!GetCommState(hPort,&amp;dcb))
		return false;
	dcb.BaudRate = CBR_9600; //9600 Baud
	dcb.ByteSize = 8; //8 data bits
	dcb.Parity = NOPARITY; //no parity
	dcb.StopBits = ONESTOPBIT; //1 stop
	if (!SetCommState(hPort,&amp;dcb))
		return false;
	bool retVal = WriteFile(hPort,data,1,&amp;byteswritten,NULL);
	
	CloseHandle(hPort); //close the handle
	return retVal;
}


/*
*	XylusImgDisplayFrameHelper
*/

void XylusImgDisplayFrameHelper::SetImageFromFile(string filepath)
{
	string extension; 
	//wxBitmapType format; 
/*
	extension = filepath.substr(1+filepath.find_last_of('/'));	
	if (extension == &quot;jpg&quot;)
		format = wxBITMAP_TYPE_JPEG;
	else if (extension == &quot;png&quot;) 
		format  = wxBITMAP_TYPE_PNG;
	*/
	m_image.Destroy();
	m_image.LoadFile(filepath); 
	bitmap = wxBitmap(m_image);
	

}

void XylusImgDisplayFrameHelper::RefreshImage()
{
	this-&gt;Refresh();
}

void XylusImgDisplayFrameHelper::MakeVisible()
{
	this-&gt;Show(true);
}

/*
 * Called by the system of by wxWidgets when the panel needs
 * to be redrawn. You can also trigger this call by
 * calling Refresh()/Update().
 */
 
void XylusImgDisplayFrameHelper::paintEvent(wxPaintEvent &amp; evt)
{
    // depending on your system you may need to look at double-buffered dcs
    wxPaintDC dc(this);
    render(dc);
}
 
/*
 * Alternatively, you can use a clientDC to paint on the panel
 * at any time. Using this generally does not free you from
 * catching paint events, since it is possible that e.g. the window
 * manager throws away your drawing when the window comes to the
 * background, and expects you will redraw it when the window comes
 * back (by sending a paint event).
 */
void XylusImgDisplayFrameHelper::paintNow()
{
    // depending on your system you may need to look at double-buffered dcs
    wxClientDC dc(this);
    render(dc);
}
 
/*
 * Here we do the actual rendering. I put it in a separate
 * method so that it can work no matter what type of DC
 * (e.g. wxPaintDC or wxClientDC) is used.
 */
void XylusImgDisplayFrameHelper::render(wxDC&amp;  dc)
{
    dc.DrawBitmap( bitmap, 0, 0, false );
}
 
</pre>

<!-- 
NewPP limit report
Preprocessor node count: 4/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key rkarim:pcache:idhash:228-0!1!0!!en!2!edit=0 and timestamp 20180312125141 -->
<div class="printfooter">
Retrieved from "<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source">http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Talk:P3DImageTools_Source&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-anonuserpage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:159.92.151.128" title="The user page for the ip you&#039;re editing as [.]" accesskey="." class="new">159.92.151.128</a></li>
				<li id="pt-anontalk"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:159.92.151.128" title="Discussion about edits from this IP address [n]" accesskey="n" class="new">Talk for this IP</a></li>
				<li id="pt-anonlogin"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:UserLogin&amp;returnto=P3DImageTools_Source" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/images/myWikiLogo.gif);" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki">Main Page</a></li>
				<li id="n-Home"><a href="http://www.doc.ic.ac.uk/~rkarim/">Home</a></li>
				<li id="n-currentevents"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Rashed Karim Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:WhatLinksHere/P3DImageTools_Source" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChangesLinked/P3DImageTools_Source" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&amp;oldid=1370&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&amp;oldid=1370" title="Permanent link to this revision of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="privacy"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Privacy_policy" title="Rashed Karim Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:About" title="Rashed Karim Wiki:About">About Rashed Karim Wiki</a></li>
					<li id="disclaimer"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:General_disclaimer" title="Rashed Karim Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.467 secs. --></body>
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=P3DImageTools_Source&oldid=1370 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:49:58 GMT -->
</html>
