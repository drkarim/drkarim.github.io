<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&oldid=2905 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:52:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="robots" content="noindex,nofollow" />
		<meta name="keywords" content="LA segment from CE MRA Dec2014" />
		<link rel="shortcut icon" href="http://wwwhomes.doc.ic.ac.uk/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/opensearch_desc.php" title="Rashed Karim Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Rashed Karim Wiki RSS Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Rashed Karim Wiki Atom Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>LA segment from CE MRA Dec2014 - Rashed Karim Wiki</title>
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/monobook/main.css?207" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE50Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE55Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE60Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE70Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/~rkarim/mediawiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/~rkarim/mediawiki/skins";
		var wgArticlePath = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=$1";
		var wgScriptPath = "/~rkarim/mediawiki";
		var wgScript = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://wwwhomes.doc.ic.ac.uk/";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "LA_segment_from_CE_MRA_Dec2014";
		var wgTitle = "LA segment from CE MRA Dec2014";
		var wgAction = "view";
		var wgArticleId = 471;
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 2905;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/ajax.js?207"></script>
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-LA_segment_from_CE_MRA_Dec2014 skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">LA segment from CE MRA Dec2014</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Rashed Karim Wiki</h3>
			<div id="contentSub">
				<div id="mw-revision-info">Revision as of 15:20, 1 December 2014 by <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:Admin&amp;action=edit&amp;redlink=1" class="new mw-userlink" title="User:Admin (page does not exist)">Admin</a>  <span class="mw-usertoollinks">(<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:Admin&amp;action=edit&amp;redlink=1" class="new" title="User talk:Admin (page does not exist)">Talk</a>&#32;|&#32;<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Contributions/Admin" title="Special:Contributions/Admin">contribs</a>)</span></div>

				<div id="mw-revision-nav">(diff) ← Older revision&#32;|&#32;Current revision (diff)&#32;|&#32;Newer revision → (diff)</div>
			</div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<a name="Modifications" id="Modifications"></a><h2> <span class="mw-headline"> Modifications </span></h2>
<p>This version is more streamlined. Computes EDT, localmax and bcmaps with the click of a button. It works alongside another software <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Otsu3D" class="external text" title="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Otsu3D" rel="nofollow">Otsu3D</a>. The output of Otsu3D is used as input to this software. 
</p><p>Other new features include: 
</p>
<ul><li> The orthogonal planes are that of the MRI image (from Otsu step) and not EDT
</li><li> The main window title bar shows filename of the image 
</li></ul>
<a name="Source" id="Source"></a><h2> <span class="mw-headline"> Source </span></h2>
<pre>
#define HAS_VTK 1                                                                                                                                                                                                                               
#include &quot;vtkRenderer.h&quot;
#include &quot;vtkRenderWindow.h&quot;
#include &quot;vtkRenderWindowInteractor.h&quot;
#include &lt;vtkPiecewiseFunction.h&gt; 
#include &lt;vtkColorTransferFunction.h&gt; 
#include &lt;vtkVolumeProperty.h&gt; 
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt; 
#include &lt;vtkVolumeRayCastMIPFunction.h&gt;
#include &lt;vtkVolumeRayCastMapper.h&gt;
#include &lt;vtkVolume.h&gt;
#include &lt;vtkVolumeTextureMapper2D.h&gt;
#include &lt;vtkImageReader.h&gt;
#include &lt;vtkImageImport.h&gt;
#include &lt;vtkImageCast.h&gt;
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include &lt;vtkStructuredPoints.h&gt;
#include &lt;vtkStructuredGrid.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &quot;vtkPointData.h&quot;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkWorldPointPicker.h&gt;
#include &lt;vtkCommand.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkContourFilter.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkImageToPolyDataFilter.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkCallbackCommand.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkImagePlaneWidget.h&gt;
#include &lt;vtkImageActor.h&gt;
#include &lt;vtkImageMapToColors.h&gt;
#include &lt;vtkInteractorStyleTrackballCamera.h&gt;
#include &lt;vtkPropPicker.h&gt;
#include &lt;vtkBoxWidget.h&gt;
#include &lt;vtkPlanes.h&gt;
#include &lt;vtkRendererCollection.h&gt;
#include &lt;vtkWindowedSincPolyDataFilter.h&gt;
#include &lt;vtkSmartPointer.h&gt;
// irtk
#include &lt;irtkImage.h&gt;

// fltk
#include &lt;FL/Fl.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;
#include &lt;FL/Fl_Slider.H&gt;
#include &lt;FL/Fl_Output.H&gt;
#include &lt;FL/Fl_Menu_Item.H&gt;
#include &lt;FL/Fl_Menu_Bar.H&gt;
#include &lt;FL/Fl_File_Chooser.H&gt;
#include &lt;FL/Fl_Progress.H&gt;


// STLs
#include &lt;stack&gt;
#include &lt;vector&gt;

// vtkFLWindow
#include &lt;vtkFlRenderWindowInteractor.h&gt;
#include &lt;irtkEuclideanDistanceTransform.h&gt;
// file I/O
#include &lt;iostream&gt;
#include &lt;fstream&gt;

vtkPolyDataMapper *sphereMapper;
vtkActor *sphereActor;
vtkActor *heart;
vtkPointPicker *picker;
vtkPropPicker *picker2; 
vtkRenderer *renderer1;
vtkRenderWindow *renWin1; 
vtkRenderer *renderer2, *renderer3; 
vtkRenderWindow *renWin2, *renWin3; 
vtkFlRenderWindowInteractor *fl_vtk_window_1;
vtkFlRenderWindowInteractor *fl_vtk_window_2; 
vtkFlRenderWindowInteractor *fl_vtk_window_3; 
vtkImageMapToColors *sliceZColors; 
vtkImageMapToColors* sliceXColors; 
vtkImageMapToColors* sliceYColors; 
vtkImageActor *ySlice;
vtkImageActor *xSlice;
vtkImageActor *zSlice;
vtkLookupTable *bwLut; 
vtkImageActor **imageActorArray;
vtkInteractorStyleTrackballCamera *interactorStyle1, *interactorStyle2, *interactorStyle3;
vtkPlanes *planes;
vtkCamera *camera1, *camera2; 
vtkStructuredPoints *struct_points_data;
irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt; *edt = NULL;
irtkRealImage input, output, edt_data, input_temp;
double table_range_low=0, table_range_high=0, hue=0, saturation=0;
double mcubes_threshold=170; 
int maxX, maxY, maxZ, zPos=10, yPos=10, xPos=10, max_edt_value=255;
char buffer[10];
bool isActorSuperImposed = false;
double picker2_pos[3];
int screenX, screenY, seed_picked_x, seed_picked_y, seed_picked_z;
vector&lt;irtkPoint*&gt; localMaximums, localMaxPicked;
vtkActor **sphereActors;
irtkRealImage localMaxMap, basicComponentMap, localMaxSegmentedImage, cropped_image, emptyMap; 
irtkRealImage localMaxSegmentedImageCopy; 
vtkBoxWidget *boxWidget;
bool boxWidgetIsOn = false;
vtkVolume* volumeArray[2];	

Fl_Window *main_window;



void init()
{
	renWin1 = vtkRenderWindow::New(); 
	renWin2 = vtkRenderWindow::New();
	renWin3 = vtkRenderWindow::New();
	

	picker = vtkPointPicker::New(); 
	picker2 = vtkPropPicker::New();
	renderer1 = vtkRenderer::New(); 
	renderer2 = vtkRenderer::New();
	renderer3 = vtkRenderer::New();
	sliceZColors = vtkImageMapToColors::New(); 
	sliceXColors = vtkImageMapToColors::New(); 
	sliceYColors = vtkImageMapToColors::New(); 
	xSlice = vtkImageActor::New();
	ySlice = vtkImageActor::New();
	zSlice = vtkImageActor::New();
	bwLut = vtkLookupTable::New(); 
	bwLut-&gt;SetTableRange(0,255);	// for edt 46111
	
	/* for black and white  - pg. 193 of vtk fat book */
	
	bwLut-&gt;SetSaturationRange(0,0);
	bwLut-&gt;SetHueRange(0,0);
	bwLut-&gt;SetValueRange(0,1);
	bwLut-&gt;SetRampToLinear(); 
	bwLut-&gt;SetNumberOfColors(256);


	/* for color edt */
	/*
	bwLut-&gt;SetSaturationRange(1,1);
	bwLut-&gt;SetHueRange(0.6667,0.0);
	bwLut-&gt;SetAlphaRange(1.0,1.0); 
	bwLut-&gt;SetValueRange(1,1);
	bwLut-&gt;SetRampToLinear(); 
	bwLut-&gt;SetNumberOfColors(64);
	bwLut-&gt;Build(); 
	bwLut-&gt;SetTableValue(0,   1.0,1.0,1.0,1.0); 
	
	*/
	/* custom made rainbow */
	/*
	bwLut-&gt;SetNumberOfColors(6); 
	bwLut-&gt;Build(); 
	bwLut-&gt;SetTableValue(0,   1.0,1.0,1.0,1.0); 
	bwLut-&gt;SetTableValue(10,  0.0,1.0,1.0,1.0); 
	bwLut-&gt;SetTableValue(100, 0.0,1.0,0.25,1.0); 
	bwLut-&gt;SetTableValue(200, 0.5,1.0,0.0,1.0); 
	bwLut-&gt;SetTableValue(250, 1.0,1.0,0.0,1.0); 
	bwLut-&gt;SetTableValue(300, 1.0,0.0,0.0,1.0); */
	
	
	
	interactorStyle1 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle2 = vtkInteractorStyleTrackballCamera::New();
//	interactorStyle3 = vtkInteractorStyleTrackballCamera::New();
	planes = vtkPlanes::New();
	camera1 = vtkCamera::New(); 
	camera2 = vtkCamera::New(); 
	edt = new irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;
	(irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;::irtkDistanceTransform3D);
	sphereActor = vtkActor::New();
	sphereMapper = vtkPolyDataMapper::New();
	heart = vtkActor::New();
	struct_points_data = vtkStructuredPoints::New();
	imageActorArray = new vtkImageActor*[3]; 
	boxWidget = vtkBoxWidget::New(); 
	//volumeArray = new vtkVolume*[2];
	
	
}


void destroy() 
{	
	renWin1-&gt;Delete(); 
	renWin2-&gt;Delete(); 
	renderer1-&gt;Delete(); 
	renderer2-&gt;Delete(); 
	sliceZColors-&gt;Delete();
	sliceXColors-&gt;Delete();
	sliceYColors-&gt;Delete();
	xSlice-&gt;Delete(); 
	ySlice-&gt;Delete(); 
	zSlice-&gt;Delete(); 
	bwLut-&gt;Delete(); 
	interactorStyle1-&gt;Delete(); 
	interactorStyle2-&gt;Delete(); 
	planes-&gt;Delete(); 
	camera1-&gt;Delete(); 
	camera2-&gt;Delete();
	picker-&gt;Delete();
	picker2-&gt;Delete();
	sphereActor-&gt;Delete();
	heart-&gt;Delete();
	struct_points_data-&gt;Delete();
	boxWidget-&gt;Delete();
	
}

int contains(vector&lt;irtkPoint*&gt;&amp; v, irtkPoint* p)
{
	int index_found = -1; 
	for (int i=0;i&lt;v.size();i++)
	{
		if (v[i]-&gt;_x == p-&gt;_x &amp;&amp; v[i]-&gt;_y == p-&gt;_y &amp;&amp; v[i]-&gt;_z == p-&gt;_z)
		{
			index_found = i; 
			return index_found; 
		}
	}
	return index_found;
}

bool contains_2(vector&lt;irtkPoint*&gt;&amp; v, int a, int b, int c)
{
	for (int i=0;i&lt;v.size();i++)
	{
		if (v[i]-&gt;_x == a &amp;&amp; v[i]-&gt;_y == b &amp;&amp; v[i]-&gt;_z == c)
		{
			return true; 
		}
	}
	return false;

}

irtkPoint* getLocalMaxInVicinity(irtkPoint* p) 
{
	int i, j, k, n; 
	i = p-&gt;_x; 
	j = p-&gt;_y; 
	k = p-&gt;_z; 
	n = 1;
	for (int a=-n;a&lt;=n;a++)
	{
		for (int b=-n;b&lt;=n;b++)
		{
			for (int c=-n;c&lt;=n;c++)
			{
				if (localMaxMap.Get(i+a, j+b, k+c) &gt; 0) 
				{
					return new irtkPoint(i+a, j+b, k+c);
				}
			}
		}
	}
	return new irtkPoint(-1, -1, -1);
}

void colorLocalMaxPicked(irtkPoint *p)
{
	int indexToSphereActorArray; 
	indexToSphereActorArray = localMaxMap.Get(p-&gt;_x, p-&gt;_y, p-&gt;_z); 
	vtkProperty *property = sphereActors[indexToSphereActorArray-1]-&gt;GetProperty(); 
	property-&gt;SetColor(0.5,1.0,0.5); 
}

void UnColorLocalMaxPicked(irtkPoint *p)
{
	int indexToSphereActorArray; 
	indexToSphereActorArray = localMaxMap.Get(p-&gt;_x, p-&gt;_y, p-&gt;_z); 
	vtkProperty *property = sphereActors[indexToSphereActorArray-1]-&gt;GetProperty(); 
	property-&gt;SetColor(0,0,1); 
}

bool isLocalMaxPicked(int point[]) 
{
	irtkPoint *p = new irtkPoint(0,0,0); 

	// check if point is a local max that has been picked by the user 
	for (int i=0; i&lt;localMaxPicked.size(); i++)
	{
		p = localMaxPicked[i];
		if (point[0] == p-&gt;_x &amp;&amp; point[1] == p-&gt;_y &amp;&amp; point[2] == p-&gt;_z)
		{
			return true; 
		}
		
	}

	return false;
}
void drawLocalMaxPointsOnScreenAndSetLocalMaxMap() 
{
	vtkProperty *property;
	double localMax[3]; 
	int s = localMaximums.size(); 
	sphereActors = new vtkActor*[s]; 
	
	for (int i=0;i&lt;s;i++)
	{
		sphereActors[i] = vtkActor::New(); 
	}

	// resetting local max map to 0s
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				localMaxMap.Put(i,j,k, 0);
			}
		}
	}

	for (int i=0;i&lt;s;i++) 
	{
		localMax[0] = localMaximums[i]-&gt;_x; 
		localMax[1] = localMaximums[i]-&gt;_y; 
		localMax[2] = localMaximums[i]-&gt;_z; 
		localMaxMap.Put(localMax[0], localMax[1], localMax[2], i+1);			// for local max map
		cout &lt;&lt; &quot;(&quot; &lt;&lt; localMax[0] &lt;&lt; &quot;,&quot; &lt;&lt; localMax[1] &lt;&lt; &quot;,&quot; &lt;&lt; localMax[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		edt_data.ImageToWorld(localMax[0], localMax[1], localMax[2]); 
		sphereActors[i]-&gt;SetMapper(sphereMapper); 
		property = sphereActors[i]-&gt;GetProperty(); 
		property-&gt;SetColor(0.3,0.4,1); 
		sphereActors[i]-&gt;SetPosition(localMax[0], localMax[1], localMax[2]);
	}
	
	for (int i=0;i&lt;s;i++) 
	{
		renderer1-&gt;AddActor(sphereActors[i]);		// draws on screen
	}
}
static void keyPressedFunction(vtkObject* obj, unsigned long,void *sr, void *){

       vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::SafeDownCast(obj);
       vtkImageActor **imageActorArray = (vtkImageActor **)(sr);
	   vtkImageActor *zSl = imageActorArray[0]; 
		vtkImageActor *xSl = imageActorArray[1]; 
		vtkImageActor *ySl = imageActorArray[2]; 
		irtkPoint *p; 

		screenX = fl_vtk_window_1-&gt;GetEventPosition()[0]; 
		screenY = fl_vtk_window_1-&gt;GetEventPosition()[1]; 
		picker2-&gt;Pick(screenX,screenY,0.0, renderer1); 
		picker2-&gt;GetPickPosition(picker2_pos);
		
		edt_data.WorldToImage(picker2_pos[0], picker2_pos[1], picker2_pos[2]);
		cout &lt;&lt; &quot;Picked point &quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;( &quot; &lt;&lt; picker2_pos[0] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[1] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;Scalar value: &quot; &lt;&lt; edt_data.Get(picker2_pos[0], picker2_pos[1], picker2_pos[2]) &lt;&lt; endl; 

		p = getLocalMaxInVicinity(new irtkPoint(picker2_pos[0], picker2_pos[1], picker2_pos[2])); 
	
	
		switch (iren-&gt;GetKeyCode())
		{
		
			
		case 'p':
			if (p-&gt;_x&nbsp;!= -1) 
			{
				cout &lt;&lt; &quot;max picked: &quot; &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;_x &lt;&lt; &quot;,&quot; &lt;&lt; p-&gt;_y &lt;&lt; &quot;,&quot; &lt;&lt; p-&gt;_z &lt;&lt; &quot;)&quot; &lt;&lt; endl;

				localMaxPicked.push_back(p);
				colorLocalMaxPicked(p);
				int q = localMaxMap.Get(p-&gt;_x, p-&gt;_y, p-&gt;_z); 
				cout &lt;&lt; &quot;this local max is indexed at = &quot; &lt;&lt; q &lt;&lt; endl;
			

			}
			else
			{
				cout &lt;&lt; &quot;point was picked on plane&quot; &lt;&lt; endl;
				sphereActor-&gt;SetPosition(picker2_pos);
				
			}
	
		
			fl_vtk_window_1-&gt;Render();
			
			break;
		
		case 'u': 
			
			if (p-&gt;_x&nbsp;!= -1) 
			{
				int point_index = contains(localMaxPicked, p); 
				if (point_index &gt; 0) 
				{	
					UnColorLocalMaxPicked(p); 
					localMaxPicked.erase(localMaxPicked.begin()+point_index); 
				}
			}
			else {
				cout &lt;&lt; &quot;This is not a picked point&quot; &lt;&lt; endl; 
			}

			fl_vtk_window_1-&gt;Render();
			break; 
		
		
		default: 
			cout &lt;&lt; &quot;Keys: p - pick point, \n\t u - un-pick or remove point&quot; &lt;&lt; endl;
			break;

		}
}

static void keyPressedFunction2(vtkObject* obj, unsigned long,void *sr, void *)
{
	vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::SafeDownCast(obj);
	switch (iren-&gt;GetKeyCode())
	{
		case 'b':
			if (boxWidgetIsOn)
			{
				boxWidget-&gt;Off(); 
				boxWidgetIsOn = false;
			}
			else
			{
				boxWidget-&gt;On(); 
				boxWidgetIsOn = true;
			}
		break; 

		default: 
			cout &lt;&lt; &quot;Keys: b - toggle box widget&quot; &lt;&lt; endl;
		break;

	}
}

void show_segmented_image(vtkFlRenderWindowInteractor *&amp;flrwi, irtkRealImage image)
{
	// convert irtk image to a structured point set os unsigned scalars
	vtkStructuredPoints  *vtkImage = vtkStructuredPoints::New();	
	vtkImageCast *vtkImageCast = vtkImageCast::New();
	image.ImageToVTK(vtkImage);
	vtkImageCast-&gt;SetInput(vtkImage);
	vtkImageCast-&gt;SetOutputScalarTypeToUnsignedShort();
	
	// surface rendering
	vtkMarchingCubes *surface = vtkMarchingCubes::New(); 
	surface-&gt;SetInputConnection(vtkImageCast-&gt;GetOutputPort());

	surface-&gt;SetValue(0,mcubes_threshold);
	cout &lt;&lt; &quot;polygons created&quot; &lt;&lt; endl;
	//vtkPolyDataNormals *surfaceNormals = vtkPolyDataNormals::New();
	//surfaceNormals-&gt;SetInputConnection(surface-&gt;GetOutputPort());
	//surfaceNormals-&gt;SetFeatureAngle(60.0);

	vtkSmartPointer&lt;vtkWindowedSincPolyDataFilter&gt; smoother = vtkSmartPointer&lt;vtkWindowedSincPolyDataFilter&gt;::New();
	smoother-&gt;SetInput(surface-&gt;GetOutput());
	smoother-&gt;SetNumberOfIterations(15);
	smoother-&gt;BoundarySmoothingOff();
	smoother-&gt;FeatureEdgeSmoothingOff();
	smoother-&gt;SetFeatureAngle(120.0);
	smoother-&gt;SetPassBand(0.001);
	smoother-&gt;NonManifoldSmoothingOn();
	smoother-&gt;NormalizeCoordinatesOn();
	smoother-&gt;Update();
	vtkSmartPointer&lt;vtkPolyDataNormals&gt; normals = vtkSmartPointer&lt;vtkPolyDataNormals&gt;::New();
	normals-&gt;ComputeCellNormalsOn();
	normals-&gt;SetInputConnection(smoother-&gt;GetOutputPort()); 
	normals-&gt;Update();

	cout &lt;&lt; &quot;normals created&quot; &lt;&lt; endl;
	vtkPolyDataMapper *surfaceMapper = vtkPolyDataMapper::New();
	surfaceMapper-&gt;SetInput(normals-&gt;GetOutput());

	cout &lt;&lt; &quot;mappers created&quot; &lt;&lt; endl;
	surfaceMapper-&gt;ScalarVisibilityOff();
				
	heart-&gt;SetMapper(surfaceMapper);
	cout &lt;&lt; &quot;actor added to mapper&quot; &lt;&lt; endl;
	
	heart-&gt;GetProperty()-&gt;SetAmbient(0.2); 
	heart-&gt;GetProperty()-&gt;SetDiffuse(0.5); 
	heart-&gt;GetProperty()-&gt;SetSpecular(1.0); 
	heart-&gt;GetProperty()-&gt;SetSpecularPower(90.0); 
	heart-&gt;GetProperty()-&gt;SetInterpolationToPhong();
	heart-&gt;GetProperty()-&gt;SetSpecularColor(1,1,1);
	heart-&gt;GetProperty()-&gt;SetColor(1,0,0);

	if (flrwi-&gt;GetInitialized() == 1) 
	{	
		renderer2-&gt;Delete(); 
		renderer2 = vtkRenderer::New();

		//flrwi-&gt;ReInitialize();		// dont need this line
		//renderer2-&gt;RemoveAllViewProps();
		renderer2-&gt;AddActor(heart); 
		renWin2-&gt;RemoveRenderer(renderer2);
		//renWin2-&gt;AddRenderer(renderer2); 
		renWin2-&gt;AddRenderer(renderer2);
		renWin2-&gt;Render(); 
		//flrwi-&gt;SetRenderWindow(renWin2);
	}
	else
	{
		
		cout &lt;&lt; &quot;actor added to renderer&quot; &lt;&lt; endl;
		renderer2-&gt;AddActor(heart);
		renWin2-&gt;AddRenderer(renderer2);
		flrwi-&gt;SetRenderWindow(renWin2);	
		flrwi-&gt;Initialize();
	}

	
	surface-&gt;Delete(); 
	vtkImage-&gt;Delete(); 
	vtkImageCast-&gt;Delete(); 
	surfaceMapper-&gt;Delete();
	
}


void showOrthoPlanes()
{
	if (fl_vtk_window_1-&gt;GetInitialized() == 1)
	{
		renderer1-&gt;Delete(); 
		renderer1 = vtkRenderer::New();
		renderer1-&gt;SetBackground(0.0,0.1,0.5);
	}

	// Z planes
	sliceZColors-&gt;SetInput(struct_points_data); 
	sliceZColors-&gt;SetLookupTable(bwLut);
	zSlice-&gt;SetInput(sliceZColors-&gt;GetOutput()); 
	zSlice-&gt;SetDisplayExtent(0, maxX-1, 0, maxY-1, zPos, zPos); 
	cout &lt;&lt; &quot;z plane generated&quot; &lt;&lt; endl;

	// X Plane
	sliceXColors-&gt;SetInput(struct_points_data); 
	sliceXColors-&gt;SetLookupTable(bwLut);
	xSlice-&gt;SetInput(sliceXColors-&gt;GetOutput()); 
	if (maxZ &gt; 1) xSlice-&gt;SetDisplayExtent(xPos, xPos, 0, maxY-1, 0, maxZ-1); 
	cout &lt;&lt; &quot;x plane generated&quot; &lt;&lt; endl;
	
	// Y Plane
	sliceYColors-&gt;SetInput(struct_points_data); 
	sliceYColors-&gt;SetLookupTable(bwLut);
	ySlice-&gt;SetInput(sliceYColors-&gt;GetOutput()); 
	if (maxZ &gt; 1) ySlice-&gt;SetDisplayExtent(0, maxX-1, yPos, yPos, 0, maxZ-1); 
	cout &lt;&lt; &quot;y plane generated&quot; &lt;&lt; endl;

	renderer1-&gt;AddActor(xSlice);			
	if (maxZ &gt; 1) renderer1-&gt;AddActor(ySlice);			
	if (maxZ &gt; 1) renderer1-&gt;AddActor(zSlice);	
	cout &lt;&lt; &quot;all actors added&quot; &lt;&lt; endl;

	
	imageActorArray[0] = zSlice; 
	if (maxZ &gt; 1) imageActorArray[1] = ySlice; 
	if (maxZ &gt; 1) imageActorArray[2] = xSlice; 
	cout &lt;&lt; &quot;image actor added&quot; &lt;&lt; endl;

	// add point picker for the slices 
	vtkSphereSource *sphere = vtkSphereSource::New();
	sphere-&gt;SetThetaResolution(8); 
	sphere-&gt;SetPhiResolution(8);
	sphere-&gt;SetRadius(1);
	sphereMapper = vtkPolyDataMapper::New();
	sphereMapper-&gt;ScalarVisibilityOff();
	sphereMapper-&gt;SetInput(sphere-&gt;GetOutput());
	vtkProperty *property = sphereActor-&gt;GetProperty();
	property-&gt;SetColor(0.3,0.4,1); 
	sphereActor-&gt;SetMapper(sphereMapper);
//	sphereActor-&gt;PickableOff();
	renderer1-&gt;AddActor(sphereActor);
	picker2-&gt;InitializePickList();		
	if (maxZ &gt; 1) picker2-&gt;AddPickList(xSlice); 
	if (maxZ &gt; 1) picker2-&gt;AddPickList(ySlice); 
	picker2-&gt;AddPickList(zSlice); 
	
	

	if (fl_vtk_window_1-&gt;GetInitialized() == 1)
	{
		renWin1-&gt;RemoveRenderer(renderer1); 
		renWin1-&gt;AddRenderer(renderer1);
		renWin1-&gt;Render(); 
		vtkCallbackCommand *callback = vtkCallbackCommand::New();
		callback-&gt;SetCallback(keyPressedFunction);
		callback-&gt;SetClientData((void *) imageActorArray);
		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback); 
		
	}
	else
	{

		
		fl_vtk_window_1-&gt;SetPicker(picker2);
		vtkCallbackCommand *callback = vtkCallbackCommand::New();
		callback-&gt;SetCallback(keyPressedFunction);
		callback-&gt;SetClientData((void *) imageActorArray);
		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback); 
		renderer1-&gt;SetBackground(0.0,0.1,0.5);
		renWin1-&gt;AddRenderer(renderer1); 
		cout &lt;&lt; &quot;renderer added&quot; &lt;&lt; endl;
		fl_vtk_window_1-&gt;SetRenderWindow(renWin1);
		cout &lt;&lt; &quot;renderer window set&quot; &lt;&lt; endl;
//		fl_vtk_window_1-&gt;Initialize();
		cout &lt;&lt; &quot;window init&quot; &lt;&lt; endl;
		
	}
	
}



void xSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = (maxX-1)*slider-&gt;value(); 
	vtkImageActor *xSl = imageActorArray[2]; 
	xPos = v;
	xSl-&gt;SetDisplayExtent(xPos,xPos,0,maxY-1,0,maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void zSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = (maxZ-1)*slider-&gt;value(); 
	vtkImageActor *zSl = imageActorArray[0]; 
	zPos = v;
	//cout &lt;&lt; &quot;z-slice = &quot; &lt;&lt; zPos &lt;&lt; &quot;  &quot;; 
	zSl-&gt;SetDisplayExtent(0,maxX-1,0,maxY-1,zPos,zPos);
	fl_vtk_window_1-&gt;Render();
}

void ySlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = (maxY-1)*slider-&gt;value(); 
	vtkImageActor *ySl = imageActorArray[1]; 
	yPos = v;
	ySl-&gt;SetDisplayExtent(0,maxX-1,yPos, yPos, 0,maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void lookUpTable_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = 4000*slider-&gt;value();
	bwLut-&gt;SetTableRange(0,v);
	fl_vtk_window_1-&gt;Render();
}

void hue_selector_cb(Fl_Widget* widget, void* p) 
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = 1*slider-&gt;value(); 
	Fl_Output* textDisplay = (Fl_Output*)(p); 
	int vInt = (int)v;
	itoa(vInt, buffer, 10); 
	textDisplay-&gt;value(buffer);
	hue = v;
	bwLut-&gt;SetHueRange(0,hue);
}

void mcubes_threshold_selector_cb(Fl_Widget* widget, void* p) 
{
	Fl_Slider* slider = (Fl_Slider*)(widget); 
	float v = 300*slider-&gt;value(); 
	Fl_Output* textDisplay = (Fl_Output*)(p); 
	int vInt = (int)v;
	itoa(vInt, buffer, 10); 
	textDisplay-&gt;value(buffer);
	mcubes_threshold = v;
}



void open_segmented_cb(Fl_Widget*, void*) {

  char *newfile = fl_file_chooser(&quot;Open File?&quot;, &quot;*.gipl&quot;, &quot;&quot;);
  
	if (newfile&nbsp;!= NULL) 
	{
		// change window title to show filename 
		string filename_from_path = newfile; 
		const size_t last_slash_idx = filename_from_path.find_last_of(&quot;\\/&quot;);
		if (std::string::npos&nbsp;!= last_slash_idx)
		{
			filename_from_path.erase(0, last_slash_idx + 1);
		}

		main_window-&gt;label(filename_from_path.c_str()); 

		input.Read(newfile);
		show_segmented_image(fl_vtk_window_2, input);	
		
		input.ImageToVTK(struct_points_data);
		// visualize the edt data 
		maxX = input.GetX(); maxY = input.GetY(); maxZ = input.GetZ(); 
		cout &lt;&lt; &quot;\nI am now rendering a visualization of the otsu output ... &quot;; 
		showOrthoPlanes();		
	
//		show_volume_rendering(fl_vtk_window_3, input);
	}
}

void open_edt_cb(Fl_Widget* , void* )
{
	char *newfile = fl_file_chooser(&quot;Open File?&quot;, &quot;*.gipl&quot;, &quot;&quot;);
	if (newfile&nbsp;!= NULL) 
	{
		edt_data.Read(newfile);
		maxX = edt_data.GetX(); maxY = edt_data.GetY(); maxZ = edt_data.GetZ(); 
		edt_data.ImageToVTK(struct_points_data);
		showOrthoPlanes();
		cout &lt;&lt; &quot;ortho planes exited&quot; &lt;&lt; endl;
	}
}

void open_basicComponentMap_cb(Fl_Widget* , void* )
{
	char *newfile = fl_file_chooser(&quot;Open File?&quot;, &quot;*.gipl&quot;, &quot;&quot;);
	if (newfile&nbsp;!= NULL) 
	{
		basicComponentMap.Read(newfile);
	}
}


void open_manualSegmentation_cb(void) 
{
	char *line; 
	char *token; 
	int point[3];
	int index=0, localMaxMapIndex = 0, totalNumberOfLocalMaximums=625;
	bool isLocalMaxPicked = false;
	int isPicked = 0;
	ifstream in; 
	irtkPoint **tempArrayOfLocalMaximums;

	char *newfile = fl_file_chooser(&quot;Open File?&quot;, &quot;*.atrium&quot;, &quot;&quot;);
	if (newfile&nbsp;!= NULL) 
	{
	// resetting localMaxMap
		if (localMaxMap.GetX() == 0 &amp;&amp; localMaxMap.GetY() == 0 &amp;&amp; localMaxMap.GetZ() == 0)
			localMaxMap = edt_data;

		cout &lt;&lt; &quot;resetting local max map .. &quot; &lt;&lt; endl;
		

		cout &lt;&lt; &quot;resetting local max picked buffer &quot; &lt;&lt; endl;
		// resetting localMaxPicked
		if (localMaxPicked.size() &gt; 0)
			localMaxPicked.clear();

		in.open(newfile,  ios::in); 

		cout &lt;&lt; &quot;parsing file ... &quot; &lt;&lt; endl;
		
		in &gt;&gt; totalNumberOfLocalMaximums;
		tempArrayOfLocalMaximums = new irtkPoint*[totalNumberOfLocalMaximums];
		while (!in.eof())
		{
			in &gt;&gt; point[0] &gt;&gt; point[1] &gt;&gt; point[2] &gt;&gt; localMaxMapIndex &gt;&gt; isPicked;
			isLocalMaxPicked = (isPicked == 1);
			if (isLocalMaxPicked)
				localMaxPicked.push_back(new irtkPoint(point[0], point[1], point[2]));
			tempArrayOfLocalMaximums[localMaxMapIndex-1] = new irtkPoint(point[0], point[1], point[2]);
		}
		cout &lt;&lt; &quot;Finished parsing .atrium file... &quot; &lt;&lt; endl;
		in.close();
	}

	// enumerate localMaximums Array 
	cout &lt;&lt; &quot;Enumerating local maximums .. &quot; &lt;&lt; endl;
	for (int i=0;i&lt;totalNumberOfLocalMaximums;i++)
	{
		localMaximums.push_back(tempArrayOfLocalMaximums[i]);
	}
	
	drawLocalMaxPointsOnScreenAndSetLocalMaxMap();
	cout &lt;&lt; &quot;Segmentation and local max points loaded successfully&quot; &lt;&lt; endl;

	// color localMaxPoints picked 
	for (int i=0;i&lt;localMaxPicked.size();i++)
	{
		colorLocalMaxPicked(localMaxPicked[i]);
	}

	

}
void saveas_segmented_cb(void) {
  
	char *newfile;
  newfile = fl_file_chooser(&quot;Save EDT file&quot;, &quot;*.gipl&quot;, &quot;myEDT.gipl&quot;);
  if (newfile&nbsp;!= NULL) 
	  output.Write(newfile);

}

void saveas_manualSegmentation_cb(void) {
	
	char *newfile; 
	int v; 
	newfile = fl_file_chooser(&quot;Save auto segmentation&quot;, &quot;*.gipl&quot;, &quot;mra_autoseg.gipl&quot;); 
	if (newfile&nbsp;!= NULL) 
	{
		ofstream out;
		out.open(newfile);
		int point[3]; 
		
		// output the number of local maximum points, useful for constructing localMaximums vector when opening manual segmentation files
		out &lt;&lt; localMaximums.size() &lt;&lt; endl; 

		// iterate through local max map and find out which points are local maximums
		for (int i=0;i&lt;maxX; i++)
		{
			for (int j=0;j&lt;maxY;j++)
			{
				for (int k=0;k&lt;maxZ; k++)
				{
					point[0] = i; 
					point[1] = j; 
					point[2] = k;
					
					v = localMaxMap.Get(i,j,k); 
					if (v &gt; 0)
					{	
						if (isLocalMaxPicked(point))
						{
							out &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl;
						}
						else
						{
							out &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; 0 &lt;&lt; endl;
						}
					}
				}
			}
		} // end for 

		out.close();

		// added 2014

		localMaxSegmentedImageCopy = localMaxSegmentedImage; 
		irtkRealPixel *p = localMaxSegmentedImageCopy.GetPointerToVoxels(); 
		irtkRealPixel *_p = localMaxSegmentedImage.GetPointerToVoxels(); 
		for (int i=0;i&lt;localMaxSegmentedImageCopy.GetNumberOfVoxels();i++)
		{
			if (*_p &gt; 0)
				*p = 1; 
			
			p++;
			_p++;
		}
		stringstream ss; 
		ss &lt;&lt; newfile; 
		localMaxSegmentedImageCopy.Write(ss.str().c_str());
	}
	
}
void saveas_basicComponent_cb(void) {
  
	char *newfile;
	string fileNameBase;
	string::size_type pos;
	string fileNameExt;
	stringstream fileNameStream;
	newfile = fl_file_chooser(&quot;Save Basic Components Map file&quot;, &quot;*.gipl&quot;, &quot;myBasicComponent.gipl&quot;);
	if (newfile&nbsp;!= NULL) {
		basicComponentMap.Write(newfile);

		// THIS PART IS NEW: MARCH 2009 
		// NOW WE WILL ALSO STORE THE LOCALMAXMAP ARRAY IN TEXT FILE 
		
		// extract bcmap filename base and extension 
		fileNameBase = newfile; 
		pos = fileNameBase.find_last_of( '.' );
		if (pos&nbsp;!= -1)
		{
			fileNameExt.assign( fileNameBase, pos, 4 );
			fileNameBase.erase( pos, pos+3 );
			fileNameStream &lt;&lt; fileNameBase &lt;&lt; &quot;_localmaxmap.txt&quot; &lt;&lt; ends;			// name the localmaxmap file as &lt;bcmap-name&gt;_localmaxmap.txt

			ofstream out;	
			out.open(fileNameStream.str().c_str());
			for (int i=0;i&lt;localMaximums.size();i++)
			{

				out &lt;&lt; localMaximums[i]-&gt;_x &lt;&lt; &quot;,&quot; &lt;&lt; localMaximums[i]-&gt;_y &lt;&lt; &quot;,&quot; &lt;&lt;localMaximums[i]-&gt;_z;
				if (i&lt;localMaximums.size()-1)
					out &lt;&lt; endl;		// no line break at the end of file - for precaution when reading the points in 
			}
			out.close();
		}
	}

 
}
void saveas_cropped_cb(void) {
  
  char *newfile;
  newfile = fl_file_chooser(&quot;Save Cropped Image file&quot;, &quot;*.gipl&quot;, &quot;myCroppedImage.gipl&quot;);
  if (newfile&nbsp;!= NULL) 
	  cropped_image.Write(newfile);
 
}


void superimpose_cb(Fl_Widget*, void*)
{
	if (!isActorSuperImposed)
	{
		renderer1-&gt;RemoveActor(sphereActor);
		renderer1-&gt;AddActor(sphereActor);
		renderer1-&gt;AddActor(heart);
		renderer1-&gt;Render();
			
		isActorSuperImposed = true;
	}
	else
	{
		renderer1-&gt;RemoveActor(heart);
		renderer1-&gt;Render();
		isActorSuperImposed = false;
	}
	

}

void edt_cb(Fl_Widget*, void* )
{
	int x,y,z;
	input_temp = input;
	cout &lt;&lt; &quot;inverting image .. &quot; &lt;&lt; endl;
	for (z = 0; z &lt; input.GetZ(); z++){
		for (y = 0; y &lt; input.GetY(); y++){
			for (x = 0; x &lt; input.GetX(); x++){
				if (input(x,y,z) == 0)
					input_temp(x,y,z) = 100;
				else
					input_temp(x,y,z) = 0;
			}
		}
	}
	//input_temp.Write(&quot;myoutput.gipl&quot;);
	cout &lt;&lt; &quot;image inverted.&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;EDT computation started&quot; &lt;&lt; endl; 
	edt-&gt;SetInput(&amp;input_temp);
	edt-&gt;SetOutput(&amp;output);
	cout &lt;&lt; &quot;filter started ... &quot; &lt;&lt; endl;
	edt-&gt;Run();
	cout &lt;&lt; &quot;filter finished running &quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;Converting data to structured point&quot; &lt;&lt; endl;
	output.ImageToVTK(struct_points_data); 
	cout &lt;&lt; &quot;conversion finished&quot; &lt;&lt; endl;
	edt_data = output; 
	maxX = edt_data.GetX(); maxY = edt_data.GetY(); maxZ = edt_data.GetZ(); 
	cout &lt;&lt; &quot;displaying ortho planes&quot; &lt;&lt; endl;
//	showOrthoPlanes();		
	saveas_segmented_cb();		

}

void reRender_cb(Fl_Widget*, void*) 
{
	if (localMaximums.size() &gt; 0)
		show_segmented_image(fl_vtk_window_2, localMaxSegmentedImage);	
	else 	
		show_segmented_image(fl_vtk_window_2, input);	
}


void quit_cb(Fl_Widget*, void*)
{
	destroy();
	 exit(0);
}


void printirtkPoint(irtkPoint* p)
{
	cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;_x &lt;&lt; &quot;,&quot; &lt;&lt; p-&gt;_y &lt;&lt; &quot;,&quot; &lt;&lt; p-&gt;_z &lt;&lt; &quot;)&quot; &lt;&lt; endl; 
}	

// I replaced this function from my current testpointpicker code
void calculateLocalMaximas()
{
	double edt=0;
	double scalarValue=0;
	int n = 1;
	bool neighborWithMaxExists, neighborWithNonZeroExists=false;
	irtkPoint *maximumPoint;
	int count = 0;
	irtkRealImage voxelsVisited = edt_data;

	//reset voxelsVisisted
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				voxelsVisited.Put(i,j,k, 0);
			}
		}
	}

	cout &lt;&lt; &quot;finding local maximas .. &quot; &lt;&lt; endl;

	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				if (voxelsVisited.Get(i,j,k) == 0)
				{
					edt = edt_data.Get(i,j,k);
					neighborWithMaxExists = false;
					neighborWithNonZeroExists = false;
					voxelsVisited.Put(i,j,k,1);

					// iterate through neighbors
					for (int a=-n;a&lt;=n &amp;&amp;&nbsp;!neighborWithMaxExists;a++)
					{
						for (int b=-n;b&lt;=n &amp;&amp;&nbsp;!neighborWithMaxExists&nbsp;;b++)
						{
							for (int c=-n;c&lt;=n &amp;&amp;&nbsp;!neighborWithMaxExists;c++)
							{

								if (i+a &gt;= 0 &amp;&amp; i+a &lt;maxX &amp;&amp; j+b &gt;= 0 &amp;&amp; j+b &lt; maxY &amp;&amp; k+c &gt;= 0 &amp;&amp; k+c &lt; maxZ &amp;&amp;&nbsp;!(a==0 &amp;&amp;  b==0 &amp;&amp; c==0))
								{
									scalarValue = edt_data.Get(i+a,j+b,k+c);		// get edt of neighbour
									voxelsVisited.Put(i+a,j+b,k+c,1);

									if (scalarValue &gt;= edt)			// Remove equal to not allow even plateus. For phantom, remove = 
									{
										neighborWithMaxExists = true;
									}
									if (scalarValue&nbsp;!= 0)
									{
										neighborWithNonZeroExists = true;
									}
								}
							}
						}
					}

					if (!neighborWithMaxExists &amp;&amp; neighborWithNonZeroExists)
					{
						maximumPoint = new irtkPoint(i,j,k);
						localMaximums.push_back(maximumPoint);
					}
				}

			}
		}
	}

}


bool isLocalMax(int point[])
{
	int x,y,z,maxX, maxY, maxZ;
	x = point[0]; y = point[1]; z = point[2]; 
	
	maxX = localMaxMap.GetX(); maxY = localMaxMap.GetY(); maxZ = localMaxMap.GetZ(); 
	if (x &gt; 0 &amp;&amp; x &lt; maxX &amp;&amp; y &gt; 0 &amp;&amp; y&lt; maxY &amp;&amp; z &gt; 0 &amp;&amp; z &lt; maxZ)
	{
		return (localMaxMap.Get(x,y,z) &gt; 0);
	}
	else
		return false; 
}


// p = image coordinates
void drawPoints(vector&lt;irtkPoint*&gt;&amp; collection)
{
	double coord[3];

	for (int i=0; i&lt;collection.size()-1; i++) 
	{
		coord[0] = collection[i]-&gt;_x; 
		coord[1] = collection[i]-&gt;_y; 
		coord[2] = collection[i]-&gt;_z; 
cout &lt;&lt; &quot;(&quot; &lt;&lt; coord[0] &lt;&lt; &quot;,&quot; &lt;&lt; coord[1] &lt;&lt; &quot;,&quot; &lt;&lt; coord[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		edt_data.ImageToWorld(coord[0], coord[1], coord[2]);

		vtkActor *spherePathTrail = vtkActor::New(); 
		spherePathTrail-&gt;SetMapper(sphereMapper);
		vtkProperty *property = spherePathTrail-&gt;GetProperty(); 
		property-&gt;SetColor(0.5,0.8,0.8); 
		spherePathTrail-&gt;SetPosition(coord[0], coord[1], coord[2]);
		renderer1-&gt;AddActor(spherePathTrail);
	}
	

}
void initEmptyMap() 
{
	emptyMap = edt_data; 
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j =0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				emptyMap.Put(i,j,k,0);
			}
		}
	}
}

// p is the image coordinates , AND not world coordinate
void findPathToMaximum(irtkPoint* p, bool revealPath, irtkPoint* maxp, int&amp; component, bool doDebug)
{
	irtkPoint q; 
	int n=1;
	bool maxFound = false, isPointVisited, alreadyComputed=false; 
	double maxEDT = 0;
	double edt = 0; 
	int max_i, max_j, max_k;
	int i, j, k;
	int count = 0, totalNeighborsVisited=0;
	vector&lt;irtkPoint*&gt; pointCollection;
	vector&lt;irtkPoint*&gt; visitedPoints;
	irtkPoint w(p-&gt;_x,p-&gt;_y, p-&gt;_z);	
	int coord[3];
	coord[0] = p-&gt;_x; 
	coord[1] = p-&gt;_y; 
	coord[2] = p-&gt;_z;
	bool orphaned = false; 

	visitedPoints.push_back(new irtkPoint(p-&gt;_x,p-&gt;_y, p-&gt;_z));
	if (revealPath)
		pointCollection.push_back(&amp;w);

	while (!isLocalMax(coord) &amp;&amp;&nbsp;!orphaned &amp;&amp;&nbsp;!alreadyComputed)
	{
		i = coord[0]; 
		j = coord[1]; 
		k = coord[2]; 
		for (int a=-n;a&lt;=n;a++)
		{
			for (int b=-n;b&lt;=n;b++)
			{
				for (int c=-n;c&lt;=n;c++)
				{	
					if (i+a &gt;= 0 &amp;&amp; i+a &lt;maxX-1 &amp;&amp; j+b &gt;= 0 &amp;&amp; j+b &lt; maxY-1 &amp;&amp; k+c &gt;= 0 &amp;&amp; k+c &lt; maxZ-1 &amp;&amp;&nbsp;!(a==0 &amp;&amp;  b==0 &amp;&amp; c==0))
					{
						//irtkPoint n(i+a, j+b, k+c); 
						isPointVisited = contains_2(visitedPoints, i+a, j+b, k+c);
						if (doDebug) cout &lt;&lt; &quot;Checking neigh: (&quot; &lt;&lt; a+i &lt;&lt; &quot;,&quot; &lt;&lt; b+j &lt;&lt; &quot;,&quot; &lt;&lt; c+k &lt;&lt; &quot;), &quot;; 
						
						if (!isPointVisited)
						{
							edt = edt_data.Get(i+a, j+b, k+c); 
							if (doDebug) cout &lt;&lt; &quot;not visited, edt = &quot; &lt;&lt; edt &lt;&lt;&quot;, &quot;; 
							
							if (edt &gt; maxEDT) 
							{
								maxEDT = edt; 
								max_i = i+a; 
								max_j = j+b; 
								max_k = k+c;
								visitedPoints.push_back(new irtkPoint(i+a, j+b, k+c));
							}
						}			
						
						totalNeighborsVisited++;
					}
					
				
				}
			}	
		}
	
		
		coord[0] = max_i; 
		coord[1] = max_j; 
		coord[2] = max_k;

		count++;
		if (revealPath)
			pointCollection.push_back(new irtkPoint(coord[0], coord[1], coord[2]));
		// if vicious cycle where a voxel doesnt converge to a local max. 
		if ((totalNeighborsVisited == 26 &amp;&amp; maxEDT == 0) || count&gt;200)
		{
			orphaned = true;
			if (doDebug) cout &lt;&lt; &quot;orphan! ,&quot;; 
		}
		
		if (max_i &gt; 0 &amp;&amp; max_i &lt; maxX &amp;&amp; max_j &gt; 0 &amp;&amp; max_j &lt; maxY &amp;&amp; max_k &gt; 0 &amp;&amp; max_k &lt; maxZ)
		{
			if (basicComponentMap.Get(max_i, max_j, max_k) &gt; 0)
			{
				alreadyComputed =&nbsp;!alreadyComputed; 
				component = basicComponentMap.Get(max_i, max_j, max_k);
				if (doDebug) cout &lt;&lt; &quot;hit path to already computed bcComp = &quot; &lt;&lt; component &lt;&lt; &quot;, &quot;;
			}
			
		}
		totalNeighborsVisited = 0;
		maxEDT = -1;
	
	} // end while

	
	if (revealPath)
	{
		drawPoints(pointCollection);
	 
	}

	/*
	pointCollection.~vector&lt;irtkPoint*&gt;();
	visitedPoints.clear();
	w.~irtkPoint();*/
	if (doDebug) cout &lt;&lt; &quot;Out of while loop ..&quot; &lt;&lt; endl;
	if (orphaned)
	{
		maxp-&gt;_x = -1; maxp-&gt;_y = -1; maxp-&gt;_z = -1;
	}
	else if (component &gt; 0 &amp;&amp; alreadyComputed) 
	{
		maxp-&gt;_x = -1; maxp-&gt;_y = -1; maxp-&gt;_z = -1;
	}
	else if (max_i &gt; 0 &amp;&amp; max_i &lt; maxX &amp;&amp; max_j &gt; 0 &amp;&amp; max_j &lt; maxY &amp;&amp; max_k &gt; 0 &amp;&amp; max_k &lt; maxZ)
	{
		maxp-&gt;_x = coord[0]; maxp-&gt;_y = coord[1]; maxp-&gt;_z = coord[2];
	}
	else
	{
		maxp-&gt;_x = -1; maxp-&gt;_y = -1; maxp-&gt;_z = -1;
	}
}

void findBasicComponent_cb(Fl_Widget*, void*)
{
	irtkPoint *dummy; int dummy_i; 
	dummy = new irtkPoint(-1,-1,-1);
	irtkPoint *p = new irtkPoint(seed_picked_x, seed_picked_y, seed_picked_z);
	findPathToMaximum(p, true, dummy, dummy_i,false);
	
}

void findBasicComponent2_cb()
{
	int i,j,k,n=2, indexToLocalMaximumsArray, count=0;
	double percent_completed=0, percent_step=1, prev_percent=0;
	basicComponentMap = edt_data; 
	irtkPoint *localMax = new irtkPoint(-1,-1,-1);
	double dim = ((maxX)*(maxY)*(maxZ));
	irtkPoint *w; 
	int bcComponentAlreadyComputed=-1;

	cout &lt;&lt; &quot;total points  = &quot; &lt;&lt; ((maxX)*(maxY)*(maxZ)) &lt;&lt; endl;
	cout &lt;&lt; &quot;initializing component map .. &quot; &lt;&lt; endl;
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0; k&lt;maxZ; k++) 
			{
				basicComponentMap.Put(i,j,k,0);
			}
		}
	}
	w = new irtkPoint(i,j,k);
	cout &lt;&lt; &quot;component map initialized.&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;computing basic components  .. this may take several minutes .. please wait&quot; &lt;&lt; endl;
	// iterate all voxels and determine their basic component
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0; k&lt;maxZ; k++) 
			{
				
				if (edt_data.Get(i,j,k) &gt; 0)
				{
					w-&gt;_x = i; w-&gt;_y = j; w-&gt;_z = k;

if (w-&gt;_x == 40 &amp;&amp; w-&gt;_y == 50 &amp;&amp; w-&gt;_z == 39) cout &lt;&lt; &quot;percent = &quot; &lt;&lt; round(percent_completed) &lt;&lt; &quot;going into routine for finding path to local max for point = &quot; &lt;&lt; w-&gt;_x &lt;&lt;&quot;, &quot; &lt;&lt; w-&gt;_y &lt;&lt; &quot;, &quot; &lt;&lt; w-&gt;_z &lt;&lt; &quot;)&quot; &lt;&lt; endl; 
					findPathToMaximum(w,false, localMax, bcComponentAlreadyComputed, false);
					//if (round(percent_completed) &gt;= 27) cout &lt;&lt; &quot;out of find Path to max = localmax = (&quot; &lt;&lt; localMax-&gt;_x &lt;&lt; &quot;, &quot; &lt;&lt; localMax-&gt;_y &lt;&lt; &quot;, &quot; &lt;&lt; localMax-&gt;_z &lt;&lt; &quot;) and &quot; &lt;&lt; bcComponentAlreadyComputed &lt;&lt; endl; 
if (w-&gt;_x == 40 &amp;&amp; w-&gt;_y == 50 &amp;&amp; w-&gt;_z == 39) cout &lt;&lt; &quot;out of find Path to max = localmax = (&quot; &lt;&lt; localMax-&gt;_x &lt;&lt; &quot;, &quot; &lt;&lt; localMax-&gt;_y &lt;&lt; &quot;, &quot; &lt;&lt; localMax-&gt;_z &lt;&lt; &quot;) and &quot; &lt;&lt; bcComponentAlreadyComputed &lt;&lt; endl; 
					if (localMax-&gt;_x&nbsp;!= -1)
					{
						
						indexToLocalMaximumsArray = localMaxMap.Get(localMax-&gt;_x, localMax-&gt;_y, localMax-&gt;_z);
						
						if (indexToLocalMaximumsArray &gt; 0)
						{
							basicComponentMap.Put(i,j,k, indexToLocalMaximumsArray);
						}
						else
						{
							printirtkPoint(localMax);
							cout &lt;&lt; &quot;Error!&quot; &lt;&lt; endl;
						}
					}
					else
					{
						// voxel doesnt have a basic component
						if (bcComponentAlreadyComputed &gt; 0)
						{
							basicComponentMap.Put(i,j,k, bcComponentAlreadyComputed);
						}
						else
						{
							basicComponentMap.Put(i,j,k, 0);
						}
					}
					//	reducing memory usage by clearing memory for next iteration 
					//delete w; 
					//delete localMax;
					bcComponentAlreadyComputed = -1; 
				}

				count++;
				// reports percent process completed

				percent_completed = ((double)count/dim)*100.0; 
				if (abs(prev_percent-percent_completed) &gt;= percent_step)
				{
					cout &lt;&lt; round(percent_completed) &lt;&lt; &quot;% ..&quot;;
					prev_percent=percent_completed;
				}
			

				
			}
		}
	}
	cout &lt;&lt; &quot;basic components computed!&quot; &lt;&lt; endl;
	basicComponentMap.Write(&quot;basicMap.gipl&quot;);
	

}

void calculateLocalMaximas_cb(Fl_Widget*, void*)
{
	
	calculateLocalMaximas(); 
	localMaxMap = edt_data;			
	cout &lt;&lt; &quot;total local maxs = &quot; &lt;&lt; localMaximums.size();
	drawLocalMaxPointsOnScreenAndSetLocalMaxMap();

	
}
void segmentedAccordingToLocalMax()
{
	localMaxSegmentedImage = edt_data;
	int index, b;
	irtkPoint *p;
	int *lookupTable = new int[localMaximums.size()+1];

	cout &lt;&lt; &quot;initializing lookup table&quot; &lt;&lt; endl;
	// initialize lookup table
	for (int i=0;i&lt;localMaximums.size()+1;i++)
	{
		lookupTable[i] = 0;
	}

	cout &lt;&lt; &quot;initializing memory for segmented image&quot;&lt;&lt; endl;
	// init. segmented image
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				localMaxSegmentedImage.Put(i,j,k, 0);
			}
		}
	}
	
	cout &lt;&lt; &quot;Populating lookup table&quot; &lt;&lt; endl;
	// enumerating lookup table 
	for (int i=0; i&lt;localMaxPicked.size(); i++)
	{
		p = localMaxPicked[i];
		index = localMaxMap.Get(p-&gt;_x, p-&gt;_y,p-&gt;_z); 
		lookupTable[index] = 1;
	}

	cout &lt;&lt; &quot;segmentation started .. &quot; &lt;&lt; endl;
	// iterate through all voxels and segment those which belong to basic components centered by the local maxs picked
	for (int i=0;i&lt;maxX;i++)
	{
		for (int j=0;j&lt;maxY;j++)
		{
			for (int k=0;k&lt;maxZ;k++)
			{
				b = basicComponentMap.Get(i,j,k);
				if (b &gt; 0)
				{
					if (lookupTable[b] == 1)
					{
						localMaxSegmentedImage.Put(i,j,k,input.Get(i,j,k));
					}
				}
			}
		}
	}
	cout &lt;&lt; &quot;segmentation finished&quot; &lt;&lt; endl;
	

}

void displayLocalMaxSegmentation_cb(Fl_Widget* v, void* vp)
{
	segmentedAccordingToLocalMax();
	show_segmented_image(fl_vtk_window_2, localMaxSegmentedImage);
	

	// display heart atrium if not displayed 
	if (!isActorSuperImposed)
	{
		renderer1-&gt;RemoveActor(sphereActor);
		renderer1-&gt;AddActor(sphereActor);
		renderer1-&gt;AddActor(heart);
		renderer1-&gt;Render();
			
		isActorSuperImposed = true;
	}
	//show_volume_rendering(fl_vtk_window_3, localMaxSegmentedImage);

}

bool isPointInsideBox(int x, int y, int z, vtkPlanes* planes, irtkRealImage* i)
{
	// checks if point lies inside vtkBoxWidget - global var
	
	double pos[3];
	pos[0] = x; 
	pos[1] = y; 
	pos[2] = z;
	
	i-&gt;ImageToWorld(pos[0], pos[1], pos[2]);
	double v = planes-&gt;FunctionValue(pos);
	
	if (v &lt; 0)
	{	
		return true; 
	}
	else 
	{
		return false;
	}
	
	
}


/*
*	Functions in 2014
*/

void compute_edt_bcmap_cb(Fl_Widget* fw, void* vp)
{
	

	bool isBcComputeOn = false; 
	int x,y,z;
	char user_input;

	cout &lt;&lt; &quot;Do you want me to re-compute the spherical maps?&quot;; 
	cin &gt;&gt; user_input; 
	if (user_input == 'y' || user_input == 'Y') 
	{
		isBcComputeOn = true; 
	}
	

	input_temp = input;
	cout &lt;&lt; &quot;I am about to start computing the Euclidean distance transformation of the image ... &quot; &lt;&lt; endl;
	for (z = 0; z &lt; input.GetZ(); z++){
		for (y = 0; y &lt; input.GetY(); y++){
			for (x = 0; x &lt; input.GetX(); x++){
				if (input(x,y,z) == 0)
					input_temp(x,y,z) = 100;
				else
					input_temp(x,y,z) = 0;
			}
		}
	}
	
	edt-&gt;SetInput(&amp;input_temp);
	edt-&gt;SetOutput(&amp;output);
	cout &lt;&lt; &quot;completed!&quot; &lt;&lt; endl; 
	edt-&gt;Run();
	
	//output.ImageToVTK(struct_points_data); 
	
	edt_data = output; 
	maxX = edt_data.GetX(); maxY = edt_data.GetY(); maxZ = edt_data.GetZ(); 
	

	// compute local maximums 
	cout &lt;&lt; &quot;\nI am computing the local maximums of the EDT image .. &quot;; 
	calculateLocalMaximas(); 
	localMaxMap = edt_data;			
	cout &lt;&lt; &quot;DEBUG info (Ignore): total local maxs = &quot; &lt;&lt; localMaximums.size();
	cout &lt;&lt; &quot;\nI am now rendering a visualization of the local maximums of EDT&quot; &lt;&lt; endl; 
	drawLocalMaxPointsOnScreenAndSetLocalMaxMap();

	// start bcmap computation 
	cout &lt;&lt; &quot;\nI am now computing spherical maps, this may take longer .. &quot;; 
	if (isBcComputeOn) 
		findBasicComponent2_cb();
	else
		open_basicComponentMap_cb(fw, vp); 

	cout &lt;&lt; &quot;\n\nReady to start segmentation, select the local maximum points using 't' and 'r' to remove them&quot; &lt;&lt; endl;

}




void create_window(vtkFlRenderWindowInteractor *&amp;flrwi_1, vtkFlRenderWindowInteractor *&amp;flrwi_2, 
				   Fl_Window *&amp;flw, char* title)
{
	flw = new Fl_Window(1100,900,title);

	flrwi_1 = new vtkFlRenderWindowInteractor(5,30,900,550, NULL); 
	flrwi_2 = new vtkFlRenderWindowInteractor(5,585,900,310,NULL); 
//	flrwi_3 = new vtkFlRenderWindowInteractor(610,515,290,310,NULL); 

	flrwi_1-&gt;SetInteractorStyle(interactorStyle1);
	flrwi_2-&gt;SetInteractorStyle(interactorStyle2);
//	flrwi_3-&gt;SetInteractorStyle(interactorStyle3);

	// menu bar
	Fl_Menu_Item menuitems[] = {
  { &quot;&amp;File&quot;,              0, 0, 0, FL_SUBMENU },
    { &quot;&amp;Open MRI GIPL...&quot;,    FL_CTRL + 'o', (Fl_Callback *)open_segmented_cb, 0, FL_MENU_DIVIDER },
	{ &quot;Save &amp;Segmentation GIPL As...&quot;, FL_CTRL + 's', (Fl_Callback *)saveas_manualSegmentation_cb, 0, FL_MENU_DIVIDER },	
    { &quot;E&amp;xit&quot;, FL_CTRL + 'q', (Fl_Callback *)quit_cb, 0 },
    { 0 },
  { 0 }};



	Fl_Menu_Bar *m = new Fl_Menu_Bar(0, 0, 1100, 30);
	m-&gt;copy(menuitems);

	// buttons
	int button_x=925, button_y=660, button_h=20, button_w=140, button_sep=30;
	
	
	Fl_Button* startprocess_button = new Fl_Button(button_x, button_y, button_w, button_h, &quot;&amp;Start processing&quot;);
	Fl_Button* segment_button = new Fl_Button(button_x, button_y+button_sep, button_w, button_h, &quot;Se&amp;gment&quot;);

	Fl_Button* superimpose_button = new Fl_Button(button_x, button_y+(button_sep*3), button_w, button_h, &quot;&amp;Hide/Show&quot;);
	Fl_Button* reRender_button = new Fl_Button(button_x, button_y+(button_sep*4), button_w, button_h, &quot;&amp;Render surface&quot;);
	

	// sliders
	int slider_x=925, slider_y=35, slider_h=240, slider_w=30, slider_sep=30;
	Fl_Slider* xSlice_selector = new Fl_Slider(slider_x, slider_y+0, slider_w, slider_h+20, &quot;X&quot;); 
	Fl_Slider* ySlice_selector = new Fl_Slider(slider_x+(slider_sep*1), slider_y, slider_w, slider_h+20, &quot;Y&quot;);
	Fl_Slider* zSlice_selector = new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h+20, &quot;Z&quot;);
	Fl_Slider* lookUpTable_selector = new Fl_Slider(slider_x+(slider_sep*3), slider_y, slider_w, slider_h+20, &quot;B&quot;); 

	Fl_Slider* mcubes_threshold_selector = new Fl_Slider(slider_x, slider_y+300, slider_w, slider_h+20, &quot;MCUB&quot;); 
	
	// text boxes
	int textbox_x=925, textbox_y=325, textbox_w=30, textbox_h=20, textbox_sep = slider_sep;
	Fl_Output* mcubes_threshold_textDisplay = new Fl_Output(textbox_x, textbox_y+300, textbox_w, textbox_h); 
	
	
	zSlice_selector-&gt;type(FL_VERTICAL);
	ySlice_selector-&gt;type(FL_VERTICAL);
	xSlice_selector-&gt;type(FL_VERTICAL);
    mcubes_threshold_selector-&gt;type(FL_VERTICAL);
	lookUpTable_selector-&gt;type(FL_VERTICAL);
	
	// for box widget
	boxWidget-&gt;SetInteractor(flrwi_2);
	
	// Button callbacks 
	superimpose_button-&gt;callback(superimpose_cb, NULL);
	reRender_button-&gt;callback(reRender_cb,NULL);
	
	startprocess_button-&gt;callback(compute_edt_bcmap_cb, NULL); 
	segment_button-&gt;callback(displayLocalMaxSegmentation_cb, NULL);


	// sliders
	zSlice_selector-&gt;callback(zSlice_selector_cb, NULL);
	xSlice_selector-&gt;callback(xSlice_selector_cb, NULL);
	ySlice_selector-&gt;callback(ySlice_selector_cb, NULL);
	lookUpTable_selector-&gt;callback(lookUpTable_selector_cb, NULL);

	mcubes_threshold_selector-&gt;callback(mcubes_threshold_selector_cb, mcubes_threshold_textDisplay);

	// some more callbacks 
	vtkCallbackCommand *callback = vtkCallbackCommand::New();
    callback-&gt;SetCallback(keyPressedFunction2);
    flrwi_2-&gt;AddObserver(vtkCommand::KeyPressEvent, callback); 
	
	flw-&gt;end();
	//flw-&gt;resizable(flrwi_1);
	flw-&gt;resizable(flrwi_1);
	flw-&gt;resizable(flrwi_2);
	
	
}


int main (int argc, char* argv[])
{
	main_window = NULL;

	init();
	create_window(fl_vtk_window_1, fl_vtk_window_2, main_window, 
		&quot;MRA-Seg 3D&nbsp;:: Rashed Karim&nbsp;:: 2006-2014&quot;);
	//showOrthoPlanes();
	
	main_window-&gt;show();
	fl_vtk_window_1-&gt;show();
	fl_vtk_window_2-&gt;show();
	//fl_vtk_window_3-&gt;show();
	
	/* show an initial blank screen */
	renderer1-&gt;SetBackground(0.0,0,0);
	renWin1-&gt;AddRenderer(renderer1);
	fl_vtk_window_1-&gt;SetRenderWindow(renWin1);

	renWin2-&gt;AddRenderer(renderer2);
	fl_vtk_window_2-&gt;SetRenderWindow(renWin2);

	//renWin3-&gt;AddRenderer(renderer3);
	//fl_vtk_window_3-&gt;SetRenderWindow(renWin3);

	fl_vtk_window_1-&gt;Initialize();
	fl_vtk_window_2-&gt;Initialize();
	//fl_vtk_window_3-&gt;Initialize();


	int fl_ret = Fl::run();
	destroy();
	
	return fl_ret;
	


	 /* edt
	   irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt; *edt = NULL;
	   edt = new irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;
	(irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;::irtkDistanceTransform3D);
	   	
		edt-&gt;SetInput(&amp;input);
		edt-&gt;SetOutput(&amp;output);
		edt-&gt;Run();

       output.Write(output_filename);
	   */

}







</pre>
<a name="Header" id="Header"></a><h2> <span class="mw-headline"> Header </span></h2>
<pre>
#define HAS_VTK 1
#define _IS_DEBUG 1

#include &quot;vtkPointData.h&quot;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkCommand.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkContourFilter.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkImageToPolyDataFilter.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkCallbackCommand.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkImagePlaneWidget.h&gt;
#include &lt;vtkImageActor.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkPolyDataWriter.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkIterativeClosestPointTransform.h&gt;
#include &lt;vtkLandmarkTransform.h&gt;
#include &lt;vtkMath.h&gt;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkMaskPoints.h&gt;
#include &lt;vtkSelectPolyData.h&gt;
#include &lt;vtkClipPolyData.h&gt;
#include &lt;vtkTriangleFilter.h&gt;
#include &lt;vtkFileOutputWindow.h&gt;
#include &lt;vtkTriangle.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkDijkstraGraphGeodesicPath.h&gt;
#include &lt;vtkSmartPointer.h&gt;

#include &lt;irtkImage.h&gt;


#include &lt;stdio.h&gt;    // to get &quot;printf&quot; function
#include &lt;stdlib.h&gt;   // to get &quot;free&quot; function

#include &quot;mathBoxCore.h&quot;
#include &quot;Encircler.h&quot;
</pre>

<!-- 
NewPP limit report
Preprocessor node count: 10/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key rkarim:pcache:idhash:471-0!1!0!!en!2!edit=0 and timestamp 20180312130126 -->
<div class="printfooter">
Retrieved from "<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014">http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Talk:LA_segment_from_CE_MRA_Dec2014&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-anonuserpage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:159.92.151.128" title="The user page for the ip you&#039;re editing as [.]" accesskey="." class="new">159.92.151.128</a></li>
				<li id="pt-anontalk"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:159.92.151.128" title="Discussion about edits from this IP address [n]" accesskey="n" class="new">Talk for this IP</a></li>
				<li id="pt-anonlogin"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:UserLogin&amp;returnto=LA_segment_from_CE_MRA_Dec2014" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/images/myWikiLogo.gif);" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki">Main Page</a></li>
				<li id="n-Home"><a href="http://www.doc.ic.ac.uk/~rkarim/">Home</a></li>
				<li id="n-currentevents"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Rashed Karim Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:WhatLinksHere/LA_segment_from_CE_MRA_Dec2014" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChangesLinked/LA_segment_from_CE_MRA_Dec2014" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&amp;oldid=2905&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&amp;oldid=2905" title="Permanent link to this revision of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="privacy"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Privacy_policy" title="Rashed Karim Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:About" title="Rashed Karim Wiki:About">About Rashed Karim Wiki</a></li>
					<li id="disclaimer"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:General_disclaimer" title="Rashed Karim Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.436 secs. --></body>
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=LA_segment_from_CE_MRA_Dec2014&oldid=2905 by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:52:22 GMT -->
</html>
