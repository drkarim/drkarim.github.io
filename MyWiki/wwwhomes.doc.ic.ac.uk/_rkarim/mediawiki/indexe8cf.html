<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6&action=edit by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:48:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="robots" content="noindex,nofollow" />
		<meta name="keywords" content="Scar3d v6,Users" />
		<link rel="next" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6" />
		<link rel="shortcut icon" href="http://wwwhomes.doc.ic.ac.uk/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/opensearch_desc.php" title="Rashed Karim Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Rashed Karim Wiki RSS Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Rashed Karim Wiki Atom Feed" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>View source - Rashed Karim Wiki</title>
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/shared.css?207" type="text/css" media="screen" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/commonPrint.css?207" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/monobook/main.css?207" type="text/css" media="screen" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE50Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE55Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE60Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/~rkarim/mediawiki/skins/monobook/IE70Fixes.css?207" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" media="print" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/~rkarim/mediawiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/~rkarim/mediawiki/skins";
		var wgArticlePath = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=$1";
		var wgScriptPath = "/~rkarim/mediawiki";
		var wgScript = "http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://wwwhomes.doc.ic.ac.uk/";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Scar3d_v6";
		var wgTitle = "Scar3d v6";
		var wgAction = "edit";
		var wgArticleId = "422";
		var wgIsArticle = false;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 2662;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/wikibits.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/edit.js?207"></script>
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/ajax.js?207"></script>
		<script type="text/javascript" src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Scar3d_v6 skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">View source</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Rashed Karim Wiki</h3>
			<div id="contentSub">for <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6" title="Scar3d v6">Scar3d v6</a></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">The action you have requested is limited to users in the group: <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Rashed Karim Wiki:Users (page does not exist)">Users</a>.</div>
<p>You can view and copy the source of this page:
</p><textarea id="wpTextbox1" name="wpTextbox1" cols="80" rows="25" readonly="readonly">== Issues == 
* The projections are not correct - there are bugs in the projected intensities in shell 

== See also == 
* [http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Analysis_auto_segmentation Scar3D main page] 
== Source  == 

&lt;pre&gt;
#include &quot;scar3d.h&quot;

void CellDataToPointData(vtkPolyData* cell_poly, vtkPolyData* point_poly)
{
	vtkSmartPointer&lt;vtkCellDataToPointData&gt; cell_to_point = vtkSmartPointer&lt;vtkCellDataToPointData&gt;::New(); 
	cell_to_point-&gt;SetInput(cell_poly); 
	cell_to_point-&gt;PassCellDataOn(); 
	cell_to_point-&gt;Update();
	point_poly-&gt;DeepCopy(cell_to_point-&gt;GetPolyDataOutput()); 
}

void displayScarInfo(double* p)
{
	int cellId;
	vtkGenericCell *temp_cell;  
	double dist;
	int subId;
	double closestPoint[3];
	temp_cell = vtkGenericCell::New();
	double scarValue; 
	vtkFloatArray *scalars;
	
	if (!isCellLocatorComputed) { 
		
		cell_locator = vtkCellLocator::New();
		cell_locator-&gt;SetDataSet(polys); 
		cell_locator-&gt;AutomaticOn(); 
		cell_locator-&gt;BuildLocator();
		isCellLocatorComputed = true; 
	}
	
	cell_locator-&gt;FindClosestPoint(p, closestPoint, temp_cell, cellId, subId, dist); 
	scalars =  vtkFloatArray::SafeDownCast(polys-&gt;GetCellData()-&gt;GetScalars()); 
	scarValue = scalars-&gt;GetTuple1(cellId); 
	cout &lt;&lt; &quot;\nValue of scar at this point = &quot; &lt;&lt; scarValue &lt;&lt; endl;

}

void threshold_scar_on_surface_cb(double t1, double t2)
{
	// http://www.vtk.org/Wiki/VTK/Examples/ThresholdingCells
	thresholder = vtkThreshold::New();
	thresholder-&gt;SetInput(polys); 
	thresholder-&gt;AllScalarsOn();
	thresholder-&gt;SetInputArrayToProcess(0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_CELLS, vtkDataSetAttributes::SCALARS);
	thresholder-&gt;ThresholdBetween(t1,t2);
	thresholder-&gt;Update();
	vtkSmartPointer&lt;vtkDataSetSurfaceFilter&gt; backToPolyFilter = vtkSmartPointer&lt;vtkDataSetSurfaceFilter&gt;::New();
	backToPolyFilter-&gt;SetInput(thresholder-&gt;GetOutput());
	backToPolyFilter-&gt;Update();
	thresholdedScar	= backToPolyFilter-&gt;GetOutput();

	vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New(); 
	mapper-&gt;SetInput(thresholdedScar); 
	thresholdedScarActor-&gt;SetMapper(mapper);
	
	if (isThresholdScarActorDisplayed)
	{
		renderer1-&gt;RemoveActor(thresholdedScarActor);
	}
	//thresholdedScarActor-&gt;SetColor(1,1,0);
	renderer1-&gt;AddActor(thresholdedScarActor);
	fl_vtk_window_1-&gt;Render();
	isThresholdScarActorDisplayed = true;
}

void displayWindowStatus(char* status)
{
	winStats-&gt;SetInput(status);
	vtkSmartPointer&lt;vtkTextProperty&gt; txtprop= vtkSmartPointer&lt;vtkTextProperty&gt;::New();
	txtprop = winStats-&gt;GetTextProperty();
	txtprop-&gt;SetFontFamilyToArial();
	txtprop-&gt;SetFontSize(20);
	txtprop-&gt;SetColor(1,1,1);
	winStats-&gt;SetDisplayPosition(400,850);
	renderer1-&gt;AddActor(winStats); 
	fl_vtk_window_1-&gt;Render();
}


void RemoveActorAndScalarBar(int status)
{
	if (curr_display_status == 1) { renderer1-&gt;RemoveActor(heart); renderer1-&gt;RemoveActor2D(scalarBarForScar); scar_slider_win-&gt;hide(); }
	else if (curr_display_status == 2) { if (isNoVoltageActorPresent) renderer1-&gt;RemoveActor(noVoltageActor); renderer1-&gt;RemoveActor(voltageMapActor); renderer1-&gt;RemoveActor2D(scalarBarForVoltage); voltage_slider_win-&gt;hide(); }
	else if (curr_display_status == 3) { renderer1-&gt;RemoveActor(peakTimeActor); renderer1-&gt;RemoveActor(peakTimeContourActor); 
	//renderer1-&gt;RemoveActor2D(peakTimeContourLabels);	
	for (int i=0;i&lt;contour3DLabels.size();i++) { renderer1-&gt;RemoveActor(contour3DLabels[i]); }
	renderer1-&gt;RemoveActor2D(peakTimeScalarBar); 
	peakarrival_slider_win-&gt;hide(); }
	// status values = {1,2,3} = {scar map, voltage map, peak arrival time map}
	if (status == 1) { renderer1-&gt;AddActor(heart); renderer1-&gt;AddActor2D(scalarBarForScar); curr_display_status = status; scar_slider_win-&gt;show(); fl_vtk_window_1-&gt;Render(); displayWindowStatus(&quot;Scar map&quot;);}
	else if (status == 2) { if (isNoVoltageActorPresent) renderer1-&gt;AddActor(noVoltageActor); renderer1-&gt;AddActor(voltageMapActor); renderer1-&gt;AddActor2D(scalarBarForVoltage); curr_display_status = status; voltage_slider_win-&gt;show();  fl_vtk_window_1-&gt;Render(); displayWindowStatus(&quot;Peak-to-peak voltage map&quot;);}
	else if (status == 3) { renderer1-&gt;AddActor(peakTimeActor); renderer1-&gt;AddActor(peakTimeContourActor); 
	//renderer1-&gt;AddActor2D(peakTimeContourLabels); renderer1-&gt;AddActor2D(peakTimeScalarBar); 
	for (int i=0;i&lt;contour3DLabels.size();i++) { renderer1-&gt;AddActor(contour3DLabels[i]); }
	curr_display_status = status; peakarrival_slider_win-&gt;show();  fl_vtk_window_1-&gt;Render(); displayWindowStatus(&quot;Peak-arrival time map&quot;);}
}


/********************************************************************************
* @KCL for binarizing scars (comparing with graph cut auto segmentations
* Given a threshold value, binarizes the surface to foreground (1) and background (0) 
* scalars
********************************************************************************/
void binarize_scar_surface_cb(Fl_Widget* widget, void* p)
{
	char* in, *filename; 
	double t; 
	vtkFloatArray *cell_scalars = vtkFloatArray::New(); 
	vtkFloatArray *new_scalars = vtkFloatArray::New(); 
	cout &lt;&lt; &quot;\nShould I store scar image as is (Enter 1) or as a binary surface containing scar and no-scar (Enter 2)?&quot; &lt;&lt; endl; 
	cin &gt;&gt; t;

	if (t == 2) { 
		cout &lt;&lt; &quot;\n\nPlease enter a threshold value for binarizing surface scalars&quot; &lt;&lt; endl; 
		cout &lt;&lt; &quot;\nIf you are not sure what threshold value to select, use the Lt slider to find out what will be marked as foreground\n&gt;&quot;;
		cin &gt;&gt; t; 
		//t = atof(in);  
	
		cout &lt;&lt; &quot;obtaining cell scalars .. &quot;;
		cell_scalars = vtkFloatArray::SafeDownCast(polys-&gt;GetCellData()-&gt;GetScalars());
		cout &lt;&lt; &quot;Obtained cell scalars, not binarizing .. &quot;;
		for (int i=0;i&lt; polys-&gt;GetNumberOfCells();i++)			// running through each polygon 
		{
			if (cell_scalars-&gt;GetTuple1(i) &gt;= t)
				new_scalars-&gt;InsertTuple1(i, 1); 
			else
				new_scalars-&gt;InsertTuple1(i, 0); 
		}
		cout &lt;&lt; &quot;finished!\n&quot;;
		polys-&gt;GetCellData()-&gt;SetScalars(new_scalars); 
	}

	vtkSmartPointer&lt;vtkPolyDataWriter&gt; writer = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New(); 
	filename = fl_file_chooser(&quot;Save binarized surface&quot;, &quot;*.vtk&quot;, dir_path);
	
	if (filename != NULL)
	{
		writer-&gt;SetInput(polys); 
		writer-&gt;SetFileName(filename); 
		writer-&gt;Update(); 
		cout &lt;&lt; &quot;written to &quot; &lt;&lt; filename &lt;&lt; &quot; successfully!&quot;;
	}
	
}

void export_other_shells_cb(Fl_Widget* widget,	void* p)
{
	int input; char* filename;
	
	if (p) {
		filename = (char*)p; 
		if (benAutoMode) 
			input = 1; 	
	}
	else { 
		filename = fl_file_chooser(&quot;Save binarized surface&quot;, &quot;*.vtk&quot;, dir_path);
		cout &lt;&lt; &quot;\n\nShould I write the shell as:\n(1) scar as std. dev. from normal myocardium,\n(2) scar as a ratio of std. dev.\n(3) Original intensity values of the image (obtained from traversing shell normals)\n&gt;&quot;; 
		cin &gt;&gt; input; 
	}

	vtkSmartPointer&lt;vtkPolyDataWriter&gt; writer = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New();
	writer-&gt;SetFileName(filename);
	
	if (filename != NULL)
	{

		switch (input)
		{
			case 1: 
				writer-&gt;SetInput(_scar_stdev_poly); 		
			break;

			case 2: 
				writer-&gt;SetInput(_scar_multiplier_poly); 
			break; 

			case 3: 
				writer-&gt;SetInput(_scar_original_poly); 
			break; 

			default:
				cout &lt;&lt; &quot;You haven't specified the correct option, not to worry, i am writing scar as std. dev.&quot; &lt;&lt; endl;
				writer-&gt;SetInput(polys); 
			break; 
		}

		 
		writer-&gt;Update(); 
		cout &lt;&lt; &quot;written to &quot; &lt;&lt; filename &lt;&lt; &quot; successfully!&quot;;
	}

}

/*************************************************************
* UI Sliders for PEAK arrival time maps 
**************************************************************/
void peakarrival_color_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currPeakArrivalHue = (maxPeakArrivalHue)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currPeakArrivalHue);
	textDisplay-&gt;value(buffer);
	ensiteGraphics.DisplayPeakArrivalTimeActor(fl_vtk_window_1, polys_2, peakTimeActor, peakTimeLut, peakTimeScalarBar, currPeakArrivalScalar, currPeakArrivalHue,true);
	
}

void peakarrival_time_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currPeakArrivalScalar = (maxPeakArrivalScalar)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currPeakArrivalScalar);
	textDisplay-&gt;value(buffer);
	ensiteGraphics.DisplayPeakArrivalTimeActor(fl_vtk_window_1, polys_2, peakTimeActor, peakTimeLut, peakTimeScalarBar, currPeakArrivalScalar, currPeakArrivalHue,  true);
}


/*************************************************************
*
* UI Sliders for isochrone maps 
*
**************************************************************/
void isochrone_time_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currISOTime = (maxISOTime)*slider-&gt;value()+300;
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currISOTime );
	textDisplay-&gt;value(buffer);
	isISOTimeSliderTouched = true; 

	if (voltageTraceIsochrone.size() &gt; 0)
			voltageTraceIsochrone.clear();
	/*
	double c = ensiteGraphics.getTimeIncrConstant();
	ensite.GetVoltageTraceIsochrone(currISOTime, c , voltageTraceIsochrone, maxISOScalar, minISOScalar);
	ensiteGraphics.SetVoltageTempVector(voltageTraceIsochrone);
	ensiteGraphics.displayVoltageTraceIsochrone(fl_vtk_window_1, polys, voltageNodeList, currISOPtInfl, voltageTraceIsochrone, 
		isochroneMapper, isochroneActor, isochroneLut, currISOScalar, minISOScalar, currISOHue, true);*/

	int currISOTimeInt = round(currISOTime)-300;
	renderer1-&gt;RemoveActor(isochroneActors[prev_iso_actor_index]); 
	cout &lt;&lt; &quot;displaying isochrones at time = &quot; &lt;&lt; currISOTimeInt &lt;&lt; endl;
	renderer1-&gt;AddActor(isochroneActors[currISOTimeInt]); 
	prev_iso_actor_index = currISOTimeInt;
	renWin1-&gt;Render();
}

void isochrone_color_hue_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currISOHue = (maxISOHue)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currISOHue);
	textDisplay-&gt;value(buffer);
	
	for (int i=0;i&lt;voltageNodeList.size();i++)
	{
		isochroneLuts[i]-&gt;SetHueRange(currISOHue, 0.0);			// red - 0, yellow - 60, green- 120, cyan - 180, blue - 240, magenta - 300 (on the hue circle, pg. 42 vtk book)
		voltageLut-&gt;ForceBuild(); 
	}
	cout &lt;&lt; &quot;finished rebuilding lookuptables .. &quot;;
	fl_vtk_window_1-&gt;GetRenderWindow()-&gt;Render();
}


void isochrone_scalar_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currISOScalar = (maxISOScalar)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currISOScalar);
	textDisplay-&gt;value(buffer);
	 
}

void isochrone_point_influence_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currISOPtInfl = (maxISOPtInfl)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currISOPtInfl);
	textDisplay-&gt;value(buffer);
}


void redraw_isochrone_map_cb(Fl_Widget* widget, void* p)
{
	if (isISOTimeSliderTouched)
	{
		if (voltageTraceIsochrone.size() &gt; 0)
			voltageTraceIsochrone.clear();
		double c = ensiteGraphics.getTimeIncrConstant();
		
		ensite.GetVoltageTraceIsochrone(currISOTime, c , voltageTraceIsochrone, maxISOScalar, minISOScalar);
		ensiteGraphics.SetVoltageTempVector(voltageTraceIsochrone);
		
		isISOTimeSliderTouched = false; 
	}
	ensiteGraphics.displayVoltageTraceIsochrone(fl_vtk_window_1, polys, voltageNodeList, currISOPtInfl, voltageTraceIsochrone, 
		isochroneMapper, isochroneActor, isochroneLut, scalarBarForIsochrone, maxISOScalar, minISOScalar, 0.33, true);
}

/*************************************************************
*
* UI Sliders for voltag maps
*
**************************************************************/
void color_hue_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currHueForV = (maxH)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currHueForV);
	textDisplay-&gt;value(buffer);
	//ensiteGraphics.displayGeometryWithInterpolatedVoltage(fl_vtk_window_1, polys_3, voltageSurfaceMapper, voltageMapActor, voltageLut, -1, currMaxV, currHueForV, true);  
	voltageLut-&gt;SetHueRange(0.0, currHueForV);			// red - 0, yellow - 60, green- 120, cyan - 180, blue - 240, magenta - 300 (on the hue circle, pg. 42 vtk book)
	voltageLut-&gt;ForceBuild(); 
	fl_vtk_window_1-&gt;GetRenderWindow()-&gt;Render();
}

void maximum_voltage_slider_cb(Fl_Widget* widget, void* p )
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currMaxV = (maxV)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currMaxV);
	textDisplay-&gt;value(buffer);
	ensiteGraphics.displayGeometryWithInterpolatedVoltage(fl_vtk_window_1, polys_3, voltageSurfaceMapper, voltageMapActor, 
		voltageLut, scalarBarForVoltage, -1, currMaxV, currHueForV, true); 
}

void std_dev_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currStdDevForVoltage = (maxStdDevForVoltage)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currStdDevForVoltage);
	textDisplay-&gt;value(buffer);
	
}

void k_nearest_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	double d = (maxkNearestForVoltage)*slider-&gt;value();
	currkNearestForVoltage = round(d);
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%d&quot;,currkNearestForVoltage );
	textDisplay-&gt;value(buffer);
	
}

void dist_thresh_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currdistThreshForVoltage = (maxdistThreshForVoltage)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currdistThreshForVoltage);
	textDisplay-&gt;value(buffer);
	
}


void redraw_voltage_color_cb(Fl_Widget* widget, void* p)
{
	voltageSurfaceMapper = vtkPolyDataMapper::New(); 
	polys_4 = vtkPolyData::New();
	polys_4-&gt;DeepCopy(polys);
	polys_5 = vtkPolyData::New();		// the part that could be interpolated 
	polys_6 = vtkPolyData::New();		// the part of the polygon where interpolation is not possible 
	if (_SIMPLE_INTERPOLATION_OF_VOLTAGE_ENABLED == 1)	{
		ensiteGraphics.InterpolateScalars_SimpleInterpolationAtCells(polys_4); 
	}
	else {
		ensiteGraphics.InterpolateScalars(polys_4, voltageNodeList, 0, 2, currStdDevForVoltage, currdistThreshForVoltage, currkNearestForVoltage);
	}
	ensiteGraphics.ClipInfiniteCellLocations(polys_4, polys_5, polys_6);	// break up polys_4 to the two bits (one where interpolation is possible and otherwise)
	voltageSurfaceMapper-&gt;SetInput(polys_5);		// as poly has now changed 
	ensiteGraphics.displayGeometryWithInterpolatedVoltage(fl_vtk_window_1, polys_5, voltageSurfaceMapper, 
		voltageMapActor, voltageLut, scalarBarForVoltage, -1, currMaxV, currHueForV, true, 0);
	
	// now display the part of polygon with no voltage information - where interpolation was not possible
	if (isNoVoltageActorPresent) renderer1-&gt;RemoveActor(noVoltageActor); 
	else isNoVoltageActorPresent = true; 
	vtkSmartPointer&lt;vtkPolyDataMapper&gt;	polymapper = vtkPolyDataMapper::New(); 
	polymapper-&gt;SetInput(polys_6); 
	polymapper-&gt;ScalarVisibilityOff();
	noVoltageActor-&gt;SetMapper(polymapper); 
	noVoltageActor-&gt;GetProperty()-&gt;SetColor(0.8,0.8,0.8); 
	renderer1-&gt;AddActor(noVoltageActor);
	fl_vtk_window_1-&gt;Render();
	//ensiteGraphics.debugWriteShortestDistArrayToFile();

}


/*************************************************************
*
* UI Sliders for scar maps
*
**************************************************************/
void scar_color_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currHueForScar = (maxScarHue)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currHueForV);
	textDisplay-&gt;value(buffer);

	Scarlut-&gt;SetHueRange(currHueForScar, 0.0);	
	Scarlut-&gt;SetTableRange(currScalarForScar, maxScarScalar);
	Scarlut-&gt;ForceBuild(); 
	fl_vtk_window_1-&gt;GetRenderWindow()-&gt;Render();

}

void scar_scalar_slider_cb(Fl_Widget* widget, void* p)
{
	if (_SCAR_MIP==1 &amp;&amp; _SCAR_AS_STANDARD_DEVIATION == 1) maxScarScalar = _max_std_dev_in_scar; 
	else maxScarScalar = max_scalar_in_scar; 
	Fl_Slider* slider = (Fl_Slider*)(widget);
	currScalarForScar = (maxScarScalar)*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,currScalarForScar);
	textDisplay-&gt;value(buffer);
	vtkSmartPointer&lt;vtkPolyDataMapper&gt; surfaceMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	surfaceMapper-&gt;SetInput(polys);
	surfaceMapper-&gt;SetScalarModeToUseCellData();
	surfaceMapper-&gt;ScalarVisibilityOn(); 
	surfaceMapper-&gt;SetScalarRange(currScalarForScar, 1);
	Scarlut-&gt;SetTableRange(currScalarForScar, 1);
	surfaceMapper-&gt;SetLookupTable(Scarlut); 
	renderer1-&gt;RemoveActor(heart);
	renderer1-&gt;RemoveActor2D(scalarBarForScar);
	heart-&gt;SetMapper(surfaceMapper);
	scalarBarForScar-&gt;SetLookupTable(Scarlut);
	scalarBarForScar-&gt;SetTitle(&quot;intensity&quot;);
	scalarBarForScar-&gt;SetWidth(0.08); 
	scalarBarForScar-&gt;SetHeight(1.0); 
	scalarBarForScar-&gt;SetDisplayPosition(8,8); 
	renderer1-&gt;AddActor2D(scalarBarForScar);
	renderer1-&gt;AddActor(heart);
	fl_vtk_window_1-&gt;GetRenderWindow()-&gt;Render();

}

void threshold_t1_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	thresholdt1 = slider-&gt;value()*7;
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,thresholdt1);
	textDisplay-&gt;value(buffer);
	threshold_scar_on_surface_cb(thresholdt1, thresholdt2);
}

void threshold_t2_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	thresholdt2 = slider-&gt;value()*12;
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,thresholdt2);
	textDisplay-&gt;value(buffer);
	threshold_scar_on_surface_cb(thresholdt1, thresholdt2);

}

/*
* this is only a test slider for checking if we can recursively get neighbours of a cell 
*/
void recursive_neighbour_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	double d = (40)*slider-&gt;value();
	recursive_neighbour_order = round(d);
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%d&quot;,recursive_neighbour_order);
	textDisplay-&gt;value(buffer);
	// TURNED THIS OFF TO STOP TESTING RECURSIVE NEIGHBOURS AROUND A CELL. TURNING THIS ON WILL SIMPLY START THE FEATURE AGAIN
	//ensite.TestRecursiveNeighbour(renderer1, heart, polys, Scarlut, recursive_neighbour_order, cellIdProbed); 
	//fl_vtk_window_1-&gt;Render();
	
}

void cellId_slider_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	double d = (3)*slider-&gt;value();		// INCREASE THIS 10 TO 10000 IF YOU WANT TO TEST RECURSIVE NEIGHBOUR 
	//cellIdProbed = round(d);			
	voltage_threshold = d;
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,d);
	textDisplay-&gt;value(buffer);
	// TURNED THIS OFF TO STOP TESTING RECURSIVE NEIGHBOURS AROUND A CELL. TURNING THIS ON WILL SIMPLY START THE FEATURE AGAIN
	// dont forget to turn on rounding of cellId to closest integer values 
	//ensite.TestRecursiveNeighbour(renderer1, heart, polys, Scarlut, recursive_neighbour_order, cellIdProbed); 
	//fl_vtk_window_1-&gt;Render();
	
}

/****************************************
* END
*/

void xSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (maxX-1)*slider-&gt;value();
	vtkImageActor *xSl = imageActorArray[2];
	xPos = v;
	xSl-&gt;SetDisplayExtent(xPos,xPos,0,maxY-1,0,maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void zSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (maxZ-1)*slider-&gt;value();
	vtkImageActor *zSl = imageActorArray[0];
	zPos = v;
	zSl-&gt;SetDisplayExtent(0,maxX-1,0,maxY-1,zPos,zPos);
	fl_vtk_window_1-&gt;Render();
}

void ySlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (maxY-1)*slider-&gt;value();
	vtkImageActor *ySl = imageActorArray[1];
	yPos = v;
	ySl-&gt;SetDisplayExtent(0,maxX-1,yPos, yPos, 0,maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void lookUpTable_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (_MAX_INTENSITY)*slider-&gt;value();
	bwLut-&gt;SetTableRange(0,v);
	bwLut-&gt;SetValueRange(0.0, 1.0); // from black to white
	bwLut-&gt;SetSaturationRange(0.0, 0.0); // no color saturation
	bwLut-&gt;SetRampToLinear();
	bwLut-&gt;Build();

	fl_vtk_window_1-&gt;Render();
}


void opacity_selector_for_z_slice_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,v);
	textDisplay-&gt;value(buffer);

	vtkImageActor *zSl = imageActorArray[0];
	vtkImageActor *xSl = imageActorArray[1]; 
	vtkImageActor *ySl = imageActorArray[2]; 
	zSl-&gt;SetOpacity(v);
	xSl-&gt;SetOpacity(v); 
	ySl-&gt;SetOpacity(v); 
	fl_vtk_window_1-&gt;Render();	
}

void scar_opacity_selector_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,v);
	textDisplay-&gt;value(buffer);
	
	
	scar_actor-&gt;GetProperty()-&gt;SetOpacity(v); 
	fl_vtk_window_1-&gt;Render();
}

void peaktime_opacity_selector_cb(Fl_Widget* widget, void* p)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,v);
	textDisplay-&gt;value(buffer);
	
	peakTimeActor-&gt;GetProperty()-&gt;SetOpacity(v); 
	fl_vtk_window_1-&gt;Render();
}


void low_threshold_selector_cb(Fl_Widget* widget, void* p	)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = _MAX_INTENSITY*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	low_threshold = v;
	
/*
	heart-&gt;GetProperty()-&gt;SetOpacity(v);
	fl_vtk_window_2-&gt;Render();*/

}


void high_threshold_selector_cb(Fl_Widget* widget, void* p	)
{
	
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = _MAX_INTENSITY*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	/*	this slider used to control this saddle points before */
	high_threshold = v;
	
	/*
	if (camera1 != NULL)
		camera1 = renderer1-&gt;GetActiveCamera();
	camera1-&gt;SetViewAngle(v);
	fl_vtk_window_1-&gt;Render();*/
}

void at_body_distance_low_slider_cb(Fl_Widget* widget, void* p	)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = 1000*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	low_distance_threshold = v;
}

void at_body_distance_high_slider_cb(Fl_Widget* widget, void* p	)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = 1000*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	high_distance_threshold = v;
}

void smoothing_slider_cb(Fl_Widget* widget, void* p	)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = 100*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	num_smoothing_iterations= v;
}

void MIP_slider_cb(Fl_Widget* widget, void* p	)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = 10*slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	//sprintf(buffer,&quot;%f&quot;,v);
	itoa((int)v, buffer, 10); 
	textDisplay-&gt;value(buffer);
	scar_step_max = v;
	scar_step_min = -v;
	isScarNormalExtentChanged = true; 
}


void opacity_selector_cb(Fl_Widget* widget, void* p)
{

	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = slider-&gt;value();
	Fl_Output* textDisplay = (Fl_Output*)(p);
	sprintf(buffer,&quot;%f&quot;,v);
	textDisplay-&gt;value(buffer);

	if (curr_display_status == 1 || curr_display_status == -1) { 
		heart-&gt;GetProperty()-&gt;SetOpacity(v);
	}
	else if (curr_display_status == 2) { 
		if (isNoVoltageActorPresent) 
			noVoltageActor-&gt;GetProperty()-&gt;SetOpacity(v);
		voltageMapActor-&gt;GetProperty()-&gt;SetOpacity(v);
	}
	
	fl_vtk_window_1-&gt;Render();

}

void show_scar_cb(Fl_Widget* widget, void* p)
{
	if (scar_threshold_value == 0)
	{
		if (low_threshold == -1 &amp;&amp; high_threshold == -1)
		{
			high_threshold = _MAX_INTENSITY; 
			low_threshold = 1100; 
			low_threshold_selector-&gt;value(low_threshold/high_threshold); 
			high_threshold_selector-&gt;value(1); 
			threshold_scar(); 
			
		}

		render_scar(); 
	}
}

void ostia_measure_cb(Fl_Widget* widget, void* p)
{
	drawPlaneWidgetOnScreen(1,1,1, 0,0,0, &amp;mri_data, planeWidget, fl_vtk_window_1); 
	PlaneWidgetPlaced = true; 
}


/*********************
*	For hafiz angle 
*	measurement 
**********************/

void pv_angle_measure_reset_cb(Fl_Widget* widget, void* p) 
{
	angle_relative_position_reset = true;
	angle_point_num=0;
}

void pv_angle_measure_cb(Fl_Widget* widget, void* p) 
{
	if (angle_point_num &lt; 1) 
	{
		cout &lt;&lt; &quot;\nERROR: You have not selected two points for measuring angles&quot; &lt;&lt; endl; 
		return;
	}
	else if (!isCentroidComputed)
	{
		cout &lt;&lt; &quot;\nERROR: Please compute the centroid of LA first, press 'x' to select ROI around LA body and then Tools&quot;
			&quot;-&gt; Compute LA centroid to compute centroid, and then use this feature\n&quot; &lt;&lt; endl;
		return; 
	}
	
	double angle = getAngleBetweenPoints(angle_point_1, LA_centroid, angle_point_2); 


	cout &lt;&lt; &quot;PV angle relative user-input points and LA centroid is = \n&quot; &lt;&lt; angle &lt;&lt; &quot; degrees &quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;\nAnd subtracting 180 degrees from this angle gives = \n&quot; &lt;&lt; 180-angle &lt;&lt; &quot; degrees\n\n&quot;;
	
}

void LA_centroid_measure_cb(Fl_Widget*, void*) 
{
	vector&lt;irtkPoint*&gt; all_surface_points; 
	vtkPlanes* planes; 

	double num_points=0;
	
	double cP[3];
	
	vtkIdType num_cell_points; 
	vtkSmartPointer&lt;vtkIdList&gt; point_cells = vtkSmartPointer&lt;vtkIdList&gt;::New(); 
	vtkSmartPointer&lt;vtkIdList&gt; cell_points = vtkSmartPointer&lt;vtkIdList&gt;::New(); 
	
	if (!boxWidgetIsOn ) { 
		cout &lt;&lt; &quot;ERROR: Please select a region of interest around the atrial body first using 'x' on your keyboard&quot; &lt;&lt; endl; 
		return;
	}

	int *is_visited = new int[polys-&gt;GetNumberOfCells()]; 
	for (int i=0;i&lt;polys-&gt;GetNumberOfCells();i++)			// running through each polygon 
	{
		is_visited[i] = 0;
	}

	planes = vtkPlanes::New();
	boxWidget-&gt;GetPlanes(planes); 
	for (int i=0;i&lt;polys-&gt;GetNumberOfCells();i++)			// running through each polygon 
	{
		
		vtkIdType neighbor_point; 
		polys-&gt;GetCellPoints(i, cell_points); 
		num_cell_points = cell_points-&gt;GetNumberOfIds(); 
        for ( neighbor_point = 0; neighbor_point &lt; num_cell_points; ++neighbor_point ) 
        { 
			// Get the neighbor point id.           
			vtkIdType neighbor_point_id = cell_points-&gt;GetId(neighbor_point); 

			// Get the neighbor point position. 
			//double cP[3]; 
			polys-&gt;GetPoint( neighbor_point_id, cP ); 
			
			if (planes-&gt;FunctionValue(cP) &lt; 0 &amp;&amp; is_visited[neighbor_point_id] == 0)		// if within the bounding box 
			{
				all_surface_points.push_back(new irtkPoint(cP[0], cP[1], cP[2]));
				num_points++; 
				is_visited[neighbor_point_id] = 1; 
			}
		}
	
		
	}

	
	LA_centroid[0] = 0; LA_centroid[1] = 0; LA_centroid[2] = 0;
	for (int i=0;i&lt;all_surface_points.size();i++)
	{
		LA_centroid[0]+=(all_surface_points[i]-&gt;_x/num_points); 
		LA_centroid[1]+=(all_surface_points[i]-&gt;_y/num_points); 
		LA_centroid[2]+=(all_surface_points[i]-&gt;_z/num_points); 
	}

	sphereActor5-&gt;SetPosition(LA_centroid);
	fl_vtk_window_1-&gt;Render();
	
	cout &lt;&lt; &quot;\n\nCENTROID COMPUTATION\n=======================\nComputed centroid of LA and this is: \n&quot; 
		&lt;&lt; &quot;(&quot; &lt;&lt; LA_centroid[0] &lt;&lt; &quot;,&quot; &lt;&lt; LA_centroid[1] &lt;&lt; &quot;,&quot; &lt;&lt; LA_centroid[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl &lt;&lt; 
		&quot;This was computed from &quot; &lt;&lt; num_points &lt;&lt; &quot; points you selected in the LA body&quot; &lt;&lt; endl &lt;&lt; 
		&quot;\nInstructions:\n===============\n\nYou can start measuring angles now by clicking 'h' on keyboard\nfor selecting the first and second \nreference points. &quot; &lt;&lt; 
		&quot;\nThe grey circle is your first reference point, and the second reference point is the blue circle. \nThe blue circle's position can be changed&quot; &lt;&lt; 
		&quot;by repeatedly clicking 'h' and this re-computes the angles. \nTo change the position of the first reference point, hit the reset pv angle button&quot; &lt;&lt; endl;
		

	isCentroidComputed = true; 
	angle_relative_position_reset = true; 
	
}

void shellOnOff_cb(Fl_Widget* widget, void* p)
{
	if (isShellOn) { renderer1-&gt;RemoveActor(heart); isShellOn = false; }
	else {renderer1-&gt;AddActor(heart); isShellOn = true; }
	fl_vtk_window_1-&gt;Render();
}

/*********************************************************************
*		All VRML and vtk tools here
*********************************************************************/
void vrml_to_vtk_cb(Fl_Widget* widget, void* p)
{
	double max_t, min_t, thresh; 
	char* vrmlfile, *vtkfile, *input; 
	vrmlfile = fl_file_chooser(&quot;Open VRML file&quot;, &quot;*.wrl&quot;, dir_path);
	
	if (vrmlfile != NULL)
	{
		
		vrml_rw = new VRMLandVTKFileReaderWriter(vrmlfile); 
		
		cout &lt;&lt; &quot;\nEnter the minimum threshold for VRML as selected by operator &gt; &quot;; 
		cin &gt;&gt; input; 
		min_t = atof(input); 

		cout &lt;&lt; &quot;\n,and MAXIMUM threshold for VRML as selected by operator &gt; &quot;; 
		cin &gt;&gt; input; 
		max_t = atof(input); 

		cout &lt;&lt; &quot;\n, and threshold for cut-off for scar &gt; &quot;; 
		cin &gt;&gt; input; 
		thresh = atof(input); 

		vtkfile = fl_file_chooser(&quot;Save as vtk file&quot;, &quot;*.vtk&quot;, dir_path);
		if (vtkfile != NULL) 
		{
			vrml_rw-&gt;SetVTKOutputFile(vtkfile); 
			vrml_rw-&gt;SetOperatorSelectedMaxAndMinValuesForVRMLModel(max_t, min_t);
		//	vrml_rw-&gt;convertToVTK(max_t-(0.5*(max_t-min_t))); 
				vrml_rw-&gt;convertToVTK(thresh); 
		}
	}
}

void open_vtk_shell_cb(Fl_Widget* widget, void* p)
{
	char* fn; 

	fn = fl_file_chooser(&quot;Open VTK file&quot;, &quot;*.vtk&quot;, dir_path);

	if (fn != NULL) 
	{
		vrml_rw = new VRMLandVTKFileReaderWriter(); 
		vrml_rw-&gt;setVTKPoly1(fn); 
		
		vtkSmartPointer&lt;vtkCallbackCommand&gt; callback = vtkSmartPointer&lt;vtkCallbackCommand&gt;::New();
		callback-&gt;SetCallback(keyPressedFunction);
		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);
		
		vrml_rw-&gt;displayVTK1(fl_vtk_window_1); 
		camera1-&gt;SetPosition(0,0,500);
		camera1-&gt;SetFocalPoint(0,0,0);
		renderer1-&gt;SetActiveCamera(camera1);
	}

}	
/******************************************************************
*		end VRML and vtk tools
*******************************************************************/

/***********************
*	Encircle tools 
*
***********************/
void open_vtk_shell_encircler_cb(Fl_Widget* widget, void* p)
{
	char* fn; 

	fn = fl_file_chooser(&quot;Open VTK file&quot;, &quot;*.vtk&quot;, dir_path);

	if (fn != NULL) 
	{
		enc = new Scar3DTools(); 
		enc-&gt;setVTKPoly(fn); 
		
		vtkSmartPointer&lt;vtkCallbackCommand&gt; callback = vtkSmartPointer&lt;vtkCallbackCommand&gt;::New();
		callback-&gt;SetCallback(keyPressedFunction);
		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);
		
		enc-&gt;DisplaySurfaceToScreen(fl_vtk_window_1); 
		camera1-&gt;SetPosition(0,0,500);
		camera1-&gt;SetFocalPoint(0,0,0);
		renderer1-&gt;SetActiveCamera(camera1);
	}

}	


/***********************
*	End of Encircle tools 
*
***********************/

void quit_cb(Fl_Widget*, void*)
{
	 destroy();
	 exit(0);
}

void LeftMouseButtonReleasedFunction(vtkObject* obj, unsigned long,void *sr, void *)
{
	isLeftButtonHeld = false; 
}

void LeftMouseButtonPressedFunction(vtkObject* obj, unsigned long,void *sr, void *)
{
	isLeftButtonHeld = true; 
}


void mouseMovedFunction(vtkObject* obj, unsigned long,void *sr, void *)
{
	  if (isAllowSync &amp;&amp; isLeftButtonHeld)
	  {
		//cout &lt;&lt; &quot;mouse is held and now moving ... &quot; &lt;&lt; isLeftButtonHeld;
		double cam_pos[3]; 
		camera1-&gt;GetPosition(cam_pos);
		camera2-&gt;SetFocalPoint(cam_pos[0], cam_pos[1], cam_pos[2]);
		camera2-&gt;SetPosition(0,0,0); 
		
		renWin2-&gt;Render();

	  }
}

void keyPressedFunction(vtkObject* obj, unsigned long,void *sr, void *)
{
	int p_index;
	double c[3];
	double *s, *y;
	vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::SafeDownCast(obj);
	switch (iren-&gt;GetKeyCode())
	{
		case 'x':
			if (boxWidgetIsOn)
			{
				boxWidget-&gt;Off();
				//boxWidget2-&gt;Off();
				boxWidgetIsOn = false;
			}
			else
			{
				boxWidget-&gt;On();
				//boxWidget2-&gt;On();
				boxWidgetIsOn = true;
			}
		break;

		case 'r': 
			if (voltageScarBoxWidgetIsOn) { voltageScarBoxWidget-&gt;Off(); voltageScarBoxWidgetIsOn = !voltageScarBoxWidgetIsOn; }
			else { voltageScarBoxWidget-&gt;On(); voltageScarBoxWidgetIsOn = !voltageScarBoxWidgetIsOn; } 
		break;
		
		case 'p':		/* sselecting foreground */ 
		case 'o':		/* selecting background */ 

				// MRI_DATA contains the late-gad scar image
				screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
				screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
				picker2-&gt;Pick(screenX,screenY,0.0, renderer1);
				picker2-&gt;GetPickPosition(picker2_pos);
				mri_data.WorldToImage(picker2_pos[0], picker2_pos[1], picker2_pos[2]);
			
				if (picker2_pos[0] &gt; 0 &amp;&amp; picker2_pos[0] &lt; mri_data.GetX() &amp;&amp;
					picker2_pos[1] &gt; 0 &amp;&amp; picker2_pos[1] &lt; mri_data.GetY() &amp;&amp; 
					picker2_pos[2] &gt; 0 &amp;&amp; picker2_pos[2] &lt; mri_data.GetZ()) 
				{
					//cout &lt;&lt; &quot;( &quot; &lt;&lt; picker2_pos[0] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[1] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
					renderer1-&gt;RemoveActor(xSlice); 
					
					/*
						for (int i=-1;i&lt;=1;i++) { 
							for (int j=-1;j&lt;=1;j++) {
								for (int k=-1;k&lt;=1;k++) {
									if (picker2_pos[0]+i &gt;= 0 &amp;&amp; picker2_pos[0]+i &lt;maxX &amp;&amp; picker2_pos[1]+j &gt;= 0 &amp;&amp; picker2_pos[1]+j &lt; maxY &amp;&amp; 
										picker2_pos[2]+k &gt;= 0 &amp;&amp; picker2_pos[2]+k &lt; maxZ)
									{ 
									

										if (iren-&gt;GetKeyCode() == 'y' &amp;&amp; mri_data.Get(picker2_pos[0]+i, picker2_pos[1]+j, picker2_pos[2]+k) &gt; 0)
											class_labels.Put(picker2_pos[0]+i, picker2_pos[1]+j, picker2_pos[2]+k, F_INDICATOR); 
										else if (iren-&gt;GetKeyCode() == 't' &amp;&amp; mri_data.Get(picker2_pos[0]+i, picker2_pos[1]+j, picker2_pos[2]+k) &gt; 0)
											class_labels.Put(picker2_pos[0]+i, picker2_pos[1]+j, picker2_pos[2]+k, B_INDICATOR); 
									}
									
								}

							}
						}*/
						// IF YOU WANT TO PICK ONLY SINGLE POINTS TURN THIS ON AND THE ABOVE CODE OFF
					if (iren-&gt;GetKeyCode() == 'p' &amp;&amp; mri_data.Get(picker2_pos[0], picker2_pos[1], picker2_pos[2]) &gt; 0)
						class_labels.Put(picker2_pos[0], picker2_pos[1], picker2_pos[2], F_INDICATOR); 
					else if (iren-&gt;GetKeyCode() == 'o' &amp;&amp; mri_data.Get(picker2_pos[0], picker2_pos[1], picker2_pos[2]) &gt; 0)
						class_labels.Put(picker2_pos[0], picker2_pos[1], picker2_pos[2], B_INDICATOR); 
					//cout &lt;&lt; &quot;foreground selected .. &quot; &lt;&lt; endl; 
					class_labels.ImageToVTK(struct_points_data);
					sliceXColors-&gt;SetInput(struct_points_data);
					sliceXColors-&gt;SetLookupTable(bwLut);
					xSlice-&gt;SetInput(sliceXColors-&gt;GetOutput());
					xSlice-&gt;SetDisplayExtent(xPos, xPos, 0, maxY-1, 0, maxZ-1);
					renderer1-&gt;AddActor(xSlice); 
					imageActorArray[2] = xSlice;
					fl_vtk_window_1-&gt;Render(); 
					
				}

		break; 
		case 'l' :
			ensite.displayXYZPointsFromVoltageMap(fl_vtk_window_1, sphereActors); 
		break; 
		case 'g' : 
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			picker2-&gt;Pick(screenX,screenY,0.0, renderer1);
			picker2-&gt;GetPickPosition(picker2_pos);
			//xyplot_win-&gt;show(); 
			/* to display XY chart of voltage trace */
			
			plotactor = vtkXYPlotActor::New();
			ensiteGraphics.FindClosestVoltagePointIndexToPickedPoint(picker2_pos, p_index);
			ensiteGraphics.FindGeodesicDistanceFromPickedPointToClosestVoltagePoint(polys_3, picker2_pos, p_index, currStdDevForVoltage, currdistThreshForVoltage, currkNearestForVoltage);
			ensiteGraphics.displayXYVoltageTracePlot(fl_vtk_window_4, p_index, plotactor);
			c[0] = ensite._voltage_xyz[p_index]-&gt;_x;  c[1] = ensite._voltage_xyz[p_index]-&gt;_y; c[2] = ensite._voltage_xyz[p_index]-&gt;_z; 
			ensite.displayClosestVoltagePointInfo(c, fl_vtk_window_1);
			
			//ensiteGraphics.displayTimeArrivalInfo(p_index);
			displayScarInfo(c); 
			// if you want to debug the voltage interpolation scheme then turn this on 
			/*
			ensite.displayClosestVoltagePointInfo(picker2_pos, fl_vtk_window_1); 
			ensiteGraphics.debugVoltageInterpolation(picker2_pos, polys_3); */
			
		break; 
		case 'a':
			if (toggleScarVoltageROI ==1) {
				croppedGeomActor_Scar-&gt;GetProperty()-&gt;SetOpacity(1.0); 
				croppedGeomActor_Voltage-&gt;GetProperty()-&gt;SetOpacity(0.0);
				toggleScarVoltageROI=0;
				fl_vtk_window_1-&gt;Render();
			}
			else
			{
				croppedGeomActor_Scar-&gt;GetProperty()-&gt;SetOpacity(0.0); 
				croppedGeomActor_Voltage-&gt;GetProperty()-&gt;SetOpacity(1.0);
				toggleScarVoltageROI=1;
				fl_vtk_window_1-&gt;Render();
			}

		break; 
		case 's':
			RemoveActorAndScalarBar(1);
		break; 

		case 'v':
			RemoveActorAndScalarBar(2); 
		break; 

		case 't': 
			RemoveActorAndScalarBar(3);
		break; 
		case '/': 
			if (labelOn){ 
				//renderer1-&gt;AddActor2D(peakTimeContourLabels); 
				for (int i=0;i&lt;contour3DLabels.size();i++) { renderer1-&gt;AddActor(contour3DLabels[i]); }
				labelOn = !labelOn; fl_vtk_window_1-&gt;Render();}
			else { 
				//renderer1-&gt;RemoveActor2D(peakTimeContourLabels); 
				for (int i=0;i&lt;contour3DLabels.size();i++) { renderer1-&gt;RemoveActor(contour3DLabels[i]); }
				labelOn = !labelOn; fl_vtk_window_1-&gt;Render(); }

		break;
		case 'h': 
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			cell_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			s = cell_picker-&gt;GetSelectionPoint(); 
			y = cell_picker-&gt;GetPickPosition(); 

			
			cout &lt;&lt; &quot;You selected point #&quot; &lt;&lt; angle_point_num &lt;&lt; &quot;(&quot; &lt;&lt; y[0] &lt;&lt; &quot;,&quot; &lt;&lt; y[1] &lt;&lt; &quot;,&quot; &lt;&lt; y[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl; 
			
			if (angle_relative_position_reset &amp;&amp; angle_point_num == 0) { angle_point_1[0] = y[0]; angle_point_1[1] = y[1]; angle_point_1[2] = y[2]; } 
			else if (angle_point_num == 1) { angle_point_2[0] = y[0]; angle_point_2[1] = y[1]; angle_point_2[2] = y[2];  } 
			
			if (angle_point_num == 0) {
				sphereActor3-&gt;SetPosition(angle_point_1);
				angle_point_num++;
				cout &lt;&lt; &quot;Reset... &quot; &lt;&lt; endl;
			}
			else {
				sphereActor4-&gt;SetPosition(angle_point_2);
				Fl_Widget* f; 
				pv_angle_measure_cb(f, f); 
			}
			
			fl_vtk_window_1-&gt;Render(); 
				/*
			mri_data.WorldToImage(picker2_pos[0], picker2_pos[1], picker2_pos[2]);
			cout &lt;&lt; &quot;Point no. &quot; &lt;&lt; angle_point_num &lt;&lt; &quot; picked for measuring angles:&quot; &lt;&lt; endl;
			cout &lt;&lt; &quot;( &quot; &lt;&lt; picker2_pos[0] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[1] &lt;&lt; &quot;, &quot; &lt;&lt; picker2_pos[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
			sphereActor-&gt;SetPosition(picker2_pos);
			fl_vtk_window_1-&gt;Render();
		
			if (picker2_pos[0] &gt; 0 &amp;&amp; picker2_pos[0] &lt; mri_data.GetX() &amp;&amp;
				picker2_pos[1] &gt; 0 &amp;&amp; picker2_pos[1] &lt; mri_data.GetY() &amp;&amp; 
				picker2_pos[2] &gt; 0 &amp;&amp; picker2_pos[2] &lt; mri_data.GetZ()) 
			{
				if (angle_point_num &lt; 0 &amp;&amp; angle_point_num &gt;= 3) 
				{
					angle_point_num = 0; 
				}
				selected_angle_points[angle_point_num][0] = picker2_pos[0]; 
				selected_angle_points[angle_point_num][1] = picker2_pos[1]; 
				selected_angle_points[angle_point_num][2] = picker2_pos[2]; 
			}
			*/
		break;

		case '1': 
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];

		break;

		default:
			cout &lt;&lt; &quot;Keys: b - toggle box widget&quot; &lt;&lt; endl;
		break;
		

	}
}

void superimpose_cb(Fl_Widget*, void*)
{
	if (!isActorSuperImposed)
	{
		renderer1-&gt;AddActor(heart_copy);
		//renderer1-&gt;AddActor(sphereActor);
		renderer1-&gt;Render();
		isActorSuperImposed = true;
	}
	else
	{
		renderer1-&gt;RemoveActor(heart_copy);
		renderer1-&gt;Render();
		isActorSuperImposed = false;
	}
}

void start_angle_measure_cb(Fl_Widget*, void*) 
{
	

}

void start_ostia_measure_cb(Fl_Widget*, void*)
{
	if (PlaneWidgetPlaced == true)
	{
		if (intersec_points_container.size() &gt; 0) 
			intersec_points_container.clear(); 
		
		//getIntersectionPointsBetweenCuttingPlaneAndPVSurface(planeWidget, &amp;input, 0.1, intersec_points_container); 
		planeWidget-&gt;SetRepresentationToOutline();
		getIntersectionPointsBetweenCuttingPlaneAndPVSurface2(planeWidget, &amp;input, intersec_points_container, best_fit_ellipse_points_container,
							ellipse_a, ellipse_b, max_diameter, min_diameter, mean_diameter, circumference, max_diam_range, min_diam_range, false); 
		
		if (bestFitEllipseActor != NULL)
			renderer1-&gt;RemoveActor(bestFitEllipseActor);
		bestFitEllipseActor = drawEllipse(best_fit_ellipse_points_container, fl_vtk_window_1, &amp;input);
		//drawEllipse(max_diam_range, fl_vtk_window_1, &amp;input); 
		//drawEllipse(min_diam_range, fl_vtk_window_1, &amp;input); 
		best_fit_ellipse_points_container.clear();
		ellipse_circumference = PI * (3*(ellipse_a+ellipse_b) - sqrt(((3*ellipse_a)+ellipse_b)*(ellipse_a + 3*ellipse_b))); 
		
		cout  &lt;&lt; &quot;\n\nOstia Measurements\n==============\n\nMajor axis (a) = &quot; &lt;&lt; ellipse_a &lt;&lt; &quot;, ax2 = &quot; &lt;&lt; (2*ellipse_a) &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;Minor axis (b) = &quot;&lt;&lt;ellipse_b&lt;&lt;
			&quot;, bx2 = &quot; &lt;&lt; (2*ellipse_b) &lt;&lt; &quot;\nEllipse circumference = &quot; &lt;&lt; 	ellipse_circumference &lt;&lt;&quot;\n\nUsing second method:\n&quot;&lt;&lt;
			&quot;Min diameter = &quot;&lt;&lt;min_diameter&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;Max diameter = &quot;&lt;&lt;max_diameter&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;Mean diameter = &quot;&lt;&lt;mean_diameter&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;circumference = &quot;&lt;&lt;circumference;
	}
	else
	{
		cout &lt;&lt; &quot;\nWarning:\nYou must first place the plane of interest by going to Tools -&gt; Ostia measure\m&quot;;
	}
	
}

void slice_onoff(Fl_Widget*, void* xyz)
{
	int which_xyz; 
	bool isRemoveActor;
	int sliceIndex; 

	which_xyz = (int)xyz; 
	
	if (which_xyz==0) { isRemoveActor = isXSliceOn; isXSliceOn = !isXSliceOn; sliceIndex = 2; } 
	if (which_xyz==1) { isRemoveActor = isYSliceOn; isYSliceOn = !isYSliceOn; sliceIndex = 1; } 
	if (which_xyz==2) { isRemoveActor = isZSliceOn; isZSliceOn = !isZSliceOn; sliceIndex = 0; }

	if (isRemoveActor)
		renderer1-&gt;RemoveActor(imageActorArray[sliceIndex]);
	else 
		renderer1-&gt;AddActor(imageActorArray[sliceIndex]);

	fl_vtk_window_1-&gt;Render();

}

void setPathCallback_cb(Fl_Widget*, void* textfield)
{
	const char* newpath; 
	Fl_Output* textDisplay = (Fl_Output*)(textfield);
	//sprintf(buffer,&quot;%f&quot;,v);
	
	newpath = fl_dir_chooser(&quot;Select your image folder&quot;, dir_path);
	if (newpath != NULL)
	{
		strcpy(dir_path, newpath);
	}

	textDisplay-&gt;value(dir_path);
	isImageFolderSet = true; 
}

/********************
* end of all button callbacks 
*********************/


void getStatisticalMeasure(vector&lt;irtkPoint*&gt; vals, irtkRealImage* grey_im, /*irtkRealImage* visited_im, */ int measure, double&amp; returnVal)
{
	double sum=0, max=-1, greyVal, visitedStatus; 
	int size = vals.size();
	int maxIndex; 

	if (measure == 1)			// reutrn mean 
	{
		for (int i=0;i&lt;size;i++)
		{
			sum+=grey_im-&gt;Get(vals[i]-&gt;_x, vals[i]-&gt;_y, vals[i]-&gt;_z); 
		}
		returnVal = sum/size;			
	}
	if (measure == 2)			// return max 
	{
		
		for (int i=0;i&lt;size;i++)
		{
			greyVal = grey_im-&gt;Get(vals[i]-&gt;_x, vals[i]-&gt;_y, vals[i]-&gt;_z); 
			//visitedStatus = visited_im-&gt;Get(vals[i]-&gt;_x, vals[i]-&gt;_y, vals[i]-&gt;_z); 
			
			if (greyVal &gt; max /*&amp;&amp; visitedStatus &lt; 1*/) { 
				max = greyVal; 
				maxIndex = i; 
			}
		}
		if (max== -1) 
			returnVal = 0; 
		else {
			returnVal = max;

			// now change the visited status of this max pixel 
			//visited_im-&gt;Put(vals[maxIndex]-&gt;_x, vals[maxIndex]-&gt;_y, vals[maxIndex]-&gt;_z, 1); 
		}
	}
	if (measure == 3)			// sum along the normal (integration)
	{
		for (int i=0;i&lt;size;i++)
		{
			greyVal = grey_im-&gt;Get(vals[i]-&gt;_x, vals[i]-&gt;_y, vals[i]-&gt;_z); 
			sum+=greyVal; 
		}
		returnVal = sum;
	}
	
	
}

// write the profiles to a file for post-processing 
void getProfilesToFile(vector&lt;double&gt; vals, ofstream&amp; out) 
{
	
	for (int i=0;i&lt;vals.size();i++)
	{
		out &lt;&lt; vals [i] &lt;&lt; &quot;\t&quot;; 
	}
	out &lt;&lt; endl; 
}

// Returns the intensity (mean, median, etc.) along a given normal (to a polygonal plane with given centre). The polygonal plane 
// is one of the many polygons of a vtkPolyData generated from a marching cubes algorithm (used in surface contouring/rendering)
// NOTE: the co-ordinates of normal and centre are all in the irtk image co-ordinate system (NOT VTK co-ordinate system)
// Uses GLOBAL mri_data (scar image) for bounds check
void getIntensityAlongNormal(double n_x, double n_y, double n_z, double centre_x, double centre_y, double centre_z, 
							 /*irtkRealImage* normal_band,*/ double&amp; returnVal)
{
	int size=0, j=0, indexOfPointInArray=-1, currIndex=0, a,b,c;
	double insty=0,x=0,y=0,z=0, rounded_x, rounded_y, rounded_z; 
	vector&lt;irtkPoint*&gt; pointsOnAndAroundNormal; 
	
	// normalize
	
	normalizeVector(n_x, n_y, n_z);
	
	for (double i=scar_step_min;i&lt;=scar_step_max;i+=scar_step_size)
	{
		x = centre_x + (i*n_x); 
		y = centre_y + (i*n_y); 
		z = centre_z + (i*n_z);
		x = floor(x); y=floor(y); z=floor(z);
		for (a=-1;a&lt;=1;a++) { for (b=-1;b&lt;=1;b++) { for (c=-1;c&lt;=1;c++) { 
			if (x+a&gt;=0 &amp;&amp; x+a&lt;mri_data.GetX() &amp;&amp; y+b&gt;=0 &amp;&amp; y+b&lt;mri_data.GetY() &amp;&amp; z+c&gt;=0 &amp;&amp; z+c&lt;mri_data.GetZ()) { 
				//if (normal_band-&gt;Get(x+a,y+b,z+c) &gt; 0){ 
					pointsOnAndAroundNormal.push_back(new irtkPoint(x+a, y+b, z+c)); 
				//}
			}
		}}}
	}


	if (_SCAR_MIP == 1) {
		getStatisticalMeasure(pointsOnAndAroundNormal, &amp;mri_data, /*&amp;pixelsInMIP, */ 2, insty);			// statistical measure 2 returns max 
		
	} else if (_SCAR_INTEGRAL == 1) {
		getStatisticalMeasure(pointsOnAndAroundNormal, &amp;mri_data, /*&amp;pixelsInMIP, */ 3, insty);
		//insty = insty/100;
	}

	if (_WRITE_NORMAL_PROFILE_TO_FILE == 1)
	{
		//getProfilesToFile(pointsOnAndAroundNormal, normalFileWriteStream);
	}

	
	returnVal = insty; 
	for (int i=0;i&lt;pointsOnAndAroundNormal.size();i++) delete pointsOnAndAroundNormal[i]; 
	pointsOnAndAroundNormal.clear();
	
}


// to check if point is inside 
bool isPointInsideBox(int x, int y, int z, vtkPlanes* planes, irtkRealImage* i)
{
	// checks if point lies inside vtkBoxWidget - global var.

	double pos[3];
	pos[0] = x;
	pos[1] = y;
	pos[2] = z;

	i-&gt;ImageToWorld(pos[0], pos[1], pos[2]);
	double v = planes-&gt;FunctionValue(pos);

	if (v &lt; 0)
	{
		return true;
	}
	else
	{
		return false;
	}


}

void exportSurfaceAsEnsiteXML(Fl_Widget* w, void* vptr)
{
	char* newfile; 
	newfile = fl_file_chooser(&quot;Save XML Atrial geometry Mesh&quot;, &quot;*.xml&quot;, dir_path);
	if (newfile != NULL)
	{
		ensite.DifWriter(newfile, polys); 
	}
}

void exportScarSurfaceAsEnsiteXML(Fl_Widget* w, void* vptr)
{
	char* newfile; 
	newfile = fl_file_chooser(&quot;Save XML Scar Mesh&quot;, &quot;*.xml&quot;, dir_path);
	if (newfile != NULL)
	{
		/* if useing graph-cuts scar segmentation */
		//ensite.DifWriter(newfile, classifier.scar_polys); 

		/* if using simple thresholding */ 
		ensite.DifWriter(newfile, thresholdedScar);
	}
}

void showTraceIsochroneMap(Fl_Widget* w, void* vptr)
{
	if (isVoltageDataLoaded)
	{
		double c = ensiteGraphics.getTimeIncrConstant();
		
		cout &lt;&lt; &quot;computing all isochrone maps ... total size = &quot; &lt;&lt; voltageNodeList.size() &lt;&lt; &quot;start: &quot;;
		for (int i=300;i&lt;350;i++)
		{
			ensite.GetVoltageTraceIsochrone(i, c , voltageTraceIsochrone, minISOScalar, maxISOScalar);
			ensiteGraphics.SetIsoChroneActors(fl_vtk_window_1, polys, voltageNodeList, currISOPtInfl, voltageTraceIsochrone, isochroneMapper, isochroneActors[i-300], isochroneLuts[i-300], minISOScalar, maxISOScalar, 0.33, false); 
			voltageTraceIsochrone.clear();
			cout &lt;&lt; i &lt;&lt; &quot;, (maxV,minV) = (&quot; &lt;&lt; maxISOScalar&lt;&lt; &quot;,&quot; &lt;&lt; minISOScalar &lt;&lt; &quot;) -- &quot;;
		}
		cout &lt;&lt; &quot;finished!&quot;; 
		renderer1-&gt;AddActor(isochroneActors[0]); 
		prev_iso_actor_index = 0;
		renWin1-&gt;Render();
	}
	else
	{
		cout &lt;&lt; &quot;ERROR! Voltage data not yet loaded .. cannot generate isochrone map without voltage data&quot; &lt;&lt; endl;
	}
}

void importVoltageDataAsCSV(Fl_Widget* w, void* vptr)
{
	char* newfile; 
	int num_surfaces = 0;
	newfile = fl_file_chooser(&quot;Open CSV voltage&quot;, &quot;*.csv&quot;, dir_path);
	int num_files = -1; 
	
	// init the polydatamapper so that the atrial surface (with voltage) can be drawn 
	voltageSurfaceMapper-&gt;SetInput(polys_3);
	isochroneMapper-&gt;SetInput(polys); 
	renderer1-&gt;RemoveActor(heart);
	if (newfile != NULL)
	{
		cout &lt;&lt; &quot;Need to know how many files there are to import &gt;&quot;; 
		cin &gt;&gt; num_files;  
		if (num_files &gt; 0) {
			vtkActor* voltage_actor = vtkActor::New(); 
			ensite.VoltageFileReadDriver(newfile, num_files); 
			
			ensite.TransformXYZVoltagePointsToOurOrientation();
	cout &lt;&lt; &quot;\nout of TransformXYZVoltagePointsToOurOrientation&quot; &lt;&lt; endl;	
			ensiteGraphics.SetVoltageXYZVector(ensite._voltage_xyz); 
			ensiteGraphics.SetVoltageTraceVector(ensite._voltage_trace); 
	cout &lt;&lt; &quot;\nout of SetVoltageTraceVector&quot; &lt;&lt; endl;	
			ensiteGraphics.SetVoltagePeak2PeakVector(ensite._voltage_peak2peak); 
	cout &lt;&lt; &quot;\nout of SetVoltagePeak2PeakVector&quot; &lt;&lt; endl;	
			ensiteGraphics.SetVoltageTempVector(ensite._voltage_peak2peak);				// important as interpolaters now use _voltage_temp to look for voltage

		cout &lt;&lt; &quot;\nout of SetVoltageTempVector&quot; &lt;&lt; endl;	
			ensite.getClosestPointsOnGeomtryMesh(polys_3, voltageNodeList); 
		cout &lt;&lt; &quot;\nout of getClosestPointsOnGeomtryMesh&quot; &lt;&lt; endl; 
			ensiteGraphics.ComputeShortestPathsUsingDijkstra(polys_3, voltageNodeList);
			ensiteGraphics.RelaxNodesWithInfiniteDis(polys_3); 
	//ensiteGraphics.computeVoltagePeakToPeakFromWaveform();		
			ensiteGraphics.InterpolateScalars(polys_3, voltageNodeList, 0, 2);	// interpolating peak2peak voltages
			ensiteGraphics.displayGeometryWithInterpolatedVoltage(fl_vtk_window_1, polys_3, voltageSurfaceMapper, voltageMapActor, voltageLut, scalarBarForVoltage); 
			renderer1-&gt;RemoveActor(voltageMapActor); 
		/* TURN THIS ON IF YOU WANT TO SEE PEAK ARRIVAL TIMES 
			maxPeakArrivalScalar = ensiteGraphics.PrepareForDisplayingPeakArrivalTimes(polys_2, voltageNodeList);
			currPeakArrivalScalar = maxPeakArrivalScalar;

			ensiteGraphics.DisplayPeakArrivalTimeActor(fl_vtk_window_1, polys_2, peakTimeActor, peakTimeLut, peakTimeScalarBar, currPeakArrivalScalar, currPeakArrivalHue, false);
			ensiteGraphics.DisplayIsoContoursOFPeakArrival(fl_vtk_window_1, polys_2, currPeakArrivalScalar, peakTimeContourActor, peakTimeContourLabels, contour3DLabels);
			renderer1-&gt;RemoveActor(peakTimeActor); 
			renderer1-&gt;RemoveActor(peakTimeContourActor); */
			//renderer1-&gt;RemoveActor2D(peakTimeContourLabels); 
			
			for (int i=0;i&lt;contour3DLabels.size();i++) { renderer1-&gt;RemoveActor(contour3DLabels[i]); }

		//ensiteGraphics.DisplayPeakArrivalTimeActor(fl_vtk_window_1, polys_3, voltageNodeList, peakTimeActor, peakTimeLut, scalarBarForPeakTime,  false);
		//ensiteGraphics.WriteDjikstraShortestPathArrayToFile();
		//ensiteGraphics.verifyShortestDistanceBasedOnVisualInspection(polys_3, 0); 
		//ensiteGraphics.displayGeometryWithInterpolatedVoltage(fl_vtk_window_1, polys_3, voltageSurfaceMapper, voltageMapActor, voltageLut, scalarBarForVoltage, voltageNodeList[0]); 
			
			isochroneActors = new vtkActor*[voltageNodeList.size()];
			isochroneLuts = new vtkLookupTable*[voltageNodeList.size()];
			for (int i=0;i&lt;voltageNodeList.size();i++)
			{
				isochroneActors[i] = vtkActor::New();
				isochroneLuts[i] = vtkLookupTable::New();
			}

			isVoltageDataLoaded = true;
		}
	}

	// must do this as peak time arrival values are inserted into _voltage_peak2peak 
	ensiteGraphics.ClearVoltageTempVector();	
	ensiteGraphics.SetVoltageTempVector(ensite._voltage_peak2peak);	
	
}

void importGeometryDataAsCSV(Fl_Widget* w, void* vptr)
{
	char* newfile; 
	int num_surfaces = 0;
	newfile = fl_file_chooser(&quot;Open CSV geometry&quot;, &quot;*.txt&quot;, dir_path);
	
	if (newfile != NULL)
	{
		
		num_surfaces = ensite.GeometryReader(newfile, ensiteImportedGeometry);
		for (int i=0;i&lt;num_surfaces;i++)
		{
			
			vtkPolyData* geom = vtkPolyData::New(); 
			vtkActor* geom_actor = vtkActor::New(); 
			ensiteImportedGeometry.push_back(geom); 
			importedGeometry.push_back(geom_actor); 
		}
		ensite.ReconstructGeometryForAllSurfaces(ensiteImportedGeometry); 
		ensite.displayImportedGeometries(fl_vtk_window_1, ensiteImportedGeometry, importedGeometry);
		//ensite.WriteGeometryToDisk(ensiteImportedGeometry);
	}
}

void generateVoltageScarCorrelation(Fl_Widget* w, void* vptr)
{
	char* newfile; 
	int num_surfaces = 0;
	newfile = fl_file_chooser(&quot;Save as txt file&quot;, &quot;*.txt&quot;, dir_path);
	vector&lt;double&gt; dummy; 

	if (newfile != NULL)
	{
		ofstream outputToFile; 
		outputToFile.open(newfile);		
		ensite.GetVoltageScarInfo(polys, recursive_neighbour_order, voltage_threshold, dummy, outputToFile, 1);		
		outputToFile.close(); 
	}
}

void displayXYPlotVoltageScarCorrelation(Fl_Widget* w, void* vptr)
{
	plotactor = vtkXYPlotActor::New(); 
	ensite.displayVoltageScarCorrelationPlot(fl_vtk_window_4, polys, plotactor, recursive_neighbour_order, voltage_threshold);
	
}



void generate_shell(irtkRealImage* image, int mcubes_threshold, vtkPolyData* surface)
{
	cout &lt;&lt; &quot;Generating LA shell from binary image .. &quot;;
	vtkSmartPointer&lt;vtkStructuredPoints&gt; vtkImage = vtkSmartPointer&lt;vtkStructuredPoints&gt;::New();
	vtkSmartPointer&lt;vtkImageCast&gt; imageCast = vtkSmartPointer&lt;vtkImageCast&gt;::New();
	image-&gt;ImageToVTK(vtkImage);
	cout &lt;&lt; &quot;Generated vtk unstructured points ... &quot; &lt;&lt; endl;
	imageCast-&gt;SetInput(vtkImage);
	imageCast-&gt;SetOutputScalarTypeToUnsignedShort();
	vtkSmartPointer&lt;vtkMarchingCubes&gt; cubes = vtkSmartPointer&lt;vtkMarchingCubes&gt;::New();
	imageCast-&gt;Update();
	cubes-&gt;SetInputConnection(imageCast-&gt;GetOutputPort());
	cubes-&gt;SetValue(0,mcubes_threshold);
	cubes-&gt;Update();
	cout &lt;&lt; &quot;Applying taubin smoothing &quot; &lt;&lt; endl;
	// taubin smoothing 

	vtkSmartPointer&lt;vtkWindowedSincPolyDataFilter&gt; taubin_smoother = vtkSmartPointer&lt;vtkWindowedSincPolyDataFilter&gt;::New();
	taubin_smoother-&gt;SetInput(cubes-&gt;GetOutput());
	taubin_smoother-&gt;SetNumberOfIterations(num_smoothing_iterations);
	taubin_smoother-&gt;BoundarySmoothingOff();
	taubin_smoother-&gt;FeatureEdgeSmoothingOff();
	taubin_smoother-&gt;SetFeatureAngle(120.0);
	taubin_smoother-&gt;SetPassBand(0.001);
	taubin_smoother-&gt;NonManifoldSmoothingOn();
	taubin_smoother-&gt;NormalizeCoordinatesOn();
	taubin_smoother-&gt;Update();

	surface-&gt;DeepCopy(taubin_smoother-&gt;GetOutput()); 
	cout &lt;&lt; &quot;generation complete!&quot; &lt;&lt; endl;
}

vtkActor* show_surface_normals(vtkFlRenderWindowInteractor *&amp;flrwi, irtkRealImage* image, int mcubes_threshold, vtkActor* heart, 
							   vtkScalarBarActor* scalarBar, irtkRealImage* scar_image, irtkRealImage* normal_band, double mean, double var)
{
	cout &lt;&lt; &quot;Inside surface normals .. &quot; &lt;&lt; endl;
	double scalar=0, cX=0, cY=0, cZ=0, max_scalar=-1, min_scalar=1E10, max_sdev=-1e9, max_sratio=-1e9, meanTopNScalar;	
	double sdev, sratio, sintensity; 
	double num_points=0;
	double pN[3];
	double cP[3];
	
	double pixelSizeOfSegmentation[3];
	vtkIdType num_cell_points; 
	vtkSmartPointer&lt;vtkIdList&gt; point_cells = vtkSmartPointer&lt;vtkIdList&gt;::New(); 
	vtkSmartPointer&lt;vtkIdList&gt; cell_points = vtkSmartPointer&lt;vtkIdList&gt;::New(); 
	vector&lt;double&gt; allScalarsInShell;
	Scar3DTools *scar3dtools = new Scar3DTools();
	vtkSmartPointer&lt;vtkRenderer&gt; renderer;
	vtkSmartPointer&lt;vtkRenderWindow&gt; renderWin;

	//image-&gt;GetPixelSize(&amp;pixelSizeOfSegmentation[0], &amp;pixelSizeOfSegmentation[1], &amp;pixelSizeOfSegmentation[2]);
	
	ofstream output; 
	vtkSmartPointer&lt;vtkPolyData&gt; scalars_at_points;				// in July 2011 - to get smoother looking shells
	output.open(&quot;scarIntensityAtAllCellsForMatlab.txt&quot;); 
	//scar_interp.SetInput(scar_image); 
	//scar_interp.Initialize();
	irtkPoint* locationOfMIP = new irtkPoint(0,0,0);
	
cout &lt;&lt; &quot;Checking if surface is provided by user .. &quot; &lt;&lt; endl;
	if (_surf_input == &quot;&quot;) { 
		generate_shell(image, mcubes_threshold, LA_surface_poly); 
	}

	vtkSmartPointer&lt;vtkPolyDataNormals&gt; normals = vtkSmartPointer&lt;vtkPolyDataNormals&gt;::New();
	normals-&gt;SetInput(LA_surface_poly);
	normals-&gt;ComputeCellNormalsOn();
	normals-&gt;Update(); 

	vtkSmartPointer&lt;vtkFloatArray&gt; scalars = vtkSmartPointer&lt;vtkFloatArray&gt;::New();		// the scalar at each polygon 
	
	// Nov2010 - Louisa's request - get different outputs polygon scalars
	vtkSmartPointer&lt;vtkFloatArray&gt; scalars_onlystdev = vtkSmartPointer&lt;vtkFloatArray&gt;::New();	
	vtkSmartPointer&lt;vtkFloatArray&gt; scalars_onlymultiplier = vtkSmartPointer&lt;vtkFloatArray&gt;::New();	
	vtkSmartPointer&lt;vtkFloatArray&gt; scalars_onlyintensity = vtkSmartPointer&lt;vtkFloatArray&gt;::New();	

	//vtkSmartPointer&lt;vtkPolyData&gt; polys = normals-&gt;GetOutput(); 
	polys = normals-&gt;GetOutput();

	polys_3-&gt;DeepCopy(polys);		// must copy structure this way to copy polydata, = is not overloaded as copy constructor
	polys_2-&gt;DeepCopy(polys); 
// APRIL 2010: transformation to correct orientation (but only for testing whether imported ensite data point cloud (for voltage) registers well with out surface
// must remove or else show with wierd orientation (i.e. oriented the correct way according to ensite)
//ensite.orientImageTheRightWayAccordingToEnsite(polys); 

	vtkSmartPointer&lt;vtkFloatArray&gt; cellNormals= vtkFloatArray::SafeDownCast(polys-&gt;GetCellData()-&gt;GetNormals());
	
boxWidget-&gt;GetPlanes(box_1_plane); 
boxWidget2-&gt;GetPlanes(box_2_plane);

	cout &lt;&lt; &quot;Number of polygons = &quot; &lt;&lt; normals-&gt;GetOutput()-&gt;GetNumberOfCells();
	cout &lt;&lt; &quot;\nNumber of noramls = &quot; &lt;&lt; cellNormals-&gt;GetNumberOfTuples();

	if (_WRITE_NORMAL_PROFILE_TO_FILE == 1)
	{
		normalFileWriteStream.open(&quot;normal_profile.txt&quot;); 
	}


	for (int i=0;i&lt;polys-&gt;GetNumberOfCells();i++)			// running through each polygon 
	{
		cellNormals-&gt;GetTuple(i, pN); 
	
		cX=0; cY=0; cZ=0; num_points=0;
		vtkIdType neighbor_point; 
		polys-&gt;GetCellPoints(i, cell_points); 
		num_cell_points = cell_points-&gt;GetNumberOfIds(); 
        for ( neighbor_point = 0; neighbor_point &lt; num_cell_points; ++neighbor_point ) 
        { 
			// Get the neighbor point id.           
			vtkIdType neighbor_point_id = cell_points-&gt;GetId(neighbor_point); 

			// Get the neighbor point position. 
			//double cP[3]; 
			polys-&gt;GetPoint( neighbor_point_id, cP ); 
			scar_image-&gt;WorldToImage(cP[0], cP[1], cP[2]); 
			cX+=cP[0]; cY+=cP[1]; cZ+=cP[2]; 
			num_points++;
		}
	
		cX/=num_points; cY/=num_points; cZ/=num_points; 
//		scar_image-&gt;WorldToImage(cX, cY, cZ); 
		scar_image-&gt;WorldToImage(pN[0], pN[1], pN[2]); 

		getIntensityAlongNormal(pN[0], pN[1], pN[2], cX, cY, cZ, /*normal_band, */ scalar);	

		
		if (scalar &gt; max_scalar)
			max_scalar = scalar; 
		if (scalar &lt; min_scalar)
			min_scalar = scalar;
		
		sdev = (scalar-mean)/sqrt(var); 
		
		sratio = scalar/mean; 
		
		if (max_sdev &lt; sdev) max_sdev = sdev;
		if (max_sratio &lt; sratio) max_sratio = sratio;

		if (_ONLY_POSITIVE_STDEVS == 1 &amp;&amp; sdev &lt; 0)
			sdev = 0;
		
		scalars_onlystdev-&gt;InsertTuple1(i, sdev); 
		scalars_onlyintensity-&gt;InsertTuple1(i, scalar); 
		scalars_onlymultiplier-&gt;InsertTuple1(i, sratio); 

		// FOR DEFAULT scalar to plot 
		double scalarToPlot = (scalar-mean)/sqrt(var);			// the default what is plotted and displayed to end-user
		//double scalarToPlot = scalar/mean; 

		if (scalarToPlot &lt;= 0) scalarToPlot = 0; 
		
		if (_SCAR_MIP ==1 &amp;&amp; _SCAR_AS_STANDARD_DEVIATION == 1){ 
			scalars-&gt;InsertTuple1(i, scalarToPlot); 
			allScalarsInShell.push_back(scalarToPlot);
			//cout &lt;&lt; &quot;Only plotting positive scalars .. &quot; &lt;&lt; endl;
		}
		else {
			scalars-&gt;InsertTuple1(i, scalar); 
			allScalarsInShell.push_back(scalar);
			//cout &lt;&lt; scalars &lt;&lt; &quot;, &quot;; 
		}

		if (scalar &gt; 0 &amp;&amp; isPointInsideBox(cX, cY, cZ, box_1_plane, scar_image) ) output &lt;&lt; scalarToPlot &lt;&lt; &quot;\t&quot; &lt;&lt; mean &lt;&lt; &quot;\t&quot; &lt;&lt; var &lt;&lt; endl;

		
	}
	

	scar3dtools-&gt;GetMeanOfTopN(allScalarsInShell, 99, meanTopNScalar); 

	 _scar_stdev_poly-&gt;DeepCopy(polys); 
	 _scar_multiplier_poly-&gt;DeepCopy(polys); 
	 _scar_original_poly-&gt;DeepCopy(polys); 
	
	if (_WRITE_NORMAL_PROFILE_TO_FILE == 1)
	{
		normalFileWriteStream.close();
	}

	polys-&gt;GetCellData()-&gt;SetScalars(scalars);

	if (_USE_POINT_SCALARS == 1 ) polys-&gt;GetPointData()-&gt;SetScalars(scalars);


	if (_USE_POINT_SCALARS == 1 ) _scar_stdev_poly-&gt;GetPointData()-&gt;SetScalars(scalars_onlystdev);
	else _scar_stdev_poly-&gt;GetCellData()-&gt;SetScalars(scalars_onlystdev);
	
	if (_USE_POINT_SCALARS == 1 ) _scar_multiplier_poly-&gt;GetPointData()-&gt;SetScalars(scalars_onlymultiplier);
	else _scar_multiplier_poly-&gt;GetCellData()-&gt;SetScalars(scalars_onlymultiplier);
	
	if (_USE_POINT_SCALARS == 1 ) _scar_original_poly-&gt;GetPointData()-&gt;SetScalars(scalars_onlyintensity);
	else _scar_multiplier_poly-&gt;GetCellData()-&gt;SetScalars(scalars_onlymultiplier);
	 
	cout &lt;&lt; &quot;color ranges over scalars = (min,max) = (&quot; &lt;&lt; min_scalar &lt;&lt; &quot;, &quot; &lt;&lt; max_scalar &lt;&lt; &quot;)&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;********************\n.. but as of Aug 2011, max scalar is now &quot; &lt;&lt; meanTopNScalar &lt;&lt; &quot;\n************************\n&quot; &lt;&lt; endl;
	//surfaceMapper-&gt;SetScalarRange(0,1); 
	
	vtkSmartPointer&lt;vtkPolyDataMapper&gt; surfaceMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	if (_USE_POINT_SCALARS == 1 ) {

		surfaceMapper-&gt;SetInput(polys);
		surfaceMapper-&gt;SetScalarModeToUsePointData();
		surfaceMapper-&gt;SetColorModeToMapScalars();
	}
	else  {
		scalars_at_points = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 
		CellDataToPointData(polys, scalars_at_points);				// July 2011 - smoothing the output shell 
		surfaceMapper-&gt;SetInput(scalars_at_points);
		surfaceMapper-&gt;SetScalarModeToUsePointData();
		
		CellDataToPointData(_scar_stdev_poly, _scar_stdev_poly);	
		CellDataToPointData(_scar_original_poly, _scar_original_poly);	
		CellDataToPointData(_scar_multiplier_poly, _scar_multiplier_poly);	
	}
	
	surfaceMapper-&gt;ScalarVisibilityOn(); 
	
	_max_std_dev_in_scar = meanTopNScalar;

	if (_LUT_OVERRIDE == 1)
	{
		surfaceMapper-&gt;SetScalarRange(_LUT_OVERRIDE_MIN,_LUT_OVERRIDE_MAX);	
	}
	else if (_SCAR_MIP==1 &amp;&amp; _SCAR_AS_STANDARD_DEVIATION==1) 
		surfaceMapper-&gt;SetScalarRange(0, _max_std_dev_in_scar);		// SHOULD BE OMITTED COMPLETELY IF NORMALIZING SCALARS - LOUISA REQUEST
	else
		surfaceMapper-&gt;SetScalarRange(0,max_scalar); 
	
	// a lookuptable to map cell scalars (scar tissues) from blue to red (low  to high intensity)
	Scarlut = vtkLookupTable::New();
	if (min_scalar &lt; 1) min_scalar = 0; 
	
	if (_LUT_OVERRIDE == 1)
	{
		Scarlut-&gt;SetTableRange(_LUT_OVERRIDE_MIN,_LUT_OVERRIDE_MAX);	
	}
	else if (_SCAR_MIP==1 &amp;&amp; _SCAR_AS_STANDARD_DEVIATION==1) 
		Scarlut-&gt;SetTableRange(0,_max_std_dev_in_scar);		// Set to 0,1 - CHANGED FOR LOUISA REQUEST
	else
		Scarlut-&gt;SetTableRange(0,max_scalar); 
	
	Scarlut-&gt;SetHueRange(0.33, 0.0);			// red - 0, yellow - 60, green- 120, cyan - 180, blue - 240, magenta - 300 (on the hue circle, pg. 42 vtk book)
	Scarlut-&gt;Build(); 
	surfaceMapper-&gt;SetLookupTable(Scarlut); 

	renderWin = flrwi-&gt;GetRenderWindow();
	vtkSmartPointer&lt;vtkRendererCollection&gt; rendererCollection = renderWin-&gt;GetRenderers();
	renderer = rendererCollection-&gt;GetFirstRenderer();
	
	sphereActor = vtkActor::New();
	vtkSphereSource *sphere = vtkSphereSource::New();
	sphere-&gt;SetThetaResolution(8);
	sphere-&gt;SetPhiResolution(8);
	sphere-&gt;SetRadius(0.5);
	vtkSmartPointer&lt;vtkPolyDataMapper&gt; sphereMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	sphereMapper-&gt;ScalarVisibilityOff();
	sphereMapper-&gt;SetInput(sphere-&gt;GetOutput());
	vtkProperty *property = sphereActor-&gt;GetProperty();
	property-&gt;SetColor(0.3,0.4,0.8);
	sphereActor-&gt;SetMapper(sphereMapper);

	property = heart-&gt;GetProperty(); 
	property-&gt;SetColor(1,0,0);					// if we are using a lookuptalble .. this color will not be displayed
	heart-&gt;GetProperty()-&gt;SetOpacity(1.0);
	
	heart-&gt;SetMapper(surfaceMapper);
	
	//heart-&gt;GetProperty()-&gt;SetInterpolationToPhong();
	
	renderer-&gt;AddActor(heart);
	renderer2-&gt;AddActor(heart);
renderer2-&gt;SetActiveCamera(camera2);
	//renderer-&gt;AddActor(spikeActor); 
	renderer-&gt;AddActor(sphereActor);

	if (_IS_FANCY_REFLECTIVE_SHINY_MODEL == 1) { 
		heart-&gt;GetProperty()-&gt;SetAmbient(0.2); 
		heart-&gt;GetProperty()-&gt;SetDiffuse(0.5); 
		heart-&gt;GetProperty()-&gt;SetSpecular(1.0); 
		heart-&gt;GetProperty()-&gt;SetSpecularPower(90.0); 
		heart-&gt;GetProperty()-&gt;SetInterpolationToPhong();
		heart-&gt;GetProperty()-&gt;SetSpecularColor(1,1,1);
	}

	// scalaar bar actor (MAY 2010)
	scalarBar-&gt;SetLookupTable(Scarlut);
	scalarBar-&gt;SetTitle(&quot;intensity&quot;);
	scalarBar-&gt;SetWidth(0.08); 
	scalarBar-&gt;SetHeight(1.0); 
	scalarBar-&gt;SetDisplayPosition(8,8); 
	renderer-&gt;AddActor2D(scalarBar);

	//renderWin-&gt;AddRenderer(renderer);
	cout &lt;&lt; &quot;Displaying segmented Image ... &quot;;


	renderWin-&gt;Render();
	cout &lt;&lt; &quot;finished rendering!&quot; &lt;&lt; endl;
	output.close(); 
	if (_SCAR_MIP==1 &amp;&amp; _SCAR_AS_STANDARD_DEVIATION==1) 
		max_scalar_in_scar = meanTopNScalar; 
	else 
		max_scalar_in_scar = max_scalar;		// AUG 2010: setting a global var for scar sliders

	// May 2011: write the max scalar (raw intensity), max sdev and max sratio to output

	ofstream sout; 
	sout.open(&quot;max_scalars.txt&quot;); 
	sout &lt;&lt; &quot;(max intenisty, max ratio , max standard deviation) = \n&quot;; 
	sout &lt;&lt; max_scalar &lt;&lt; endl;
	sout &lt;&lt; max_sratio &lt;&lt; endl;  
	sout &lt;&lt; max_sdev &lt;&lt; endl; 
	sout.close();
	
	allScalarsInShell.clear();
	return sphereActor;
}

// computes the normal myocardium tissue stats 
void compute_normal_myocardium_cb(Fl_Widget*, void* )
{
	if (boxWidgetIsOn) 
	{
		boxWidget-&gt;GetPlanes(box_1_plane); 
		computeDistributionInsideBox(&amp;mri_data, box_1_plane, myo_mean, myo_stdev); 
		cout &lt;&lt; &quot;\nMean and stdev for normal myocardium = \n&quot;; 
		cout &lt;&lt; &quot;Mean = &quot; &lt;&lt; myo_mean &lt;&lt; &quot;\nStd. dev = &quot; &lt;&lt; myo_stdev &lt;&lt; endl;
		isNormalMyocardiumComputed = true; 
	}
	else
	{
		cout &lt;&lt; &quot;Error: Myocardium ROI not selected. You need to press x to open bounding box control and select a ROI in the myocardium&quot; &lt;&lt; endl; 
		isNormalMyocardiumComputed = false; 
	}
}


void addOrientationMarkerWidget()
{
	vtkSmartPointer&lt;vtkAnnotatedCubeActor&gt; cube = vtkSmartPointer&lt;vtkAnnotatedCubeActor&gt;::New(); 
	cube-&gt;SetXPlusFaceText(&quot;R&quot;); cube-&gt;SetXMinusFaceText(&quot;L&quot;); cube-&gt;SetYPlusFaceText(&quot;A&quot;);
	cube-&gt;SetYMinusFaceText(&quot;P&quot;); cube-&gt;SetZPlusFaceText(&quot;S&quot;); cube-&gt;SetZMinusFaceText(&quot;I&quot;);
	cube-&gt;SetXFaceTextRotation(180);
	cube-&gt;SetYFaceTextRotation(180);
	cube-&gt;SetZFaceTextRotation(-90);
	cube-&gt;SetFaceTextScale(0.65);
	vtkProperty* property = cube-&gt;GetCubeProperty();
	property-&gt;SetColor(1,0 ,1);
	property = cube-&gt;GetTextEdgesProperty();
	property-&gt;SetLineWidth(1); property-&gt;SetDiffuse(0); property-&gt;SetAmbient(1); property-&gt;SetColor(0.18,0.28,0.23); 
	
	property = cube-&gt;GetXPlusFaceProperty();property-&gt;SetColor(0,0,1); property-&gt;SetInterpolationToFlat(); 
	property = cube-&gt;GetXMinusFaceProperty(); property-&gt;SetColor(0,0,1); property-&gt;SetInterpolationToFlat(); 
	property = cube-&gt;GetYPlusFaceProperty(); property-&gt;SetColor(0, 1, 0); property-&gt;SetInterpolationToFlat();
	property = cube-&gt;GetYMinusFaceProperty();property-&gt;SetColor(0,1,0); property-&gt;SetInterpolationToFlat(); 
	property = cube-&gt;GetZPlusFaceProperty();property-&gt;SetColor(1,0,0); property-&gt;SetInterpolationToFlat(); 
	property = cube-&gt;GetZMinusFaceProperty(); property-&gt;SetColor(1,0,0); property-&gt;SetInterpolationToFlat(); 

	vtkPropAssembly* assembly = vtkPropAssembly::New(); 
	axes = vtkAxesActor::New();
	axes-&gt;SetShaftTypeToCylinder();
	axes-&gt;SetXAxisLabelText(&quot;x&quot;); 
	axes-&gt;SetYAxisLabelText(&quot;y&quot;);	
	axes-&gt;SetZAxisLabelText(&quot;z&quot;);
	assembly-&gt;AddPart(axes); 
	assembly-&gt;AddPart(cube); 
	orientationWidget = vtkOrientationMarkerWidget::New();
	orientationWidget-&gt;SetOutlineColor( 0.9300, 0.5700, 0.1300 );
	orientationWidget-&gt;SetOrientationMarker(assembly);
	orientationWidget-&gt;SetInteractor(fl_vtk_window_1);
	orientationWidget-&gt;SetViewport( 0.0, 0.0, 0.4, 0.4 );		// where the axes should be displayed on screen 
	orientationWidget-&gt;SetEnabled( 1 );
	orientationWidget-&gt;InteractiveOff();
	orientationWidget-&gt;InteractiveOn();

	if (_IS_SPLIT_SCREEN == 1) { 
		// show a second marker widget on the split screen underneath vtk_window_1
		orientationWidget2 = vtkOrientationMarkerWidget::New();
		orientationWidget2-&gt;SetOutlineColor( 0.9300, 0.5700, 0.1300 );
		orientationWidget2-&gt;SetOrientationMarker(assembly);
		orientationWidget2-&gt;SetInteractor(fl_vtk_window_3);
		orientationWidget2-&gt;SetViewport( 0.0, 0.0, 0.4, 0.4 );		// where the axes should be displayed on screen 
		orientationWidget2-&gt;SetEnabled( 1 );
		orientationWidget2-&gt;InteractiveOn();
	}

}

void showOrthoPlanes()
{

	if (isOrthoPlaneViewedFirstTime == false)
	{
		renWin1-&gt;RemoveRenderer(renderer1);
		renderer1-&gt;Delete();
		renderer1 = vtkRenderer::New();
		//renderer1-&gt;SetBackground(0.46,0.58,0.41);		// light green color
		
	}

	// Z planes

	sliceZColors-&gt;SetInput(struct_points_data);
	sliceZColors-&gt;SetLookupTable(bwLut);
	zSlice-&gt;SetInput(sliceZColors-&gt;GetOutput());
	zSlice-&gt;SetDisplayExtent(0, maxX-1, 0, maxY-1, zPos, zPos);

	// X Plane
	sliceXColors-&gt;SetInput(struct_points_data);
	sliceXColors-&gt;SetLookupTable(bwLut);
	xSlice-&gt;SetInput(sliceXColors-&gt;GetOutput());
	xSlice-&gt;SetDisplayExtent(xPos, xPos, 0, maxY-1, 0, maxZ-1);

	// Y Plane
	sliceYColors-&gt;SetInput(struct_points_data);
	sliceYColors-&gt;SetLookupTable(bwLut);
	ySlice-&gt;SetInput(sliceYColors-&gt;GetOutput());
	ySlice-&gt;SetDisplayExtent(0, maxX-1, yPos, yPos, 0, maxZ-1);
	
	renderer1-&gt;AddActor(xSlice);
	renderer1-&gt;AddActor(ySlice);
	renderer1-&gt;AddActor(zSlice);

	imageActorArray[0] = zSlice;
	imageActorArray[1] = ySlice;
	imageActorArray[2] = xSlice;

	// add point picker for the slices
	vtkSphereSource *sphere = vtkSphereSource::New();
	sphere-&gt;SetThetaResolution(8);
	sphere-&gt;SetPhiResolution(8);
	sphere-&gt;SetRadius(0.5);
	sphereMapper = vtkPolyDataMapper::New();
	sphereMapper-&gt;ScalarVisibilityOff();
	sphereMapper-&gt;SetInput(sphere-&gt;GetOutput());
	vtkProperty *property = sphereActor-&gt;GetProperty();
	property-&gt;SetColor(0,1,0);
	sphereActor2-&gt;GetProperty()-&gt;SetColor(1,1,0); 
	sphereActor-&gt;SetMapper(sphereMapper);
	sphereActor2-&gt;SetMapper(sphereMapper); 
//	sphereActor-&gt;PickableOff();
	renderer1-&gt;AddActor(sphereActor);
	renderer1-&gt;AddActor(sphereActor2);			// MARCH 2009: this is the other sphere pointer for measuring distances 

	/*MARCH 2009: Comment this out to allow picking points on the x/y/z slice
	
	picker2-&gt;AddPickList(xSlice);
	picker2-&gt;AddPickList(ySlice);
	picker2-&gt;AddPickList(zSlice);
*/


	if (isOrthoPlaneViewedFirstTime == false)
	{
		renWin1-&gt;AddRenderer(renderer1);
		renWin1-&gt;Render();
		vtkCallbackCommand *callback = vtkCallbackCommand::New();
		callback-&gt;SetCallback(keyPressedFunction);
		callback-&gt;SetClientData((void *) imageActorArray);

		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);

	}
	else
	{

		fl_vtk_window_1-&gt;SetPicker(picker2);
		vtkCallbackCommand *callback = vtkCallbackCommand::New();
		callback-&gt;SetCallback(keyPressedFunction);
		callback-&gt;SetClientData((void *) imageActorArray);
		fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);
		
		//renderer1-&gt;SetBackground(0.22,0.23,0.32);			// the nice dark violet color
		//renderer1-&gt;SetBackground(0.83,0.93,0.96);			// colors that match the KCL presentation slide background (light blue)
		renderer1-&gt;SetBackground(1,1,1);
		renWin1-&gt;AddRenderer(renderer1);
		cout &lt;&lt; &quot;renderer added&quot; &lt;&lt; endl;
		fl_vtk_window_1-&gt;SetRenderWindow(renWin1);
		cout &lt;&lt; &quot;renderer window set&quot; &lt;&lt; endl;
//		fl_vtk_window_1-&gt;Initialize();
		cout &lt;&lt; &quot;window init&quot; &lt;&lt; endl;
		isOrthoPlaneViewedFirstTime == false;

		// set pickers for angle (Hafiz 2011)
		cell_picker = vtkCellPicker::New();
		cell_picker-&gt;SetTolerance(0.005); 
		fl_vtk_window_1-&gt;SetPicker(cell_picker); 

		sphereActor3 = vtkActor::New();
		sphere3 = vtkSphereSource::New();
		sphere3-&gt;SetThetaResolution(8);
		sphere3-&gt;SetPhiResolution(8);
		sphere3-&gt;SetRadius(0.1);
		sphereMapper3 = vtkPolyDataMapper::New();
		sphereMapper3-&gt;ScalarVisibilityOff();
		sphereMapper3-&gt;SetInput(sphere3-&gt;GetOutput());
		sphereActor3-&gt;GetProperty()-&gt;SetColor(1,1,1); 
		sphereActor3-&gt;SetMapper(sphereMapper3);

		sphereActor4 = vtkActor::New();
		sphere4 = vtkSphereSource::New();
		sphere4-&gt;SetThetaResolution(8);
		sphere4-&gt;SetPhiResolution(8);
		sphere4-&gt;SetRadius(0.1);
		sphereMapper4 = vtkPolyDataMapper::New();
		sphereMapper4-&gt;ScalarVisibilityOff();
		sphereMapper4-&gt;SetInput(sphere4-&gt;GetOutput());
		sphereActor4-&gt;GetProperty()-&gt;SetColor(0,0,1); 
		sphereActor4-&gt;SetMapper(sphereMapper3);

		sphereActor5 = vtkActor::New();
		sphere5 = vtkSphereSource::New();
		sphere5-&gt;SetThetaResolution(8);
		sphere5-&gt;SetPhiResolution(8);
		sphere5-&gt;SetRadius(0.1);
		sphereMapper5 = vtkPolyDataMapper::New();
		sphereMapper5-&gt;ScalarVisibilityOff();
		sphereMapper5-&gt;SetInput(sphere4-&gt;GetOutput());
		sphereActor5-&gt;GetProperty()-&gt;SetColor(1,0,1); 
		sphereActor5-&gt;SetMapper(sphereMapper5);
		
		renderer1-&gt;AddActor(sphereActor3); 
		renderer1-&gt;AddActor(sphereActor4); 

		
	}

	camera1-&gt;SetPosition(0,0,500);
    camera1-&gt;SetFocalPoint(0,0,0);
	renderer1-&gt;SetActiveCamera(camera1);
	addOrientationMarkerWidget();

	// turn on the XYZ slices (August 2011) 
	isXSliceOn = true; isYSliceOn = true; isZSliceOn = true; 

}


void syncWin2_cb(Fl_Widget* w, void*)
{
	 Fl_Check_Button *check = (Fl_Check_Button*)w;
	if (check-&gt;value() == 1)
		isAllowSync = true; 
	else
		isAllowSync = false;
}

void scarProjActorCheck_cb(Fl_Widget* w, void*)
{
	 Fl_Check_Button *check = (Fl_Check_Button*)w;
	if (check-&gt;value() == 1)
	{
		renderer1-&gt;RemoveActor(scarProjectionActor); 
		isScarProjectActorShowing = true; 
		fl_vtk_window_1-&gt;Render(); 
	}
	else
	{
		renderer1-&gt;AddActor(scarProjectionActor); 
		isScarProjectActorShowing = false; 
		fl_vtk_window_1-&gt;Render(); 
	}
}

void redraw_scar_cb(Fl_Widget*, void* v)
{
	char *newfile; 
	std::stringstream surfaceNormalBandFileName1SS, surfaceNormalBandFileName2SS, pixelsInMIPFileNameSS; 
	surfaceNormalBandFileName1SS &lt;&lt; dir_path &lt;&lt; &quot;/surface_normal_band.gipl&quot;; 
	surfaceNormalBandFileName2SS &lt;&lt; dir_path &lt;&lt; &quot;/surface_normal_band_bckup.gipl&quot;; 
	pixelsInMIPFileNameSS &lt;&lt; dir_path &lt;&lt; &quot;/pixels_in_MIP.gipl&quot;; 

	if (_CONSTRAINED_THRESHOLDING == 1)
	{
		if (isScarNormalExtentChanged == true) { 

			edtOfAtriumShell = input; 
			edtTransformer-&gt;SetInput(&amp;boundaryOfAtriumShell);
			edtTransformer-&gt;SetOutput(&amp;edtOfAtriumShell);
			cout &lt;&lt; &quot;Computing EDT ... &quot; &lt;&lt; endl;
			edtTransformer-&gt;Run();

			irtkRealPixel *edt_pixel = edtOfAtriumShell.GetPointerToVoxels(); 
			for (int i=0;i&lt;edtOfAtriumShell.GetNumberOfVoxels();i++)
			{
				if (*edt_pixel &lt;= scar_step_max)	
					*edt_pixel = 1; 
				else
					*edt_pixel = 0; 
				edt_pixel++;
			}

			edtOfAtriumShell.Write(surfaceNormalBandFileName1SS.str().c_str());
			edtOfAtriumShell.Write(surfaceNormalBandFileName2SS.str().c_str());
			
			sphereLocationMarker = show_surface_normals(fl_vtk_window_1, &amp;input, mcubes_threshold, heart, scalarBarForScar, &amp;mri_data, &amp;edtOfAtriumShell,_setUserWorkingMean, _setUserWorkingVar);
			
			tools-&gt;preparePixelsInMIP(&amp;pixelsInMIP, &amp;edtOfAtriumShell, &amp;boundaryOfAtriumShell);
			pixelsInMIP.Write(pixelsInMIPFileNameSS.str().c_str());
			isScarNormalExtentChanged = false;
			fl_vtk_window_1-&gt;Render();
		}
		else { 

		renderer1-&gt;RemoveActor(scalarBarForScar);
		surfaceNormalBand.Read(surfaceNormalBandFileName1SS.str().c_str()); 
		pixelsInMIP = blankImage;
		renderer1-&gt;RemoveActor(heart);
		scar_step_min=-10, scar_step_max=10;			
		show_surface_normals(fl_vtk_window_1, &amp;input, mcubes_threshold, heart, scalarBarForScar, &amp;mri_data, &amp;surfaceNormalBand,_setUserWorkingMean, _setUserWorkingVar);
		tools-&gt;preparePixelsInMIP(&amp;pixelsInMIP, &amp;surfaceNormalBand, &amp;boundaryOfAtriumShell);
		pixelsInMIP.Write(pixelsInMIPFileNameSS.str().c_str()); 
		fl_vtk_window_1-&gt;Render();
		}
	}
	else
	{
		threshold_scar(); render_scar();
	}
}


void open_MRI_scan_cb(Fl_Widget*, void* v)
{
	char *newfile;
	double intensity_value, max_intensity=-1; 

	if (!v)
		newfile = fl_file_chooser(&quot;Select MRI Scan&quot;, file_extensions, dir_path);
	else
		newfile = (char*)v; 
	if (newfile != NULL)
	{
		mri_data.Read(newfile);

		maxX = mri_data.GetX(); maxY = mri_data.GetY(); maxZ = mri_data.GetZ();
		
		
		scar_thresh = mri_data;
		class_labels = mri_data; 
		pixelsInMIP = mri_data;
		blankImage = mri_data;

		for (int i=0;i&lt;maxX;i++)
		{
			for (int j=0;j&lt;maxY;j++)
			{
				for (int k=0;k&lt;maxZ;k++)
				{
					intensity_value = mri_data.Get(i,j,k);
					if (max_intensity &lt; intensity_value)
						max_intensity = intensity_value;

					// and resetting pixelsInMIP	Aug 2011
					pixelsInMIP.Put(i,j,k,0);
					blankImage.Put(i,j,k,0);
				}
			}
		}
		_MAX_INTENSITY = max_intensity; 
		// this is a greyscale lookup table 
		//bwLut-&gt;SetRange(0, max_intensity); // image intensity range
		bwLut-&gt;SetRange(0, 500); // image intensity range
		bwLut-&gt;SetValueRange(0.0, 1.0); // from black to white
		bwLut-&gt;SetSaturationRange(0.0, 0.0); // no color saturation
		bwLut-&gt;SetRampToLinear();
		bwLut-&gt;Build();
		
		
		mri_data.ImageToVTK(struct_points_data);
		showOrthoPlanes();
		fl_vtk_window_1-&gt;Render();

		F_INDICATOR = 10+_MAX_INTENSITY; 
		B_INDICATOR = -_MAX_INTENSITY;

		
		if (_IS_SPLIT_SCREEN == 0) {
			cout &lt;&lt; &quot;now displaying MIP rendering .. &quot; &lt;&lt; endl;
			ensiteGraphics.MIP_LE_image(fl_vtk_window_3, &amp;mri_data, _MAX_INTENSITY);
		}


		// now set the image folder path if it wasn't set 
		// Sept 2011 - James request 
		if (!isImageFolderSet)
		{
			stringstream ss; 
			ss &lt;&lt; newfile; 
			string imagePath; 
			imagePath = tools-&gt;ExtractDirectory(ss.str()); 
			dir_path = new char[imagePath.length()+1]; 
			strcpy(dir_path, imagePath.c_str());
			cout &lt;&lt; &quot;\nThe image path is now set to &quot; &lt;&lt; dir_path &lt;&lt; endl;
			isImageFolderSet = true; 
		}

	}
	
	//free(newfile); 

}

void threshold_scar()
{
	for (int i=0;i&lt;mri_data.GetX();i++) {
		for (int j=0;j&lt;mri_data.GetY();j++) { 
			for (int k=0;k&lt;mri_data.GetZ();k++) {
				if (mri_data.Get(i,j,k) &gt; low_threshold &amp;&amp; mri_data.Get(i,j,k) &lt; high_threshold){
					
					if (high_distance_threshold == -1 &amp;&amp; low_distance_threshold == -1) 
					{
						high_distance_threshold = 1E10; low_distance_threshold=-1;
					}

					if (distance_image.Get(i,j,k)&lt;high_distance_threshold &amp;&amp; distance_image.Get(i,j,k)&gt;low_distance_threshold)
					{
						scar_thresh.Put(i,j,k, 255); 
					}
					else
						scar_thresh.Put(i,j,k, 0);		// scar is outside the atrial body distance threshold
				}
				else
					scar_thresh.Put(i,j,k, 0);
			}
		}
	}
	//scar_thresh.Write(&quot;scar_thresh.nii&quot;); 
}

void render_scar()
{
	// convert irtk image to a structured point set of unsigned scalars
	vtkSmartPointer&lt;vtkStructuredPoints&gt;  vtkImage = vtkSmartPointer&lt;vtkStructuredPoints&gt;::New();
	vtkSmartPointer&lt;vtkImageCast&gt; imageCast = vtkSmartPointer&lt;vtkImageCast&gt;::New();
	scar_thresh.ImageToVTK(vtkImage);
	imageCast-&gt;SetInput(vtkImage);
	imageCast-&gt;SetOutputScalarTypeToUnsignedShort();
	//vtkSmartPointer&lt;vtkRenderer&gt; renderer;
	//vtkSmartPointer&lt;vtkRenderWindow&gt; renderWin;
	vtkSmartPointer&lt;vtkLookupTable&gt; lut;

	vtkSmartPointer&lt;vtkDiscreteMarchingCubes&gt; discrete = vtkSmartPointer&lt;vtkDiscreteMarchingCubes&gt;::New();
	discrete-&gt;SetInput(imageCast-&gt;GetOutput());
	discrete-&gt;GenerateValues(255, 1, 255);
	vtkSmartPointer&lt;vtkPolyDataMapper&gt; surfaceMapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();

	vtkSmartPointer&lt;vtkDecimatePro&gt; deci = vtkSmartPointer&lt;vtkDecimatePro&gt;::New(); 
	deci-&gt;SetInputConnection(discrete-&gt;GetOutputPort()); 
	deci-&gt;SetTargetReduction(0.9); 
	deci-&gt;PreserveTopologyOn(); 
	vtkSmartPointer&lt;vtkSmoothPolyDataFilter&gt; smoother = vtkSmartPointer&lt;vtkSmoothPolyDataFilter&gt;::New(); 
	smoother-&gt;SetInputConnection(deci-&gt;GetOutputPort()); 
	smoother-&gt;SetNumberOfIterations(num_smoothing_iterations); 
	vtkSmartPointer&lt;vtkPolyDataNormals&gt; normals = vtkSmartPointer&lt;vtkPolyDataNormals&gt;::New();
	normals-&gt;SetInputConnection(smoother-&gt;GetOutputPort()); 
	normals-&gt;FlipNormalsOn(); 
	surfaceMapper-&gt;SetInput(normals-&gt;GetOutput());

	lut = vtkSmartPointer&lt;vtkLookupTable&gt;::New();
	
	lut-&gt;SetNumberOfColors(256);
	lut-&gt;SetTableRange(0,1);
	lut-&gt;SetHueRange (0.6667, 0.0);
	lut-&gt;SetSaturationRange (1.0, 1.0);
	lut-&gt;SetValueRange (1.0, 1.0);
	lut-&gt;Build();
	
	surfaceMapper-&gt;SetLookupTable(lut);
	surfaceMapper-&gt;ScalarVisibilityOn();
	surfaceMapper-&gt;SetScalarRange(lut-&gt;GetTableRange());
	

	if (scarDisplayed)
	{
		renderer1-&gt;RemoveActor(scar_actor); 
	}
	
	scar_actor-&gt;SetMapper(surfaceMapper);
	renderer1-&gt;AddActor(scar_actor);

	// fancy shading 
	scar_actor-&gt;GetProperty()-&gt;SetAmbient(0.2); 
	scar_actor-&gt;GetProperty()-&gt;SetDiffuse(0.5); 
	scar_actor-&gt;GetProperty()-&gt;SetSpecular(1.0); 
	scar_actor-&gt;GetProperty()-&gt;SetSpecularPower(30.0); 
	scar_actor-&gt;GetProperty()-&gt;SetInterpolationToPhong();

	scarDisplayed = !scarDisplayed; 
	
	cout &lt;&lt; &quot;Rendering ...&quot;;
	renWin1-&gt;Render();
	cout &lt;&lt; &quot;finished rendering!&quot;;

}

void MIP_on_surface_assist() 
{
	Fl_Widget* w = NULL;

	LA_surface_poly = vtkSmartPointer&lt;vtkPolyData&gt;::New();
	
	if (_surf_input != &quot;&quot;)
	{
		vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New(); 
		reader-&gt;SetFileName(_surf_input); 
		reader-&gt;Update(); 
		LA_surface_poly = reader-&gt;GetOutput();
	
	}
	
	open_MRI_scan_cb(w, _input_f2); 
	open_segmented_cb(w,_input_f1);
	export_other_shells_cb(w, _output); 
	
	// 2013 integrating ablation points on shell 
	

	isShellOn = true; 

}

void graphcut_segmentation_assist(int option_i)
{
	int usr_inp; 
	char *aw_fn, *sp_fn, *bp_fn, *seg_fn, *le_fn; 
	
	if (option_i == 1) { 
		
		// no pre-computation - requesting for pre-computation (Less reliable may crash) 
		if (graphCutIsFirstTime) {
			
			//computeClassIntensityDistributionParams(&amp;mri_data, &amp;class_labels, F_INDICATOR, B_INDICATOR, f_mean, f_var, b_mean, b_var);
			//cout &lt;&lt; &quot;f_mean = &quot; &lt;&lt; f_mean &lt;&lt; &quot;, f_var = &quot; &lt;&lt; f_var &lt;&lt; &quot;\n b_mean = &quot; &lt;&lt; b_mean &lt;&lt; &quot;b_var = &quot;&lt;&lt; b_var &lt;&lt; endl;
			classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
			classifier.NotifyLibRunningBatchMode(false);
			classifier.SetInput(&amp;mri_data, &amp;input); 
			classifier.getAtrialWall();
			classifier.getInnerBloodPool();
			classifier.constructSpatialPriorImage();
			
		

			//f_var = 150*150;	// set var to 8 to ocmply with other authors have reported about scar
	/*f_var = 100*100; 
	f_mean = 2000;*/
		//classifier.SetMeanVar(f_mean, f_var, b_mean, b_var);		// the b_mean and b_var not really used as background is modeled using Gaussian mixtures - EM algorithm 
			graphCutIsFirstTime = false;
		}
	}
	else if (option_i == 2)
	{
		// pre-computation of atrial wall, spatial prior and blood pool available 
		le_fn = fl_file_chooser(&quot;Select late enhancement ..?&quot;, file_extensions, dir_path);
		if (le_fn != NULL) 
		{
			mri_data.Read(le_fn);
			seg_fn = fl_file_chooser(&quot;Select LA segmentation ..?&quot;, file_extensions, dir_path);
			if (seg_fn != NULL) 
			{
				input.Read(seg_fn); 
				classifier.SetInput(&amp;mri_data, &amp;input); 
			
				aw_fn = fl_file_chooser(&quot;Select atrial wall image ..?&quot;, file_extensions, dir_path);
				if (aw_fn != NULL) {
					classifier.SetAtrialWall(aw_fn); 
					sp_fn = fl_file_chooser(&quot;Select spatial prior image ..?&quot;, file_extensions, dir_path);
					if (sp_fn != NULL) {
						classifier.SetSpatialPrior(sp_fn);
						bp_fn = fl_file_chooser(&quot;Select blood pool image ..?&quot;, file_extensions, dir_path);
						if (bp_fn != NULL) {
							classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
							classifier.NotifyLibRunningBatchMode(false);
							classifier.SetInnerBloodPool(bp_fn);
							if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
							classifier.computeStatsForABBloodPool();
						}
					}
				}
			}
		}
	}
	else if (option_i == 3)
	{ 
		cout &lt;&lt; &quot;You are using\n1) GIPL, or \n2) NIFTI\n formats?&quot; &lt;&lt; endl; 
		cin &gt;&gt; usr_inp; 
		if (usr_inp == 1) { 
			mri_data.Read(&quot;_le.gipl&quot;); input.Read(&quot;_gad_seg.gipl&quot;); classifier.SetInput(&amp;mri_data, &amp;input);
			 classifier.SetAtrialWall(&quot;_atrial_wall.gipl&quot;); classifier.SetSpatialPrior(&quot;_spatial_prior.gipl&quot;); classifier.SetInnerBloodPool(&quot;_blood_pool.gipl&quot;); 
			classifier.SetDilatedSeg(&quot;_dilated_seg.gipl&quot;); 
			classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
			if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
			 classifier.NotifyLibRunningBatchMode(true);		// post feb 2011
			 cout &lt;&lt; &quot;NOTE: running in auto mode, i.e. you cannot select a ROI&quot; &lt;&lt; endl; 
		}
		else{	
			mri_data.Read(&quot;_le.nii&quot;); input.Read(&quot;_gad_seg.nii&quot;); classifier.SetInput(&amp;mri_data, &amp;input); 
			classifier.SetAtrialWall(&quot;_atrial_wall.nii&quot;); classifier.SetSpatialPrior(&quot;_spatial_prior.nii&quot;); classifier.SetInnerBloodPool(&quot;_blood_pool.nii&quot;); 
			classifier.SetDilatedSeg(&quot;_dilated_seg.nii&quot;); 
			classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
			if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
			classifier.NotifyLibRunningBatchMode(true);			// post feb 2011
			cout &lt;&lt; &quot;NOTE: running in auto mode, i.e. you cannot select a ROI&quot; &lt;&lt; endl; 
		}
		

		classifier.computeStatsForABBloodPool();
	}
	else if (option_i == 4)
	{ 
		// auto batch-run mode 
		cout &lt;&lt; &quot;Running in automatic mode ... &quot; &lt;&lt; endl;
		mri_data.Read(&quot;_le.gipl&quot;); input.Read(&quot;_gad_seg.gipl&quot;); classifier.SetInput(&amp;mri_data, &amp;input);
		classifier.SetAtrialWall(&quot;_atrial_wall.gipl&quot;); classifier.SetSpatialPrior(&quot;_spatial_prior.gipl&quot;); classifier.SetInnerBloodPool(&quot;_blood_pool.gipl&quot;); 
		classifier.SetDilatedSeg(&quot;_dilated_seg.gipl&quot;); 
		classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
		classifier.NotifyLibRunningBatchMode(true);			// post feb 2011
		if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
		classifier.computeStatsForABBloodPool();
	}
	else if (option_i == 5)			// NEW OPTION:  iterative graph cuts  added 25 May 
	{
		// iterative graph cuts 
		ofstream out_log; 
		out_log.open(&quot;model_update_logs.txt&quot;);			// we will log the model updates in this file 
		cout &lt;&lt; &quot;You are using\n1) GIPL, or \n2) NIFTI\n formats?&quot; &lt;&lt; endl; 
		//cin &gt;&gt; usr_inp; 
		usr_inp = 1; 
		stringstream ss; 
		stringstream ss_past; 
		string out_f; 
		if (usr_inp == 1) { 
			mri_data.Read(&quot;_le.gipl&quot;); input.Read(&quot;_gad_seg.gipl&quot;); classifier.SetInput(&amp;mri_data, &amp;input);
			 classifier.SetAtrialWall(&quot;_atrial_wall.gipl&quot;); classifier.SetSpatialPrior(&quot;_spatial_prior.gipl&quot;); classifier.SetInnerBloodPool(&quot;_blood_pool.gipl&quot;); 
			classifier.SetDilatedSeg(&quot;_dilated_seg.gipl&quot;); 
			classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
			 classifier.NotifyLibRunningBatchMode(true);		// post feb 2011
			 if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
			 cout &lt;&lt; &quot;NOTE: running in auto mode, i.e. you cannot select a ROI&quot; &lt;&lt; endl; 
		}
		else{	
			mri_data.Read(&quot;_le.nii&quot;); input.Read(&quot;_gad_seg.nii&quot;); classifier.SetInput(&amp;mri_data, &amp;input); 
			classifier.SetAtrialWall(&quot;_atrial_wall.nii&quot;); classifier.SetSpatialPrior(&quot;_spatial_prior.nii&quot;); classifier.SetInnerBloodPool(&quot;_blood_pool.nii&quot;); 
			classifier.SetDilatedSeg(&quot;_dilated_seg.nii&quot;); 
			classifier.SetScarTissueTrainedModel(_scar_model_mean, _scar_model_stdev); 
			classifier.NotifyLibRunningBatchMode(true);			// post feb 2011
			if (useAtlasMode == 1) classifier.SetUseSpatialAtlas(); 
			cout &lt;&lt; &quot;NOTE: running in auto mode, i.e. you cannot select a ROI&quot; &lt;&lt; endl; 
		}
		int iterations = 0;
		
		
		classifier.computeStatsForABBloodPool();
		classifier.computeEMClassification(); 
		
		bool isConverged = false; 
		while (iterations &lt; _scar_auto_seg_iterations &amp;&amp; !isConverged) 
		{
			classifier.constructGraph(boxWidget); 
			classifier.computeCut(); 
			classifier.recomputeScarVarianceModel(out_log); 
			classifier.cleanForNextIteration(); 
			iterations++;
			
			if (usr_inp == 1) { 
				ss &lt;&lt; &quot;_gc_seg_out_&quot; &lt;&lt; iterations &lt;&lt; &quot;.gipl&quot;; 		
				if (iterations &gt; 1)
					ss_past &lt;&lt; &quot;_gc_seg_out_&quot; &lt;&lt; iterations-1 &lt;&lt; &quot;.gipl&quot;; 
			} 
			else { 
				ss &lt;&lt; &quot;_gc_seg_out_&quot; &lt;&lt; iterations &lt;&lt; &quot;.nii&quot;; 
				
				if (iterations &gt; 1)
					ss_past &lt;&lt; &quot;_gc_seg_out_&quot; &lt;&lt; iterations-1 &lt;&lt; &quot;.nii&quot;;
			} 
			

			
			if (iterations &gt; 1) 
				isConverged = classifier.CheckConvergence(ss_past.str().c_str(), _TOL);
			
			if (isConverged)
				classifier.g_label.Write(&quot;_gc_seg_out_final.gipl&quot;); 
			else
				classifier.g_label.Write(ss.str().c_str()); 
			

			ss.str(&quot;&quot;); 
			ss_past.str(&quot;&quot;);
			//classifier.g_label.Read(ss.str().c_str());
		}
		
		out_log.close();			
		return; 
	}

	classifier.computeEMClassification(); 
	classifier.constructGraph(boxWidget); 
	classifier.computeCut(); 
	//label_range[0] = 2; label_range[1] = 2; 
	//show_labelled_image(fl_vtk_window_1, &amp;classifier.g_label, 2, label_range, 300, true, 1, 1, true);
	if (usr_inp == 1) classifier.g_label.Write(&quot;_gc_seg_out.gipl&quot;);
	else classifier.g_label.Write(&quot;_gc_seg_out.nii&quot;);

	if (option_i == 4)
	{
		classifier.g_label.Write(&quot;_gc_seg_out.gipl&quot;);
	}
	else { 
		/*
		classifier.displayScar(fl_vtk_window_1, scar_actor);

		
		//classifier.debugScarPrintIntensityToFile(&quot;wall_intensity.txt&quot;, &quot;noscar_intensity.txt&quot;);
		classifier.displayScar_UsingMaximumIntensityProjection(fl_vtk_window_1, polys_2, scarProjectionActor);

		classifier.debugErodeIntensityToFile(&quot;blood_pool_intensities.txt&quot;);
		
		// write polydata output to disc 
		vtkSmartPointer&lt;vtkPolyDataWriter&gt; vtkwriter = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New(); 
		vtkwriter-&gt;SetInput(polys_2); 
		vtkwriter-&gt;SetFileName(&quot;_gc_seg_out_graphcuts.vtk&quot;); 
		vtkwriter-&gt;SetFileTypeToASCII(); 
		vtkwriter-&gt;Write(); */

	}	
}

void compute_graphcut_segmentation_cb(Fl_Widget* w, void* option)
{
	int option_i, usr_inp; 
	char *aw_fn, *sp_fn, *bp_fn, *seg_fn, *le_fn; 
	option_i = (int)option; 
	graphcut_segmentation_assist(option_i); 
}

void open_at_body_cb(Fl_Widget* w, void* vptr) {
	int pixel_value;
	at_body_file_name = fl_file_chooser(&quot;Open File?&quot;, file_extensions, dir_path);

	if (at_body_file_name != NULL)
	{
		at_body_segmented.Read(at_body_file_name); 
		// binarize atrial_body with inside atrial body = 0 and outside = 1
		
		// this will find the distance from atrial body 
		for (int i=0;i&lt;at_body_segmented.GetX(); i++)
		{
			for (int j=0;j&lt;at_body_segmented.GetY(); j++)
			{
				for (int k=0;k&lt;at_body_segmented.GetZ(); k++)
				{
					pixel_value = at_body_segmented.Get(i,j,k);
					if (pixel_value &gt; 0)
					{
						pixel_value = 1;
					}
					else
						pixel_value = 0;
				}
			}
		}

		irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt; *edt_transform_function = 
			new irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;(irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;::irtkDistanceTransform3D);

		
		edt_transform_function-&gt;SetInput(&amp;at_body_segmented);
		edt_transform_function-&gt;SetOutput(&amp;distance_image);
		edt_transform_function-&gt;Run();
		distance_image.Write(&quot;distance_image.nii&quot;); 
	}
}

void open_segmented_cb(Fl_Widget* w, void* vptr) {

	double intensity_value, max_intensity; 
	double mean, var;
	int u1;
	//char* u2, *u3; 
	bool isSuccess=false, isImage=false; 
	std::stringstream fname; 
	std::string fnameS;
	std::stringstream surfaceNormalBandFileName1SS, surfaceNormalBandFileName2SS, pixelsInMIPFileNameSS; 
	surfaceNormalBandFileName1SS &lt;&lt; dir_path &lt;&lt; &quot;/surface_normal_band.gipl&quot;; 
	surfaceNormalBandFileName2SS &lt;&lt; dir_path &lt;&lt; &quot;/surface_normal_band_bckup.gipl&quot;; 
	pixelsInMIPFileNameSS &lt;&lt; dir_path &lt;&lt; &quot;/pixels_in_MIP.gipl&quot;; 
	
	// initialize LA_surface_poly
	LA_surface_poly = vtkSmartPointer&lt;vtkPolyData&gt;::New();

	tools = new Scar3DTools();

	if (!vptr)
		segmented_image_file_name = fl_file_chooser(&quot;Open File?&quot;, &quot;*.gipl\t*.vtk&quot;, dir_path);
	else
		segmented_image_file_name = (char*)vptr; 
	
	if (segmented_image_file_name != NULL)
	{
		 fname &lt;&lt; segmented_image_file_name; 
		 fname &gt;&gt; fnameS;  

		 if (fnameS.substr(fnameS.find_last_of(&quot;.&quot;) + 1) == &quot;vtk&quot;) {
			 isImage = false; 
			 vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New(); 
			 reader-&gt;SetFileName(segmented_image_file_name); 
			 reader-&gt;Update(); 
			 LA_surface_poly = reader-&gt;GetOutput();
			 _surf_input = segmented_image_file_name;
		 }
		 else if (fnameS.substr(fnameS.find_last_of(&quot;.&quot;) + 1) == &quot;gipl&quot;) {
			input.Read(segmented_image_file_name);
			isImage = true;
		 }
		
		
	//_debugOutput.open(&quot;cell_scalars_debug.txt&quot;);
		// OCTOBER 2009: i switched this off to test graph-cuts

		if (_NORMAL_MYOCARDIUM_USER_INPUT == 1 &amp;&amp; !benAutoMode)
		{ 
			cout &lt;&lt; &quot;\nDo you want to input the normal myocardium mean and variance manually (1) or using ROI (2)?&quot;;
			cin &gt;&gt; u1; 
			if (u1 == 1)
			{
				cout &lt;&lt; &quot;\nEnter mean = &quot;; 
				cin &gt;&gt; mean; 
				 
				cout &lt;&lt; &quot;\nEnter std. dev = &quot;; 
				cin &gt;&gt; var; 
				 
				var=var*var; 
				isSuccess = true; 
			}
			else if (u1 == 2)
			{
				if (isNormalMyocardiumComputed) 
				{
					mean = myo_mean; 
					var = myo_stdev*myo_stdev;
					isSuccess = true; 
				}
				else
				{
					cout &lt;&lt; &quot;Error: Not computed normal myocardium ROI yet, Press X select ROI and then Tools-&gt;Compute normal myocardium&quot; &lt;&lt; endl;
				}
			}
			
		}
		else if (_NORMAL_MYOCARDIUM_USER_INPUT == 1 &amp;&amp; benAutoMode)
		{
			mean = _scar_model_mean; 
			var = _scar_model_stdev; 
			var = var*var; 
			isSuccess = true; 
		}
		else  
		{
			// WILL BE USING AUTO-COMPUTED BLOOD POOL INTENSITY AS APPROXIMATION FOR NORMAL MYOCARDIUM
			char* filename = fl_file_chooser(&quot;Select atrial blood pool or mask&quot;, file_extensions, dir_path);
			if (filename != NULL)
			{
				blood_pool.Read(filename); 
				getMeanIntensityWithinROI(mri_data, &amp;blood_pool, (_OUTPUT_BLOOD_POOL_INTENSITIES == 1), mean, var); 
				cout &lt;&lt; &quot;Mean and variance of blood pool intensity, mean = &quot; &lt;&lt; mean &lt;&lt; &quot;: var = &quot; &lt;&lt; var &lt;&lt; endl;
				isSuccess = true; 
			}
			//free(filename); 

		}
	
		if (isSuccess) {
			
			// convert shell to EDT to show band - august 2011
			

			/*if (isImage) { 
				cout &lt;&lt; &quot;setting image1 ...&quot; &lt;&lt; endl;
				edtOfAtriumShell = input; 
				cout &lt;&lt; &quot;setting image2 ...&quot; &lt;&lt; endl;
				boundaryOfAtriumShell = input; 
			}*/
			/*
			cout &lt;&lt; &quot;Getting inside GetPointsOnBoundary()&quot; &lt;&lt; endl;
			tools-&gt;GetPointsOnBoundary(&amp;input, &amp;boundaryOfAtriumShell); 
			cout &lt;&lt; &quot;GetPointsOnBoundary() success&quot; &lt;&lt; endl;
			edtTransformer-&gt;SetInput(&amp;boundaryOfAtriumShell);
			edtTransformer-&gt;SetOutput(&amp;edtOfAtriumShell);
			cout &lt;&lt; &quot;Computing EDT ... &quot; &lt;&lt; endl;
			edtTransformer-&gt;Run();

			irtkRealPixel *edt_pixel = edtOfAtriumShell.GetPointerToVoxels(); 
			for (int i=0;i&lt;edtOfAtriumShell.GetNumberOfVoxels();i++)
			{
				if (*edt_pixel &lt;= scar_step_max)	
					*edt_pixel = 1; 
				else
					*edt_pixel = 0; 
				edt_pixel++;
			}

			edtOfAtriumShell.Write(surfaceNormalBandFileName1SS.str().c_str());
			edtOfAtriumShell.Write(surfaceNormalBandFileName2SS.str().c_str());
			*/
			sphereLocationMarker = show_surface_normals(fl_vtk_window_1, &amp;input, mcubes_threshold, heart, scalarBarForScar, &amp;mri_data, &amp;edtOfAtriumShell,  mean, var);
			_setUserWorkingMean = mean; 
			_setUserWorkingVar = var; 

			if (isImage) { 
				//tools-&gt;preparePixelsInMIP(&amp;pixelsInMIP, &amp;edtOfAtriumShell, &amp;boundaryOfAtriumShell);
				//pixelsInMIP.Write(pixelsInMIPFileNameSS.str().c_str());
			}
		//_debugOutput.close();

			// IF YOU DONT WANT LAPLACIAN SMOOTHING THEN TURN THIS ON 
			//sphereLocationMarker = show_segmented_image_without_smoothing(fl_vtk_window_2, &amp;input, mcubes_threshold, heart, heart_copy);
			isSegmentedImageDisplayed = true;
			
			fl_vtk_window_1-&gt;Render();
			//superimpose_cb(w, vptr);

			/* MARCH 2009: This will allow you to pick points on the surface */ 
			//picker2-&gt;InitializePickList();
			picker2-&gt;AddPickList(heart_copy);

			if (_IS_SPLIT_SCREEN == 1)
			{
				int max_intensity; 
				masked_le = input; 
				ensiteGraphics.MaskLEImage(&amp;mri_data, &amp;input, &amp;masked_le, max_intensity, true); 
				ensiteGraphics.MIP_LE_image(fl_vtk_window_3, &amp;masked_le, max_intensity, true) ;
			}

		
		}

	}

	
}

void setUpBoxWidget()
{
	boxWidget-&gt;SetProp3D(ySlice);	// appears on z slice, but can be moved using interactor other slices
	boxWidget-&gt;SetPlaceFactor(40.0);
	boxWidget-&gt;PlaceWidget();

	boxWidget2-&gt;SetProp3D(ySlice);	// appears on z slice, but can be moved using interactor other slices
	boxWidget2-&gt;SetPlaceFactor(40.0);
	boxWidget2-&gt;PlaceWidget();

	voltageScarBoxWidget-&gt;SetProp3D(zSlice);
	voltageScarBoxWidget-&gt;SetPlaceFactor(40.0);
	voltageScarBoxWidget-&gt;PlaceWidget();
}


void generate_movie(char* filename,	vtkRenderWindow  *&amp;renWin)
{
	cout &lt;&lt; &quot;subroutine started .. &quot;;
	vtkRenderer* renderer;
	vtkRendererCollection* renderers;
	vtkWindowToImageFilter *imageFilter = vtkWindowToImageFilter::New();
	imageFilter-&gt;SetInput(renWin);
	cout &lt;&lt; &quot;image filter activated .. &quot;;
	vtkAVIWriter *aviWriter = vtkAVIWriter::New();
	aviWriter-&gt;SetInputConnection(imageFilter-&gt;GetOutputPort());
	cout &lt;&lt; &quot;AVI writer activated .. &quot;;
	aviWriter-&gt;SetFileName(filename);
	cout &lt;&lt; &quot;movie generationg started .. &quot;;
	aviWriter-&gt;Start();

	renderers = renWin-&gt;GetRenderers();
	cout &lt;&lt; renderers-&gt;GetNumberOfItems() &lt;&lt; &quot; of items in collection &quot; &lt;&lt; endl;

	renderers-&gt;InitTraversal(); renderer=renderers-&gt;GetNextItem();

	for (int i = 0; i &lt; 180; ++i)    {
		renderer-&gt;GetActiveCamera()-&gt;Azimuth(2);
		renderer-&gt;GetActiveCamera()-&gt;Elevation(-10);
		renderer-&gt;GetActiveCamera()-&gt;Elevation(10);
		renWin-&gt;Render();
		imageFilter-&gt;Modified();
		aviWriter-&gt;Write();
	}
	cout &lt;&lt; &quot;Movie generated!&quot; &lt;&lt; endl;

	aviWriter-&gt;End();
	aviWriter-&gt;Delete();
	// cant delete these - wont be able to interact with the actor if you delete these
	//renderers-&gt;Delete();
	//renderer-&gt;Delete();
}

void generate_movie_cb(Fl_Widget*, void* user_data)
{
	int i;
	char* filename;
	i = (int)(user_data);
	cout &lt;&lt; i;
	filename = fl_file_chooser(&quot;Save Movie&quot;, &quot;*.avi&quot;, dir_path);

	if (filename != NULL) {
		cout &lt;&lt; &quot;user selected: &quot; &lt;&lt; i;
		switch (i)
		{
			case 1:
				generate_movie(filename, renWin1);
			break;
			
			case 2:
				cout &lt;&lt; &quot;calling movie generating subroutine .. &quot;;
				generate_movie(filename, renWin2);
			break;

			case 3:
				generate_movie(filename, renWin3);
			break;

		}
	}


}

void scarVoltageCellHistogram_cb(Fl_Widget*, void* user_data)
{
	char* filename;
	filename = fl_file_chooser(&quot;scarVoltageCellHistogram.txt&quot;, &quot;*.txt&quot;, dir_path);
	if (filename != NULL) {
		ensiteGraphics.GetHistogramOfCellsInMesh(polys, polys_4, filename);
	}
	//ensiteGraphics.ExportMeshParaviewReadableFormat(polys, &quot;scarParaview.vtp&quot;); 
	//ensiteGraphics.ExportMeshParaviewReadableFormat(polys_4, &quot;voltageParaview.vtp&quot;); 
}



void scarOrVoltageInsideBox_cb(Fl_Widget*, void*) 
{
	char* filename; 
	vector&lt;irtkPoint*&gt; lowerPlane, upperPlane, upperPlane_V, lowerPlane_V; 
	vector&lt;int&gt; lowerPlaneIDs, upperPlaneIDs, lowerPlaneIDs_V, upperPlaneIDs_V, combinedPlaneIDs; 
	int user_input, user_input_2; 
	filename = fl_file_chooser(&quot;scarOrVoltage_at_ll_pv.txt&quot;, &quot;*.txt&quot;, dir_path);

	if (filename!=NULL &amp;&amp; voltageScarBoxWidgetIsOn) {
	
		ensiteGraphics.getAtrialGeometryPointsWithinBox(polys, voltageScarBoxWidget, upperPlane, lowerPlane, upperPlaneIDs, lowerPlaneIDs, halfPlaneActor, false);	// scar
		
		if (_SIMPLE_INTERPOLATION_OF_VOLTAGE_ENABLED == 1)	// i.e. if voltage is defined at cells rather than cell vertices (points on polydata) 
			ensiteGraphics.getAtrialGeometryPointsWithinBox(polys, voltageScarBoxWidget, upperPlane_V, lowerPlane_V, upperPlaneIDs_V, lowerPlaneIDs_V, halfPlaneActor, false);  // voltage
		else
			ensiteGraphics.getAtrialGeometryPointsWithinBox(polys_5, voltageScarBoxWidget, upperPlane_V, lowerPlane_V, upperPlaneIDs_V, lowerPlaneIDs_V, halfPlaneActor, true);	// polys_5 is the clipped poly


		for (int i=0;i&lt;lowerPlaneIDs.size();i++)
			combinedPlaneIDs.push_back(lowerPlaneIDs[i]); 
		
		for (int i=0;i&lt;upperPlaneIDs.size();i++)
			combinedPlaneIDs.push_back(upperPlaneIDs[i]); 
		
		cout &lt;&lt; &quot;\n\nWould you like voltage or scar data (0=voltage, 1=scar) ?\n&quot; &lt;&lt; endl;
		cin &gt;&gt; user_input;
		cout &lt;&lt; &quot;\nAre you getting to these values for correlating voltage and scar, in which case I will also include points with no voltage defined and mark them with an X (1=yes, 0=no)?\n&quot;; 
		cin &gt;&gt; user_input_2; 

		if (user_input == 0){
			// requesting voltage, now 
			
			if (_SIMPLE_INTERPOLATION_OF_VOLTAGE_ENABLED == 1) {
				if (user_input_2 == 1)
					ensiteGraphics.MeanScalarWithinROIInPoly(polys_4, combinedPlaneIDs, 0, 1e40, false, true, filename);	// include voltage locations where undefined
				else
					ensiteGraphics.MeanScalarWithinROIInPoly(polys_4, combinedPlaneIDs, 0, 100, false, true, filename);	// exclude cells where voltage is not defined
			}
			else {
				if (user_input_2 == 1)
					ensiteGraphics.MeanScalarWithinROIInPoly(polys_5, combinedPlaneIDs, 0, 1e40, true, true, filename); 
				else 
					ensiteGraphics.MeanScalarWithinROIInPoly(polys_5, combinedPlaneIDs, 0, 100, true, true, filename); 
			}
		}
		else {
			// requesting scar
			cout &lt;&lt; &quot;\nScar data is only available at cells and not points\n&quot;;
			if (user_input_2 == 1)
				ensiteGraphics.MeanScalarWithinROIInPoly(polys, combinedPlaneIDs, -1, 1e40, false, true, filename); // also include 0 scar for correlating voltage and scar
			else
				ensiteGraphics.MeanScalarWithinROIInPoly(polys, combinedPlaneIDs, 0, 1e40, false, true, filename); 
		}

		cout &lt;&lt; &quot;Output written to file &quot; &lt;&lt; filename &lt;&lt; endl;
	}
	else 
	{
		if (!voltageScarBoxWidgetIsOn)
			cout &lt;&lt; &quot;\n\nERROR: Please select a ROI using the r on keyboard to bring up bounding box\n\n&quot; &lt;&lt; endl;
	}
}

// Note that this function uses poly_5 
// poly_5 is the interpolated voltage obtained after re-drawing voltage (by setting sliders manually once voltage has been imported and 
// displayed initially 
void scarVoltageInsideBox_cb(Fl_Widget*, void* user_data)
{

	vector&lt;irtkPoint*&gt; lowerPlane, upperPlane, upperPlane_V, lowerPlane_V; 
	vector&lt;int&gt; lowerPlaneIDs, upperPlaneIDs, lowerPlaneIDs_V, upperPlaneIDs_V; 
	
	if (voltageScarBoxWidgetIsOn) {

		ensiteGraphics.getAtrialGeometryPointsWithinBox(polys, voltageScarBoxWidget, upperPlane, lowerPlane, upperPlaneIDs, lowerPlaneIDs, halfPlaneActor, false); 
		ensiteGraphics.getAtrialGeometryPointsWithinBox(polys_5, voltageScarBoxWidget, upperPlane_V, lowerPlane_V, upperPlaneIDs_V, lowerPlaneIDs_V, halfPlaneActor, true); 

		//renderer1-&gt;AddActor(halfPlaneActor); 
		double* p = new double[3];

		for (int i=0;i&lt;lowerPlane.size();i++)
		{
			p[0] = lowerPlane[i]-&gt;_x; p[1] = lowerPlane[i]-&gt;_y; p[2] = lowerPlane[i]-&gt;_z; 
			//cout &lt;&lt; &quot;(&quot; &lt;&lt; p[0] &lt;&lt; &quot;,&quot; &lt;&lt; p[1] &lt;&lt; &quot;,&quot; &lt;&lt; p[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
			ensite.drawPoint(p, fl_vtk_window_1, 1,0,0); 
			// average scar	
		}

		double scar_sum_lower=0, cell_num=0, scar_mean_lower, scar_sum_upper=0, scar_mean_upper;		// scar info. is stored at cells, so passing the cell id vector 
		double voltage_sum_lower=0, voltage_mean_lower, voltage_sum_upper=0, voltage_mean_upper; 
		scar_mean_lower = ensiteGraphics.MeanScalarWithinROIInPoly(polys, lowerPlaneIDs, 0, 100, false, false); 
		scar_mean_upper = ensiteGraphics.MeanScalarWithinROIInPoly(polys, upperPlaneIDs, 0, 100, false, false); 
		voltage_mean_lower = ensiteGraphics.MeanScalarWithinROIInPoly(polys_5, lowerPlaneIDs_V, 0, 100, true, false);		// voltage is stored at points, so passing the point id vector 
		voltage_mean_upper = ensiteGraphics.MeanScalarWithinROIInPoly(polys_5, upperPlaneIDs_V, 0, 100, true, false); 

		cout &lt;&lt; &quot;Average scar and voltage in selected area\n=================================&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;Lower (marked by red points) -&gt; Scar = &quot; &lt;&lt; scar_mean_lower &lt;&lt; &quot;, Voltage = &quot; &lt;&lt; voltage_mean_lower &lt;&lt; endl;
		cout &lt;&lt; &quot;Upper\t\t\t\t-&gt; Scar = &quot; &lt;&lt; scar_mean_upper &lt;&lt; &quot;, Voltage = &quot; &lt;&lt; voltage_mean_upper &lt;&lt; endl;

		if (isCroppedGeometryDisplayPreviously)
		{
			renderer1-&gt;RemoveActor(croppedGeomActor_Scar); 
			renderer1-&gt;RemoveActor(croppedGeomActor_Voltage); 
		}
		isCroppedGeometryDisplayPreviously = true; 
		// now display cropped geometry 
		if (curr_display_status == 1) { 
			heart-&gt;GetProperty()-&gt;SetOpacity(0.0); 
		}
		else if (curr_display_status == 2) { 
			if (isNoVoltageActorPresent) 
				noVoltageActor-&gt;GetProperty()-&gt;SetOpacity(0.0); 
			voltageMapActor-&gt;GetProperty()-&gt;SetOpacity(0.0); 
		}
		
		/*
		if (!isCroppedGeometryDisplayPreviously)
		{
			ensiteGraphics.ComputeScarValueAtEachPointInMesh(polys);
			ensiteGraphics.PhantomScalars(polys);
		}*/

		ensiteGraphics.DisplayCroppedGeometryUsingClippingPlanes(polys, voltageScarBoxWidget, Scarlut, fl_vtk_window_1, 0, 5.0 ,croppedGeomActor_Scar, clippedPoly_Scar, curr_display_status==2, false); 
		ensiteGraphics.DisplayCroppedGeometryUsingClippingPlanes(polys_5, voltageScarBoxWidget, voltageLut, fl_vtk_window_1, 0, currMaxV,croppedGeomActor_Voltage, clippedPoly_Voltage, curr_display_status==1,true); 
		

		cout &lt;&lt; &quot;Now writing histogram to files .. \n\n&quot;; 
		
		ensiteGraphics.GetHistogramOfPointsInMeshBasedOnTheirScalars(clippedPoly_Scar, &quot;histogram_scar.txt&quot;, false);
		ensiteGraphics.GetHistogramOfPointsInMeshBasedOnTheirScalars(clippedPoly_Voltage, &quot;histogram_voltage.txt&quot;, true);
		//ensiteGraphics.ExportMeshParaviewReadableFormat(clippedPoly_Scar, &quot;scarParaview.vtp&quot;); 
		//ensiteGraphics.ExportMeshParaviewReadableFormat(clippedPoly_Voltage, &quot;voltageParaview.vtp&quot;); 
	}
	else 
		cout &lt;&lt; &quot;\n\nERROR: Please select a ROI using the r on keyboard to bring up bounding box\n\n&quot; &lt;&lt; endl;
}

// ALL ENDOSENSE STUFF
void ENDOSENSE_load1(Fl_Widget*, void* user_data)
{
	char* newfile1, *newfile2; 

	newfile1 = fl_file_chooser(&quot;Select ablation tag text file&quot;, &quot;*.txt&quot;, dir_path);
	if (newfile1 != NULL)
	{
		cout &lt;&lt; &quot;reading endosense ablation tag file .. &quot;;
		endosense.Read(newfile1, 1); 
		cout &lt;&lt; &quot;finished .. &quot;;
		newfile2 = fl_file_chooser(&quot;Select fti file&quot;, &quot;*.txt&quot;, dir_path);
		
		if (newfile2 != NULL)
		{
			cout &lt;&lt; &quot;\nreading endosense fti file .. &quot;;
			endosense.Read(newfile2, 2); 
			cout &lt;&lt; &quot;finished .. now displaying ablation tag points\n&quot;;
			endosense.SetShell(polys);
			endosense.SHOW_AblationPointsOnShell(fl_vtk_window_1);
		}
	}
}


void ENDOSENSE_computePrimaryFTIMap(Fl_Widget*, void* user_data)
{
	bool b; 
	cout &lt;&lt; &quot;\n\nYou have invoked the automatic command line tool \n\n I hope you got all the params in ;)&quot; &lt;&lt; endl;
	if (_e1 &amp;&amp; _e2 &amp;&amp; _e3)
	{
		polys = vtkPolyData::New(); 
		endosense.Read(_eAB, 1); 
		b = endosense.Read(_efti, 2);
		if (b==false) return; 
		vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New();
		reader-&gt;SetFileName(_eSurf);
		reader-&gt;Update();
		polys = reader-&gt;GetOutput(); 
		endosense.SetShell(polys);
		cout &lt;&lt; &quot;I have just read a polygonal surface into memory containing &quot; &lt;&lt; polys-&gt;GetNumberOfPoints() &lt;&lt; &quot; points&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;\n\nOK, It seems you have given me all the params I need to compute FTI maps .. &quot; &lt;&lt; endl;
	}
	
	cout &lt;&lt; &quot;\nLocating all points on the LA geometry you provided .. \n&quot;; 
	endosense.GET_ClosestPointsOnGeometryMesh( _pointsInPolyWithFTI);
	cout &lt;&lt; &quot;\n\nFinished! Now computing shortest geodesic paths on surface .. \n&quot;; 
	endosense.GET_ShortestPathsUsingDijkstra( _pointsInPolyWithFTI);
	cout &lt;&lt; &quot;\n\nFinished! Finding primary ablation points just in-case you have asked for them .. \n&quot;; 
	endosense.GET_primaryAblationForcePoints(_et); 
	cout &lt;&lt; &quot;Finished! Now generating the force FTI map for you .. \n&quot;; 
	//endosense.GET_generateGangForceFTIMap(_et, _pointsInPolyWithFTI, _onlyPrimaryPoints, _EndosenseInterpolationType);
	endosense.GET_generateGangForceFTIMap_DistributeFTI(_et, _pointsInPolyWithFTI, _onlyPrimaryPoints, _EndosenseInterpolationType);
	cout &lt;&lt; &quot;Finished! Writing the force FTI map to file: &quot; &lt;&lt; _output; 
	endosense.WRITE_gangMapToFile(_output); 

	// 2013: displaying the shell with ablation points
	endosense.Display_shell(fl_vtk_window_1);
	endosense.SHOW_PrimaryAblationPointsOnShell(fl_vtk_window_1);
	cout &lt;&lt; &quot;\nFinished!&quot;;
}


/* 
*	NOTE: see also ENDOSENSE_computePrimaryFTIMap which only computes the force map. 
*	This is only for doing stats
*/
void ENDOSENSE_computeStats(Fl_Widget*, void* user_data)
{	/* old code
	char* newfile;
	double input; 

	cout &lt;&lt; &quot;\nHow far should I look around an ablation point for scar?&quot; &lt;&lt; endl; 
	cin &gt;&gt; input; 

	newfile = fl_file_chooser(&quot;Save file as&quot;, &quot;*.txt&quot;, dir_path);
	if (newfile != NULL)
	{
		//if (boxWidgetIsOn) 
		//{
			//boxWidget-&gt;GetPlanes(box_1_plane); 
			endosense.GET_cellsAroundEachAblationPoint(input); 
			endosense.GET_scarStatsAroundEachAblationPoint(); 
			endosense.WRITE_statsToFile(newfile); 
		//}
	} 
	*/ 
	bool b; 
	cout &lt;&lt; &quot;\n\nYou have invoked the automatic command line tool \n\n I hope you got all the params in ;)&quot; &lt;&lt; endl;
	if (_e1 &amp;&amp; _e2 &amp;&amp; _e3 &amp;&amp; _e4 &amp;&amp; _e5)
	{
		polys = vtkPolyData::New(); 
		endosense.Read(_eAB, 1); 
		b = endosense.Read(_efti, 2);
		if (b==false) return; 
		vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New();
		reader-&gt;SetFileName(_eSurf);
		reader-&gt;Update();
		polys = reader-&gt;GetOutput(); 
		endosense.SetShell(polys);
		cout &lt;&lt; &quot;I have just read a polygonal surface into memory containing &quot; &lt;&lt; polys-&gt;GetNumberOfPoints() &lt;&lt; &quot; points&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;\n\nOK, It seems you have given me all the params I need to get scar stats .. &quot; &lt;&lt; endl;
	
		cout &lt;&lt; &quot;\nLocating all points on the LA geometry you provided .. \n&quot;; 
		endosense.GET_ClosestPointsOnGeometryMesh( _pointsInPolyWithFTI);
		cout &lt;&lt; &quot;\n\nFinished! Now computing shortest geodesic paths on surface .. \n&quot;; 
		endosense.GET_ShortestPathsUsingDijkstra( _pointsInPolyWithFTI);
		endosense.GET_primaryAblationForcePoints(_et); 
		endosense.WRITE_CompareWithScarMap(_et, _output);
		
	}
	else
	{
		cout &lt;&lt; &quot;You must provide these switches: \neAB - ablation locations in xyz\nefti - &quot;
			&quot;fti file\net - radius extent of force\nes - scar surface\no - output text file&quot; &lt;&lt; endl;
		
	}
	

}

// This function was developed as an endosense utility but developed in a more general sense 
// for multiple shells with the same geometry to be processed using a common user-selected ROI 
void Load_N_Shells(Fl_Widget*, void* user_data)
{
	int num_shells; 
	char* newfile; 
	stringstream ss; 
	string gui_title; 
	bool abort = false; 

	cout &lt;&lt; &quot;\nHow many shells would you like to load? &quot;;
	cin &gt;&gt; num_shells; 

	vtkSmartPointer&lt;vtkPolyDataReader&gt; reader = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New();

	for (int i=0;i&lt;num_shells &amp;&amp; !abort;i++)
	{
		ss &lt;&lt; i; 
		gui_title = &quot;Load shell &quot;+ss.str(); 
		newfile = fl_file_chooser(gui_title.c_str(),&quot;*.vtk&quot;, dir_path); 

		if (newfile != NULL) 
		{
			reader-&gt;SetFileName(newfile); 
			reader-&gt;Update(); 
			n_polydata.push_back(vtkPolyData::New()); 
			n_polydata[n_polydata.size()-1]-&gt;DeepCopy(reader-&gt;GetOutput());				// if you dont do deep copy the memory assigned by Getoutput is released when function goes out of scope
			cout &lt;&lt; &quot;Read polydata with &quot; &lt;&lt; n_polydata[n_polydata.size()-1]-&gt;GetNumberOfCells() &lt;&lt;  &quot; cells &quot; &lt;&lt; endl;
		}
		else {
			abort = true; 
		}
	}	
	
	if (!abort) { 

		if (isOrthoPlaneViewedFirstTime) { 
			// callback wasnt set 
			vtkCallbackCommand *callback = vtkCallbackCommand::New();
			callback-&gt;SetCallback(keyPressedFunction);
			fl_vtk_window_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);
			
		}

		firstShellActor = vtkActor::New(); 

		displayPolyData(n_polydata[0], fl_vtk_window_1, isOrthoPlaneViewedFirstTime, firstShellActor); 
		
		cout &lt;&lt; &quot;\nShells loaded successfully, now open box widget by pressing x and select ROI. Then tools -&gt; analyze multiple shells&quot; &lt;&lt; endl; 
	}
}

void analyse_N_shells(Fl_Widget*, void* user_data)
{
	
	if (boxWidgetIsOn) 
	{
		cout &lt;&lt; &quot;I will analyze &quot; &lt;&lt; n_polydata.size() &lt;&lt; &quot;surface shells with &quot; &lt;&lt; endl;
			for (int i=0;i&lt;n_polydata.size();i++) {
				cout &lt;&lt; n_polydata[i] &lt;&lt;  &quot; cells &quot; &lt;&lt; endl;
			}
		boxWidget-&gt;GetPlanes(box_1_plane); 
		analysePolyData(n_polydata, box_1_plane); 
	}
	else
	{
		cout &lt;&lt; &quot;I could not find a ROI selection. Press x and select ROI using bounding box&quot; &lt;&lt; endl;
	}
}


void init()
{
	renWin1 = vtkRenderWindow::New();
	renWin2 = vtkRenderWindow::New();
	renWin3 = vtkRenderWindow::New();
	renWin4 = vtkRenderWindow::New();

	picker = vtkPointPicker::New();
	picker2 = vtkPropPicker::New();
	renderer1 = vtkRenderer::New();
	renderer2 = vtkRenderer::New();
	renderer3 = vtkRenderer::New();
	renderer4 = vtkRenderer::New();
	sliceZColors = vtkImageMapToColors::New();
	sliceXColors = vtkImageMapToColors::New();
	sliceYColors = vtkImageMapToColors::New();
	xSlice = vtkImageActor::New();
	ySlice = vtkImageActor::New();
	zSlice = vtkImageActor::New();
	bwLut = vtkLookupTable::New();

	interactorStyle1 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle2 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle3 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle4 = vtkInteractorStyleTrackballCamera::New();
	box_1_plane = vtkPlanes::New();
	box_2_plane = vtkPlanes::New();
	camera1 = vtkCamera::New();
	camera2 = vtkCamera::New();

	sphereActor = vtkActor::New();
	sphereActor2 = vtkActor::New(); 
	sphereMapper = vtkPolyDataMapper::New();
	heart = vtkActor::New();
	heart_copy = vtkActor::New();
	scar_actor = vtkActor::New(); 
	voltageMapActor = vtkActor::New();
	
	struct_points_data = vtkStructuredPoints::New();
	imageActorArray = new vtkImageActor*[3];
	boxWidget = vtkBoxWidget::New();
	boxWidget2 = vtkBoxWidget::New();
	voltageScarBoxWidget = vtkBoxWidget::New();

	planeWidget = vtkPlaneWidget::New();
	pl = vtkPlane::New(); 
	//volumeArray = new vtkVolume*[2];
	setUpBoxWidget();
	atrium_surface = vtkMarchingCubes::New();

	picker2_pos[0] = -1; picker2_pos[1] = -1; picker2_pos[2] = -1; 
	plotactor = vtkXYPlotActor::New(); 
	voltageSurfaceMapper = vtkPolyDataMapper::New(); 
	voltageLut = vtkLookupTable::New(); 
	noVoltageActor = vtkActor::New(); 

	isochroneMapper = vtkPolyDataMapper::New();
	isochroneActor = vtkActor::New(); 
	isochroneLut = vtkLookupTable::New(); 
	scalarBarForVoltage = vtkScalarBarActor::New();
	scalarBarForIsochrone = vtkScalarBarActor::New();
	scalarBarForScar = vtkScalarBarActor::New(); 

	thresholdedScar = vtkPolyData::New(); 
	thresholdedScarActor = vtkActor::New();

	peakTimeLut = vtkLookupTable::New();
	peakTimeScalarBar  = vtkScalarBarActor::New(); 
	peakTimeActor = vtkActor::New();
	peakTimeContourActor = vtkActor::New();
	peakTimeContourLabels = vtkActor2D::New();

	polys_2 = vtkPolyData::New();
	polys_3 = vtkPolyData::New();
	_scar_stdev_poly = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 
	_scar_multiplier_poly = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 
	_scar_original_poly = vtkSmartPointer&lt;vtkPolyData&gt;::New(); 

	winStats = vtkTextActor::New();
	
	scarProjectionActor = vtkActor::New(); 
	halfPlaneActor = vtkActor::New();
	croppedGeomActor_Scar = vtkActor::New();
	croppedGeomActor_Voltage = vtkActor::New();
	clippedPoly_Scar = vtkPolyData::New(); 
	clippedPoly_Voltage = vtkPolyData::New(); 

	angle_point_num=0;			// For Hafiz 2011 : computing angles 
	isCentroidComputed = false;

	edtTransformer = new irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;
	(irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt;::irtkDistanceTransform3D);

	isImageFolderSet = false; 
}

void destroy()
{
	renWin1-&gt;Delete();
	renWin2-&gt;Delete();
	renderer1-&gt;Delete();
	renderer2-&gt;Delete();
	sliceZColors-&gt;Delete();
	sliceXColors-&gt;Delete();
	sliceYColors-&gt;Delete();
	xSlice-&gt;Delete();
	ySlice-&gt;Delete();
	zSlice-&gt;Delete();
	bwLut-&gt;Delete();
	interactorStyle1-&gt;Delete();
	interactorStyle2-&gt;Delete();
	box_1_plane-&gt;Delete();
	box_2_plane-&gt;Delete();
	camera1-&gt;Delete();
	camera2-&gt;Delete();
	picker-&gt;Delete();
	picker2-&gt;Delete();
	sphereActor-&gt;Delete();
	sphereActor2-&gt;Delete(); 
	heart-&gt;Delete();
	struct_points_data-&gt;Delete();
	boxWidget-&gt;Delete();

}


void create_slider_for_peakarrival_window(Fl_Window *&amp;flw, char* title)
{
	int slider_x=2, slider_y=2, slider_w=30, slider_h=100, slider_sep = 40; 
	flw = new Fl_Window(100,160,title);
	Fl_Slider* color_hue_slider = new Fl_Slider(slider_x, slider_y, slider_w, slider_h, &quot;C&quot;);
	Fl_Slider* max_scalar_slider= new Fl_Slider(slider_x+(slider_sep), slider_y, slider_w, slider_h, &quot;T&quot;);
	int textbox_x=slider_x, textbox_y=slider_y+slider_h+20, textbox_w=slider_w, textbox_h=20; 
	Fl_Output* color_hue_txb = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* maximum_scalar_slider_txb = new Fl_Output(textbox_x+(slider_sep), textbox_y, textbox_w, textbox_h);
	color_hue_slider-&gt;callback(peakarrival_color_slider_cb, color_hue_txb);
	max_scalar_slider-&gt;callback(peakarrival_time_slider_cb, maximum_scalar_slider_txb);
	flw-&gt;end();
}

// brings up the sliders for manipulating color lookup table for voltage maps 
void create_slider_for_scarmaps_window(Fl_Window *&amp;flw, char* title)
{
	int slider_x=2, slider_y=2, slider_w=30, slider_h=100, slider_sep = 40; 
	flw = new Fl_Window(230,160,title);
	Fl_Slider* color_hue_slider = new Fl_Slider(slider_x, slider_y, slider_w, slider_h, &quot;C&quot;);
	Fl_Slider* max_scalar_slider= new Fl_Slider(slider_x+(slider_sep), slider_y, slider_w, slider_h, &quot;V&quot;);
	Fl_Slider* threshold_t1_slider= new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h, &quot;Lt&quot;);
	Fl_Slider* threshold_t2_slider= new Fl_Slider(slider_x+(slider_sep*3), slider_y, slider_w, slider_h, &quot;Ht&quot;);
	int textbox_x=slider_x, textbox_y=slider_y+slider_h+20, textbox_w=slider_w, textbox_h=20; 
	Fl_Output* color_hue_txb = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* maximum_scalar_slider_txb = new Fl_Output(textbox_x+(slider_sep), textbox_y, textbox_w, textbox_h);
	Fl_Output*  threshold_t1_slider_txb = new Fl_Output(textbox_x+(slider_sep*2), textbox_y, textbox_w, textbox_h);
	Fl_Output* threshold_t2_slider_txb = new Fl_Output(textbox_x+(slider_sep*3), textbox_y, textbox_w, textbox_h);
	
	color_hue_slider-&gt;callback(scar_color_slider_cb, color_hue_txb);
	max_scalar_slider-&gt;callback(scar_scalar_slider_cb, maximum_scalar_slider_txb);
	threshold_t1_slider-&gt;callback(threshold_t1_slider_cb, threshold_t1_slider_txb);
	threshold_t2_slider-&gt;callback(threshold_t2_slider_cb, threshold_t2_slider_txb);
	
	// **************** ONLY FOR TESTING RECURSIVE SLIDERS *****************
	// BUT NOW ALSO USING IT FOR ALTERING PARAMS WHEN DISPLAYING VOLTAGE-SCAR GRAPH
	Fl_Slider* recursive_neighbour_slider= new Fl_Slider(slider_x+(slider_sep*4), slider_y, slider_w, slider_h, &quot;Rn&quot;);
	Fl_Output* recursive_neighbour_slider_txb = new Fl_Output(textbox_x+(slider_sep*4), textbox_y, textbox_w, textbox_h);
	recursive_neighbour_slider-&gt;callback(recursive_neighbour_slider_cb, recursive_neighbour_slider_txb);		
	
	Fl_Slider* cellId_slider= new Fl_Slider(slider_x+(slider_sep*5), slider_y, slider_w, slider_h, &quot;Ci&quot;);
	Fl_Output* cellId_slider_txb = new Fl_Output(textbox_x+(slider_sep*5), textbox_y, textbox_w, textbox_h);
	cellId_slider-&gt;callback(cellId_slider_cb, cellId_slider_txb);		

	//Fl_Round_Button* scarRadioBut1 = new Fl_Round_Button(slider_x+(slider_sep*2), slider_y+5, 20,20, &quot;Mean&quot;); 
	//Fl_Round_Button* scarRadioBut2 = new Fl_Round_Button(slider_x+(slider_sep*2), slider_y+20+5, 20,20, &quot;Max&quot;); 

	flw-&gt;end();
}

// brings up the sliders for manipulating color lookup table for voltage maps 
void create_slider_for_isochronemaps_window(Fl_Window *&amp;flw, char* title)
{
	int slider_x=2, slider_y=2, slider_w=30, slider_h=100, slider_sep = 40; 
	flw = new Fl_Window(155,180,title);
	
	Fl_Slider* time_slider = new Fl_Slider(slider_x, slider_y, slider_w, slider_h, &quot;T&quot;);
	Fl_Slider* color_hue_slider = new Fl_Slider(slider_x+slider_sep, slider_y, slider_w, slider_h, &quot;C&quot;);
	Fl_Slider* max_scalar_slider= new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h, &quot;V&quot;);
	Fl_Slider* point_influence_slider= new Fl_Slider(slider_x+(slider_sep*3), slider_y, slider_w, slider_h, &quot;I&quot;);
	
	
	int textbox_x=slider_x, textbox_y=slider_y+slider_h+20, textbox_w=slider_w, textbox_h=20; 
	Fl_Output* time_slider_txb = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* color_hue_txb = new Fl_Output(textbox_x+(slider_sep*1), textbox_y, textbox_w, textbox_h);
	Fl_Output* maximum_scalar_slider_txb = new Fl_Output(textbox_x+(slider_sep*2), textbox_y, textbox_w, textbox_h);
	Fl_Output* point_influence_txb = new Fl_Output(textbox_x+(slider_sep*3), textbox_y, textbox_w, textbox_h);
	
	int button_x=10, button_y=slider_y+slider_h+20+textbox_h+5, button_h=20, button_w=95;
	Fl_Button* redrawBut = new Fl_Button(button_x, button_y, button_w, button_h, &quot;Redraw&quot;);
	redrawBut-&gt;callback(redraw_isochrone_map_cb, NULL); 

	time_slider-&gt;callback(isochrone_time_slider_cb, time_slider_txb);
	color_hue_slider-&gt;callback(isochrone_color_hue_slider_cb, color_hue_txb);
	max_scalar_slider-&gt;callback(isochrone_scalar_slider_cb, maximum_scalar_slider_txb);
	point_influence_slider-&gt;callback(isochrone_point_influence_slider_cb, point_influence_txb);

	/*
	int button_x=10, button_y=slider_y+slider_h+20+textbox_h+5, button_h=20, button_w=95;
	Fl_Button* redrawBut = new Fl_Button(button_x, button_y, button_w, button_h, &quot;Re-color&quot;);
	redrawBut-&gt;callback(redraw_voltage_color_cb, NULL); */
	flw-&gt;end();
}

// brings up the sliders for manipulating color lookup table for voltage maps 
void create_slider_for_voltage_window(Fl_Window *&amp;flw, char* title)
{
	int slider_x=2, slider_y=2, slider_w=30, slider_h=100, slider_sep = 40; 
	flw = new Fl_Window(190,180,title);
	
	Fl_Slider* color_hue_slider = new Fl_Slider(slider_x+(slider_sep*0), slider_y, slider_w, slider_h, &quot;C&quot;);
	Fl_Slider* maximum_voltage_slider = new Fl_Slider(slider_x+slider_sep, slider_y, slider_w, slider_h, &quot;V&quot;);
	Fl_Slider* std_dev_slider= new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h, &quot;SD&quot;);
	Fl_Slider* k_nearest_slider= new Fl_Slider(slider_x+(slider_sep*3), slider_y, slider_w, slider_h, &quot;Kn&quot;);
	Fl_Slider* dist_thresh_slider= new Fl_Slider(slider_x+(slider_sep*4), slider_y, slider_w, slider_h, &quot;D&quot;);
	
	int textbox_x=slider_x, textbox_y=slider_y+slider_h+20, textbox_w=slider_w, textbox_h=20; 
	Fl_Output* color_hue_slider_txb = new Fl_Output(textbox_x+(slider_sep*0), textbox_y, textbox_w, textbox_h);
	Fl_Output* maximum_voltage_slider_txb = new Fl_Output(textbox_x+(slider_sep*1), textbox_y, textbox_w, textbox_h);
	Fl_Output* std_dev_txb = new Fl_Output(textbox_x+(slider_sep*2), textbox_y, textbox_w, textbox_h);
	Fl_Output* k_nearest_txb = new Fl_Output(textbox_x+(slider_sep*3), textbox_y, textbox_w, textbox_h);
	Fl_Output* dist_thresh_txb = new Fl_Output(textbox_x+(slider_sep*4), textbox_y, textbox_w, textbox_h);
	
	
	color_hue_slider-&gt;callback(color_hue_slider_cb, color_hue_slider_txb);
	maximum_voltage_slider-&gt;callback(maximum_voltage_slider_cb,maximum_voltage_slider_txb);
	std_dev_slider-&gt;callback(std_dev_slider_cb, std_dev_txb);
	k_nearest_slider-&gt;callback(k_nearest_slider_cb, k_nearest_txb);
	dist_thresh_slider-&gt;callback(dist_thresh_slider_cb, dist_thresh_txb);

	int button_x=10, button_y=slider_y+slider_h+20+textbox_h+5, button_h=20, button_w=95;
	Fl_Button* redrawBut = new Fl_Button(button_x, button_y, button_w, button_h, &quot;Re-color&quot;);
	redrawBut-&gt;callback(redraw_voltage_color_cb, NULL); 
	flw-&gt;end();
}

// MAY 2010: the new sub-window which displays the voltage trace XY plot when a location on the 
// atrial surface mesh is clicked 
void create_XYPlot_window(vtkFlRenderWindowInteractor *&amp;vtki, Fl_Window *&amp;flw, char* title)
{
	flw = new Fl_Window(800,300,title);
	vtki = new vtkFlRenderWindowInteractor(5,5,790, 290, NULL); 
	vtki-&gt;SetInteractorStyle(interactorStyle4);
	flw-&gt;resizable(vtki);
	flw-&gt;end();
}

void create_window(vtkFlRenderWindowInteractor *&amp;flrwi_1, vtkFlRenderWindowInteractor *&amp;flrwi_2, vtkFlRenderWindowInteractor *&amp;flrwi_3,
				   Fl_Window *&amp;flw, char* title)
{
	flw = new Fl_Window(1135,920,title);
		

	if (_IS_SPLIT_SCREEN == 1)
	{
		flrwi_1 = new vtkFlRenderWindowInteractor(5,60,870,437, NULL);
		flrwi_3 = new vtkFlRenderWindowInteractor(5,477,870,437,NULL);
		flrwi_2 = new vtkFlRenderWindowInteractor(890,35,200,200,NULL);
	}
	else
	{
		flrwi_1 = new vtkFlRenderWindowInteractor(5,60,870,875, NULL);
		flrwi_2 = new vtkFlRenderWindowInteractor(890,35,200,200,NULL);
		flrwi_3 = new vtkFlRenderWindowInteractor(890,240,200,200,NULL);
	}

	flrwi_1-&gt;SetInteractorStyle(interactorStyle1);
	flrwi_2-&gt;SetInteractorStyle(interactorStyle2);
	flrwi_3-&gt;SetInteractorStyle(interactorStyle3);

	// menu bar
		Fl_Menu_Item menuitems[] = {
			{ &quot;File&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Open scar-enhancement scan&quot;,  FL_CTRL+'1', (Fl_Callback *)open_MRI_scan_cb, 0 },
				{ &quot;Open segmented atria Image&quot;,    FL_CTRL + '2', (Fl_Callback *)open_segmented_cb, 0 },
				{ &quot;Open segmented atria VTK&quot;,    FL_CTRL + '3', (Fl_Callback *)open_segmented_cb, 0 },
				{ &quot;Save Movie for Renderer1 As ..&quot;, NULL, (Fl_Callback *)generate_movie_cb, (void*)1, 0},
				{&quot;Export displayed shell As Paraview.. &quot;, NULL, (Fl_Callback *)binarize_scar_surface_cb, 0, FL_MENU_DIVIDER},
				{&quot;Export other shell As Paraview.. &quot;, NULL, (Fl_Callback *)export_other_shells_cb, 0, FL_MENU_DIVIDER},
				{ &quot;Exit&quot;, FL_CTRL + '0', (Fl_Callback *)quit_cb, 0 },
				{ 0 },
			{ &quot;Scar&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Display/Hide scar&quot;,    NULL, (Fl_Callback *)show_scar_cb, 0 },
				{ &quot;Construct graph for cuts&quot;, NULL, (Fl_Callback*)compute_graphcut_segmentation_cb, 0, FL_MENU_DIVIDER}, 
				{ &quot;Construct graph for cuts using pre-computed&quot;, NULL, (Fl_Callback*)compute_graphcut_segmentation_cb, (void*)2, FL_MENU_DIVIDER}, 
				{ &quot;Automatic scar segmentation read file&quot;, NULL, (Fl_Callback*)compute_graphcut_segmentation_cb, (void*)3}, 
				{ &quot;Segment scar with auto read pre-process data (iterative)&quot;, NULL, (Fl_Callback*)compute_graphcut_segmentation_cb, (void*)5}, 
				//{ &quot;Threshold scar&quot;, NULL, (Fl_Callback*)threshold_scar_on_surface_cb, 0}, 
				{ 0 },
			{ &quot;Scar-Voltage&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Constrained box scar-voltage&quot;,    NULL, (Fl_Callback *)scarVoltageInsideBox_cb, 0 },
				{ &quot;Scar-voltage cell histogram to file&quot;,    NULL, (Fl_Callback *)scarVoltageCellHistogram_cb, 0 },
				{ &quot;Scar or voltage data to file inside ROI&quot;, NULL, (Fl_Callback *)scarOrVoltageInsideBox_cb, 0}, 
				//{ &quot;Threshold scar&quot;, NULL, (Fl_Callback*)threshold_scar_on_surface_cb, 0}, 
				{ 0 },
			{ &quot;Tools&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Ostia measurements&quot;,    NULL, (Fl_Callback *)ostia_measure_cb, 0 },
				{ &quot;Normal Myocardium ROI&quot;,    NULL, (Fl_Callback *)compute_normal_myocardium_cb, 0,  FL_MENU_DIVIDER},
				{ &quot;Compute LA centroid &quot; , NULL, (Fl_Callback*)LA_centroid_measure_cb, 0},
				{ &quot;Load multiple shells &quot; , NULL, (Fl_Callback*)Load_N_Shells, 0, FL_MENU_DIVIDER},
				{ &quot;Analyze multiple shells &quot; , NULL, (Fl_Callback*)analyse_N_shells, 0},
				{ 0 },
			{ &quot;VTK-VRML&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Open VTK shell&quot;,    NULL, (Fl_Callback *)open_vtk_shell_cb, 0 },
				{ &quot;Convert to VTK&quot;,    NULL, (Fl_Callback *)vrml_to_vtk_cb, 0 },
				{ 0 },
			{ &quot;Encircle&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Open VTK shell&quot;,    NULL, (Fl_Callback *)open_vtk_shell_encircler_cb, 0 },
				/*{ &quot;Register points around ostium&quot;,    NULL, (Fl_Callback *)register_point_encircle_cb, 0 },*/
				{ 0 },
			{&quot;Ensite&quot;,              0, 0, 0, FL_SUBMENU }, 
				{ &quot;Export atrial geometry as DIF XML&quot;,   NULL, (Fl_Callback *)exportSurfaceAsEnsiteXML, 0 },
				{ &quot;Export scar geometry as DIF XML&quot;,   NULL, (Fl_Callback *)exportScarSurfaceAsEnsiteXML, 0, FL_MENU_DIVIDER },
				{ &quot;Import Geometry data as CSV&quot;,  NULL, (Fl_Callback *)importGeometryDataAsCSV, 0 },
				{ &quot;Import Voltage data as CSV&quot;,  NULL, (Fl_Callback *)importVoltageDataAsCSV, 0, FL_MENU_DIVIDER },
				{ &quot;Show Voltage Trace Isochrone Map&quot;, NULL, (Fl_Callback *)showTraceIsochroneMap, 0},
				{ &quot;Generate voltage-scar correlation file&quot;, NULL, (Fl_Callback *)generateVoltageScarCorrelation, 0},
				{ &quot;Display voltage-scar graph&quot;, NULL, (Fl_Callback *)displayXYPlotVoltageScarCorrelation, 0},
				{ 0 },
			{&quot;EndoSense&quot;,              0, 0, 0, FL_SUBMENU }, 
				{ &quot;Load ablation point and FTI files&quot;,   NULL, (Fl_Callback *)ENDOSENSE_load1, 0 },
				{ &quot;Compute force FTI map&quot;,   NULL, (Fl_Callback *)ENDOSENSE_computePrimaryFTIMap, 0, FL_MENU_DIVIDER },
				{ &quot;Scar stats to file using simple distance&quot; , NULL, (Fl_Callback *)ENDOSENSE_computeStats, 0},
				{ 0 },
		{ 0 }};

	Fl_Menu_Bar *m = new Fl_Menu_Bar(0, 0, 1135, 30);
	m-&gt;copy(menuitems);

 	// buttons

	int button_x=1035, button_y=445, button_h=20, button_w=95, button_sep=30;

	// sliders
	int slider_x=880, slider_y=445, slider_h=100, slider_w=30, slider_sep=30; 
	Fl_Slider* xSlice_selector = new Fl_Slider(slider_x, slider_y+0, slider_w, slider_h+20, &quot;X&quot;);
	Fl_Slider* ySlice_selector = new Fl_Slider(slider_x+(slider_sep*1), slider_y, slider_w, slider_h+20, &quot;Y&quot;);
	Fl_Slider* zSlice_selector = new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h+20, &quot;Z&quot;);

	Fl_Slider* MIP_slider =	new Fl_Slider(slider_x+(slider_sep*4), slider_y, slider_w, slider_h+20, &quot;MIP&quot;);
	
	// slider buttons 
	Fl_Button* xSlice_onoff = new Fl_Button(slider_x, slider_y+slider_h+35, slider_w, 25, &quot;+-X&quot;);
	Fl_Button* ySlice_onoff = new Fl_Button(slider_x+(slider_sep*1), slider_y+slider_h+35, slider_w, 25, &quot;+-Y&quot;);
	Fl_Button* zSlice_onoff = new Fl_Button(slider_x+(slider_sep*2), slider_y+slider_h+35, slider_w, 25, &quot;+-Z&quot;);

	Fl_Output* MIP_slider_textDisplay = new Fl_Output(slider_x+(slider_sep*4), slider_y+slider_h+35, slider_w, 25);


//	Fl_Slider* table_range_low_selector = new Fl_Slider(slider_x, slider_y+300, slider_w, slider_h+20, &quot;TL&quot;);
//	Fl_Slider* table_range_high_selector = new Fl_Slider(slider_x, slider_y+300, slider_w, slider_h+20, &quot;TH&quot;);
	Fl_Slider* zSliceOpacity_selector = new Fl_Slider(slider_x, slider_y+175, slider_w, slider_h+20, &quot;OPz&quot;);
	Fl_Slider* opacity_selector = new Fl_Slider(slider_x+(slider_sep*1), slider_y+175, slider_w, slider_h+20, &quot;OP&quot;);
	Fl_Slider* scar_opactity_selector = new Fl_Slider(slider_x+(slider_sep*2), slider_y+175, slider_w, slider_h+20, &quot;OPs&quot;);
	Fl_Slider* peaktime_opactity_selector = new Fl_Slider(slider_x+(slider_sep*3), slider_y+175, slider_w, slider_h+20, &quot;OPt&quot;);

	// these thresholds can also be used for constrained thresholding using boxwidget and boxwidget2
	// high_threshold_selector is for boxwidget2
	low_threshold_selector = new Fl_Slider(slider_x+(slider_sep*5), slider_y+175, slider_w, slider_h+20, &quot;L.S&quot;);
	high_threshold_selector = new Fl_Slider(slider_x+(slider_sep*6), slider_y+175, slider_w, slider_h+20, &quot;H.S&quot;);
	Fl_Slider* lookUpTable_selector = new Fl_Slider(slider_x+(slider_sep*7), slider_y+175, slider_w, slider_h+120, &quot;B&quot;);

	
	// test display boxes
	int textbox_y = slider_y+175+20+slider_h+15, textbox_sep = slider_sep;
	int textbox_x=880, textbox_w=30, textbox_h=20;		// for third row of sliders, textbox_y is defined earlier with slider_y 
//	Fl_Output* table_low_selector_textDisplay = new Fl_Output(textbox_x, textbox_y+300, textbox_w, textbox_h);
//	Fl_Output* table_high_selector_textDisplay = new Fl_Output(textbox_x, textbox_y+300, textbox_w, textbox_h);
	
	Fl_Output* zSliceOpacity_textDisplay = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* hue_textDisplay = new Fl_Output(textbox_x+(textbox_sep*1), textbox_y, textbox_w, textbox_h);
	Fl_Output* scar_textDisplay = new Fl_Output(textbox_x+(textbox_sep*2), textbox_y, textbox_w, textbox_h);
	Fl_Output* peaktime_opacity_textDisplay= new Fl_Output(textbox_x+(textbox_sep*3), textbox_y, textbox_w, textbox_h);
	textbox_w = 30;
	Fl_Output* low_threshold_selector_textDisplay = new Fl_Output(textbox_x+(textbox_sep*5), textbox_y, textbox_w, textbox_h);
	Fl_Output* high_threshold_selector_textDisplay = new Fl_Output(textbox_x+(textbox_sep*6), textbox_y, textbox_w, textbox_h);
	Fl_Output* displayPath_textDisplay = new Fl_Output(5, 35, 400, textbox_h);

	slider_h = 60; slider_sep = 35; button_y=445; button_sep=30; slider_y = button_y+(button_sep*12); textbox_w = 30;
	at_body_distance_low_slider = new Fl_Slider(slider_x, slider_y, slider_w, slider_h, &quot;L.AB&quot;); 
	at_body_distance_high_slider = new Fl_Slider(slider_x+(slider_sep*1), slider_y, slider_w, slider_h, &quot;H.AB&quot;); 
	Fl_Slider* smoothing_slider = new Fl_Slider(slider_x+(slider_sep*4), slider_y, slider_w, slider_h, &quot;SMTH&quot;); 
	
	textbox_x = slider_x; textbox_y = slider_y+slider_h+15; textbox_sep = slider_sep; 
	Fl_Output* at_body_distance_low_slider_textDisplay = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* at_body_distance_high_slider_textDisplay = new Fl_Output(textbox_x+(slider_sep*1), textbox_y, textbox_w, textbox_h);
	Fl_Output* smoothing_slider_textDisplay = new Fl_Output(textbox_x+(slider_sep*4), textbox_y, textbox_w, textbox_h);

	// BUTTONS 
	button_x=1035; button_y=445; button_h=20; button_w=95; button_sep=30;
	Fl_Button* redrawScarBut = new Fl_Button(button_x, button_y, button_w, button_h, &quot;&amp;Re-map scar&quot;);
	Fl_Button* ostiaMeasureBut = new Fl_Button(button_x, button_y+button_sep, button_w, button_h, &quot;&amp;Msure Ostia&quot;);
	Fl_Button* shellOnOffBut = new Fl_Button(button_x, button_y+(button_sep*2), button_w, button_h, &quot;&amp;Shell Off&quot;);

	Fl_Button* pvAngleMeasureResetBut = new Fl_Button(button_x, button_y+(button_sep*3), button_w, button_h, &quot;Reset PV Ang&quot;);
	Fl_Button* displayPathBut = new Fl_Button(410, 35, 120, 20, &quot;Set image folder&quot;);
	

	Fl_Check_Button* syncWin2Check = new Fl_Check_Button(1090, 38, 20,20, &quot;Syn&quot;); 
	Fl_Check_Button* scarProjActorCheck = new Fl_Check_Button(1090, 68, 20,20, &quot;ScrA&quot;); 


	zSlice_selector-&gt;type(FL_VERTICAL);
	ySlice_selector-&gt;type(FL_VERTICAL);
	xSlice_selector-&gt;type(FL_VERTICAL);
	lookUpTable_selector-&gt;type(FL_VERTICAL);
    MIP_slider-&gt;type(FL_VERTICAL);

	opacity_selector-&gt;type(FL_VERTICAL);
	scar_opactity_selector-&gt;type(FL_VERTICAL);
	low_threshold_selector-&gt;type(FL_VERTICAL);
	high_threshold_selector-&gt;type(FL_VERTICAL);
	zSliceOpacity_selector-&gt;type(FL_VERTICAL);

	// for box widget
	boxWidget-&gt;SetInteractor(flrwi_1);
	boxWidget2-&gt;SetInteractor(flrwi_1);
	voltageScarBoxWidget-&gt;SetInteractor(flrwi_1);
	//boxWidget-&gt;SetPlaceFactor(1.0);

	// sliders
	zSlice_selector-&gt;callback(zSlice_selector_cb, NULL);
	xSlice_selector-&gt;callback(xSlice_selector_cb, NULL);
	ySlice_selector-&gt;callback(ySlice_selector_cb, NULL);
	lookUpTable_selector-&gt;callback(lookUpTable_selector_cb, NULL);
	low_threshold_selector-&gt;callback(low_threshold_selector_cb, low_threshold_selector_textDisplay);
	high_threshold_selector-&gt;callback(high_threshold_selector_cb, high_threshold_selector_textDisplay);
	smoothing_slider-&gt;callback(smoothing_slider_cb, smoothing_slider_textDisplay);
	MIP_slider-&gt;callback(MIP_slider_cb, MIP_slider_textDisplay); 

	at_body_distance_low_slider-&gt;callback(at_body_distance_low_slider_cb, at_body_distance_low_slider_textDisplay); 
	at_body_distance_high_slider-&gt;callback(at_body_distance_high_slider_cb, at_body_distance_high_slider_textDisplay); 
//	table_range_low_selector-&gt;callback(table_range_low_selector_cb, table_low_selector_textDisplay);
//	table_range_high_selector-&gt;callback(table_range_high_selector_cb, table_high_selector_textDisplay);
	opacity_selector-&gt;callback(opacity_selector_cb, hue_textDisplay);
	scar_opactity_selector-&gt;callback(scar_opacity_selector_cb, scar_textDisplay);
	peaktime_opactity_selector-&gt;callback(peaktime_opacity_selector_cb, peaktime_opacity_textDisplay);
	zSliceOpacity_selector-&gt;callback(opacity_selector_for_z_slice_cb, zSliceOpacity_textDisplay);
	
	// button callbacks 
	redrawScarBut-&gt;callback(redraw_scar_cb, NULL); 
	ostiaMeasureBut-&gt;callback(start_ostia_measure_cb, NULL); 
	xSlice_onoff-&gt;callback(slice_onoff, (void*)0);
	ySlice_onoff-&gt;callback(slice_onoff, (void*)1);
	zSlice_onoff-&gt;callback(slice_onoff, (void*)2);
	
	pvAngleMeasureResetBut-&gt;callback(pv_angle_measure_reset_cb, NULL); 
	shellOnOffBut-&gt;callback(shellOnOff_cb, NULL); 
	// callback for checkbutton 
	syncWin2Check-&gt;callback(syncWin2_cb, syncWin2Check);
	scarProjActorCheck-&gt;callback(scarProjActorCheck_cb, scarProjActorCheck); 

	// callback for setpath button 
	displayPathBut-&gt;callback(setPathCallback_cb, displayPath_textDisplay);

	// some more callbacks
	vtkCallbackCommand *callback = vtkCallbackCommand::New();
    callback-&gt;SetCallback(keyPressedFunction);
    flrwi_2-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);
	
	vtkCallbackCommand *callback_2 = vtkCallbackCommand::New();
	vtkCallbackCommand *callback_3 = vtkCallbackCommand::New();
	vtkCallbackCommand *callback_4 = vtkCallbackCommand::New();
    callback_2-&gt;SetCallback(LeftMouseButtonPressedFunction);
	callback_3-&gt;SetCallback(LeftMouseButtonReleasedFunction);
	callback_4-&gt;SetCallback(mouseMovedFunction);
	flrwi_1-&gt;AddObserver(vtkCommand::LeftButtonPressEvent, callback_2);
	flrwi_1-&gt;AddObserver(vtkCommand::LeftButtonReleaseEvent, callback_3);
	flrwi_1-&gt;AddObserver(vtkCommand::MouseMoveEvent, callback_4);

	flw-&gt;resizable(flrwi_1);
	
	flw-&gt;end();


}



int main (int argc, char* argv[])
{
	bool foundArgs = false,  isAutoMode = false;
	benAutoMode=false; 
	
	useAtlasMode = 0;		// setting default use for sptial prob atlas usage - i.e. dont use atlas, only use if set by -atlas flag
	dir_path = &quot;C:\\Users\\James Harrison\\Documents\\MRIs&quot;;

	_scar_model_mean = -1;		// default values for the trained scar model in automatic scar segmentation using graphcuts 
	_scar_model_stdev = -1;	
	_scar_auto_seg_iterations = 20;

	if (argc &gt;= 1)
	{
		for (int i = 1; i &lt; argc; i++) {
			if (i + 1 != argc) { 
				 if (string(argv[i]) == &quot;-w&quot;) {
					dir_path = argv[i+1]; 
					foundArgs = true;
				 }
				 else if (string(argv[i]) == &quot;-t&quot;) {
					mcubes_threshold = atoi(argv[i+1]);	
					foundArgs = true; 

				 } else if (string(argv[i]) == &quot;-m&quot;) {
					 _scar_model_mean = atof(argv[i+1]); 
					foundArgs = true; 

				 } else if (string(argv[i]) == &quot;-s&quot;) { 
					 _scar_model_stdev = atof(argv[i+1]); 
					 foundArgs = true;  

				 } else if (string(argv[i]) == &quot;-auto&quot;) { 
					 isAutoMode = true; 
					 foundArgs = true; 

				 }
				  else if (string(argv[i]) == &quot;--atlas&quot;) { 
					 useAtlasMode = 1; 
					 foundArgs = true; 

				 }
				 else if (string(argv[i]) == &quot;-eFTI&quot;) {
					_efti = argv[i+1]; 
					foundArgs = false; 
					_e1 = true; 
				 }
				 else if (string(argv[i]) == &quot;-eAB&quot;) {
					_eAB = argv[i+1]; 
					foundArgs = false; 
					_e2 = true; 
				 }
				 else if (string(argv[i]) == &quot;-es&quot;) {
					_eSurf = argv[i+1]; 
					foundArgs = false; 
					_e3 = true; 
				 }
				  else if (string(argv[i]) == &quot;-et&quot;) {
					_et = atof(argv[i+1]);
					_e4 = true;
				 }
				  else if (string(argv[i]) == &quot;-ep&quot;) {
					foundArgs = false; 
					_onlyPrimaryPoints = true; 

				  } else if (string(argv[i]) == &quot;-eInter&quot;) { 
					  _EndosenseInterpolationType = atoi(argv[i+1]);
				  }
				   else if (string(argv[i]) == &quot;-o&quot;) {
					_output = argv[i+1]; 
					_e5 = true; 
				 }
				 else if (string(argv[i]) == &quot;-i1&quot; ) { 
					_input_f1 = argv[i+1]; 
					foundArgs = true;	
				   }
				else if (string(argv[i]) == &quot;-i2&quot; ) { 
					_input_f2 = argv[i+1]; 
					foundArgs = true;	
				   }
				else if (string(argv[i]) == &quot;--ben&quot; ) { 
					benAutoMode = true; 
					foundArgs = true;	
				   }
				 
				 else if (string(argv[i]) == &quot;--h&quot;) {
					foundArgs = false; 
				 }
				 else if (string(argv[i]) == &quot;-surf&quot;) {
					_surf_input = argv[i+1];

				 }
				   else if (string(argv[i]) == &quot;-iter&quot;) { 
					 _scar_auto_seg_iterations = atof(argv[i+1]); 
					 foundArgs = true;  

				 }
				
			}

		}
		
		if (_e1 || _e2 || _e3)	// if any of the endosense params were used 
		{
			if (_e1 &amp;&amp; _e2 &amp;&amp; _e3)		// then they all have to be present 
				foundArgs = true; 
		}
		if (foundArgs == false)
		{
			cout &lt;&lt; &quot;\n\nUsage: Scar3d \n\n\tArguments:\n\n\t-w &lt;working directory&gt; (mandatory)\n\nOptional:\n\t-t &lt;marching cubes threshold&gt; \n\t-m&quot; 
				&quot;&lt;scar trained model mean&gt; \n\t-s &lt;scar trained model variance&gt;\n\t-iter &lt;number of iterations&gt; 12 is defaut&quot;
				&quot;\n\t-auto (to run on auto-pilot)\n\n--atlas use spatial atlas in computation of scars&quot;
				&quot;\n\nEndosense mode:\n\t-eAB - ablation tag point file\n\t-es - vtk surface of the LA shell \n\t-eFTI - fti file in text format\n\t-et -- threshold for primary ablation point diameter&quot;
				&quot;\n\t-ep x - requesting only primary ablation points to be mapped\n\t-eInter - specify FTI mapping method:\n\t\t1-Constant, 2-Linear, 3-Gaussian exponential&quot; 
				&quot;\n\nBen Knowles MIP projection mode:\n\t-i1 DE-MRI image registered in 3dheart\n\t-i2 3D heart segmentation\n\t-m normal myocardium mean\n\t-s normal myocardium std. dev. \n\t--ben enable ben method\n\t-o output vtk file&quot;
				&quot;\n\n\t-o any output file\t--h for help&quot; 
				&lt;&lt; endl;
			exit(0);
		}
	}

		
	Fl_Window *main_window = NULL;
	
	init();
	create_window(fl_vtk_window_1, fl_vtk_window_2, fl_vtk_window_3, main_window,
		&quot;Scar3D :: Rashed karim 2009&quot;);


	create_XYPlot_window(fl_vtk_window_4, xyplot_win, &quot;Voltage trace&quot;);
	create_slider_for_voltage_window(voltage_slider_win, &quot;Volt control&quot;); 
	create_slider_for_isochronemaps_window(isochrone_slider_win, &quot;isochrone&quot;);
	create_slider_for_scarmaps_window(scar_slider_win, &quot;Scar&quot;); 
	create_slider_for_peakarrival_window(peakarrival_slider_win, &quot;Peak arrival&quot;);

	main_window-&gt;show();
	fl_vtk_window_1-&gt;show();
	fl_vtk_window_2-&gt;show();
	fl_vtk_window_3-&gt;show();
	//voltage_slider_win-&gt;show(); 
	scar_slider_win-&gt;show();
	//isochrone_slider_win-&gt;show();
	//peakarrival_slider_win-&gt;show();

	renderer1-&gt;SetBackground(0.22,0.23,0.32);	// this is the preferred background color (violet)
	renWin1-&gt;AddRenderer(renderer1);
	fl_vtk_window_1-&gt;SetRenderWindow(renWin1);

	renWin2-&gt;AddRenderer(renderer2);
	fl_vtk_window_2-&gt;SetRenderWindow(renWin2);

	renderer3-&gt;SetBackground(0,0,0);	
	renWin3-&gt;AddRenderer(renderer3);
	fl_vtk_window_3-&gt;SetRenderWindow(renWin3);

	renWin4-&gt;AddRenderer(renderer4);
	fl_vtk_window_4-&gt;SetRenderWindow(renWin4);

	fl_vtk_window_1-&gt;Initialize();
	fl_vtk_window_2-&gt;Initialize();
	fl_vtk_window_3-&gt;Initialize();
	fl_vtk_window_4-&gt;Initialize();
	
	picker2-&gt;InitializePickList();
	if (isAutoMode == true)			// runs auto-pilot and application exits  when it finishes 
	{
		graphcut_segmentation_assist(5);
		destroy();
		exit(0);
		return -1;
	}
	else if (benAutoMode == true)	// runs on auto-pilot and application exits  when it finishes 
	{
		MIP_on_surface_assist(); 
		destroy();
		exit(0); 
		return -1; 
	}
	else
	{
		int fl_ret = Fl::run();
		destroy();
		return fl_ret;
	}

	

}

&lt;/pre&gt;

== Header == 
&lt;pre&gt;
/*
Log of changes (Aug. 11th 2010: 

1. Turned on _CONSTRAINED_THRESHOLDING TO 1 make this 0
2. In show_Surface_normals, commented out entire branch of an if statement that checks if _CONSTRAINED_THRESHOLDING, upto else. Un-comment this
3. Right before the scalars are printed to file in show_surface_normals, there is an extra if statement which checks if cell centre is within boxwidget *

*/

#define HAS_VTK 1
#include &quot;vtkRenderer.h&quot;
#include &quot;vtkRenderWindow.h&quot;
#include &quot;vtkRenderWindowInteractor.h&quot;
#include &lt;vtkPiecewiseFunction.h&gt;
#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkVolumeProperty.h&gt;
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include &lt;vtkVolumeRayCastMIPFunction.h&gt;
#include &lt;vtkVolumeRayCastMapper.h&gt;
#include &lt;vtkVolume.h&gt;
#include &lt;vtkVolumeTextureMapper2D.h&gt;
#include &lt;vtkImageReader.h&gt;
#include &lt;vtkImageImport.h&gt;
#include &lt;vtkImageCast.h&gt;
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include &lt;vtkStructuredPoints.h&gt;
#include &lt;vtkStructuredGrid.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &quot;vtkPointData.h&quot;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkCommand.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkContourFilter.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkImageToPolyDataFilter.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkCallbackCommand.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkImagePlaneWidget.h&gt;

#include &lt;vtkImageMapToColors.h&gt;
#include &lt;vtkInteractorStyleTrackballCamera.h&gt;
#include &lt;vtkInteractorStyleFlight.h&gt;
#include &lt;vtkPropPicker.h&gt;
#include &lt;vtkBoxWidget.h&gt;
#include &lt;vtkPlanes.h&gt;
#include &lt;vtkRendererCollection.h&gt;
#include &lt;vtkWindowedSincPolyDataFilter.h&gt;
#include &lt;vtkDiscreteMarchingCubes.h&gt;
#include &lt;vtkImageThreshold.h&gt;
#include &lt;vtkWindowToImageFilter.h&gt;
#include &lt;vtkAVIWriter.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkOBJExporter.h&gt;
#include &lt;vtkMaskPoints.h&gt;
#include &lt;vtkConeSource.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkTriangle.h&gt;
#include &lt;vtkThreshold.h&gt;
#include &lt;vtkDataSetSurfaceFilter.h&gt;
#include &lt;vtkTextActor.h&gt;
#include &lt;vtkTextProperty.h&gt;
#include &lt;vtkCellLocator.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &quot;vtkGenericCell.h&quot;
#include &quot;vtkOrientationMarkerWidget.h&quot;
#include &quot;vtkAxesActor.h&quot;
#include &quot;vtkAnnotatedCubeActor.h&quot;
#include &quot;vtkPropAssembly.h&quot;
#include &quot;vtkPlaneWidget.h&quot;
#include &quot;vtkCellDataToPointData.h&quot;
#include &quot;vtkAssembly.h&quot;
#include &quot;vtkImageGaussianSmooth.h&quot;

// irtk
#include &lt;irtkImage.h&gt;
#include &lt;irtkGaussianBlurring.h&gt;


#include &lt;irtkGeometry.h&gt;
#include &lt;irtkMatrix.h&gt;



// STLs
#include &lt;stack&gt;
#include &lt;vector&gt;


#include &lt;irtkEuclideanDistanceTransform.h&gt;


// file I/O
#include &lt;iostream&gt;
#include &lt;fstream&gt;

// my libs
#include &lt;saddlePointDetector.h&gt;
#include &lt;saddlePointDetector2.h&gt;
#include &lt;basicComponentMerge.h&gt;
#include &lt;pvLocator.h&gt;
#include &lt;morphologicalOperators.h&gt;
#include &lt;feigen.h&gt;
#include &lt;vesselFinder.h&gt;	
/*
#include &lt;vtkCubeSource.h&gt;
#include &lt;vtkXMLPolyDataWriter.h&gt;
#include &lt;vtkPolyDataWriter.h&gt;*/

// fltk
#include &lt;FL/Fl.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;
#include &lt;FL/Fl_Slider.H&gt;
#include &lt;FL/Fl_Output.H&gt;
#include &lt;FL/Fl_Menu_Item.H&gt;
#include &lt;FL/Fl_Menu_Bar.H&gt;
#include &lt;FL/Fl_File_Chooser.H&gt;
#include &lt;FL/Fl_Progress.H&gt;
#include &lt;FL/Fl_Text_Display.H&gt;
#include &lt;FL/Fl_Text_Buffer.H&gt;
#include &lt;FL/Fl_Check_Button.H&gt;
#include &lt;FL/Fl_Round_Button.H&gt;

// vtk 
#include &lt;vtkImageActor.h&gt;
#include &lt;vtkFlRenderWindowInteractor.h&gt;
#include &lt;vtkButterflySubdivisionFilter.h&gt;
#include &quot;vtkCellPicker.h&quot;

#include &quot;graphCutScarClassifier.h&quot;
#include &quot;ensiteToolBox.h&quot;
#include &quot;ensiteGraphicsToolBox.h&quot;
#include &quot;EndoSenseToolbox.h&quot;
#include &quot;VRMLFileReaderWriter.h&quot;
#include &quot;Encircler.h&quot;


#define _CONSTRAINED_THRESHOLDING 1				// must remember to set to 0 if you dont want constrained thresholding using box widgets
												// dotn comment it out 


#define _NUM_OF_ITERATIONS_FOR_TAUBIN_SMOOTHING 15		// for taubin smoother 
#define _IS_SPLIT_SCREEN 0
#define _OUTPUT_BLOOD_POOL_INTENSITIES 1			// writes blood pool intensities to file blood_pool_intensities.txt (in show_surface_normals function) 
#define _SCAR_AS_STANDARD_DEVIATION 1 
#define _NORMAL_MYOCARDIUM_USER_INPUT 1
#define _DECIMATE_ATRIAL_SURFACE 0			// set to 0 if analysing voltage map, will give too many polygons when set to 1 

#define _SCAR_MIP 1
#define _SCAR_INTEGRAL 0
#define _WRITE_NORMAL_PROFILE_TO_FILE 1			// normal profile, i.e. intensity values will be written to a file called profile_normals.txt. UPDATE AUG 2011: can't do this anymore, needs slight modifitification check code where this is iused

#define _USE_POINT_SCALARS 1				// to smooth the scalar data (of scar) displayed on shells (July 2011)
#define _IS_FANCY_REFLECTIVE_SHINY_MODEL 0	// to make the model look shiny by adding specular lighting 

#define _LUT_OVERRIDE 0 
#define _LUT_OVERRIDE_MIN 0
#define _LUT_OVERRIDE_MAX 3
#define _TOL 0.08			// tolerance for convergence of algorithm - less than 1% pixel count difference between consecutive iterations _gc_out 
											
#define _ONLY_POSITIVE_STDEVS 1		// REMEBER this is for only having positive sdevs in the output (write to vtk file). For visualization of only positive sdevs set SCAR_MIP and SCAR_AS_ADEV to 1 

vtkPolyDataMapper *sphereMapper, *voltageSurfaceMapper, *voltage2SurfaceMapper;
vtkActor *sphereActor, *sphereActor2, *sphereLocationMarker;
vtkActor *heart, *heart_copy, *scar_actor;
vtkActor *voltageMapActor;
vtkActor *halfPlaneActor;
vtkPointPicker *picker;
vtkPropPicker *picker2;
vtkRenderer *renderer1, *renderer2, *renderer3, *renderer4;
vtkRenderWindow *renWin1, *renWin2, *renWin3, *renWin4;
vtkImageMapToColors *sliceZColors, *sliceXColors, *sliceYColors;
vtkImageActor *ySlice, *xSlice, *zSlice;
vtkAxesActor* axes;
vtkOrientationMarkerWidget* orientationWidget, *orientationWidget2;


vtkActor **sphereActors;			// for plotting points 
vtkXYPlotActor *plotactor; 
vtkImageActor **imageActorArray;
vtkInteractorStyleTrackballCamera *interactorStyle1, *interactorStyle2, *interactorStyle3, *interactorStyle4;
vtkPlanes *box_1_plane, *box_2_plane;
vtkCamera *camera1, *camera2, *camera3;
vtkMarchingCubes* atrium_surface; 
vtkStructuredPoints *struct_points_data;
vtkBoxWidget *boxWidget, *boxWidget2, *voltageScarBoxWidget; 
vtkPlaneWidget *planeWidget;
vtkPlane* pl;
vtkPolyData* polys;			// the polygons of the segmentation surface

vector&lt;vtkPolyData*&gt; ensiteImportedGeometry; 
vector&lt;vtkActor*&gt; importedGeometry;

vtkFlRenderWindowInteractor *fl_vtk_window_1;
vtkFlRenderWindowInteractor *fl_vtk_window_2;
vtkFlRenderWindowInteractor *fl_vtk_window_3;

vtkFlRenderWindowInteractor *fl_vtk_window_4;		// the new window 
Fl_Window *xyplot_win;	// MAY2010: the xy plot window
Fl_Window *voltage_slider_win;	// MAY2010: the xy plot window
Fl_Window *isochrone_slider_win;
Fl_Window *scar_slider_win;
Fl_Window *peakarrival_slider_win;
Fl_Slider* low_threshold_selector, *high_threshold_selector, *at_body_distance_low_slider, *at_body_distance_high_slider;

vtkLookupTable *bwLut, *voltageLut;

// simple variables 
int zPos=0, yPos=10, xPos=10, screenX, screenY, maxX, maxY, maxZ, num_smoothing_iterations=_NUM_OF_ITERATIONS_FOR_TAUBIN_SMOOTHING;
int F_INDICATOR, B_INDICATOR; 
char buffer[10];
double _MAX_INTENSITY=0, low_threshold=-1, high_threshold=-1, max_scalar_value_in_edt = 0, max_scalar_value_in_bc_map=0, 
table_range_low=0, table_range_high=0, hue=0, saturation=0, mcubes_threshold=1, scar_threshold_value=0, low_distance_threshold=-1,high_distance_threshold=-1;
double scar_step_min=-3, scar_step_max=3, scar_step_size=1;			// scar_step_max goes inside atrium!
double f_mean, f_var, b_mean, b_var;
double max_scalar_in_scar; 

double _scar_model_mean, _scar_model_stdev; 
int _scar_auto_seg_iterations;

double picker2_pos[3];
int label_range[2];

char *dir_path, *segmented_image_file_name=0, *file_extensions, *at_body_file_name;

bool isSegmentedImageDisplayed = false,  boxWidgetIsOn = false, isActorSuperImposed = false, isOrthoPlaneViewedFirstTime = true, scarDisplayed = false, graphCutIsFirstTime=true, voltageScarBoxWidgetIsOn=false;

irtkRealImage input, mri_data, scar_thresh, at_body_segmented, distance_image, class_labels, masked_le, pixelsInMIP, edtOfAtriumShell, boundaryOfAtriumShell, surfaceNormalBand, blankImage; 
irtkBSplineInterpolateImageFunction&lt;irtkRealPixel&gt; scar_interp; 

graphCutClassifier classifier;
EnsiteAdapter ensite; 
EnsiteGraphicsAdapter ensiteGraphics; 
EndoSenseToolbox endosense; 
VRMLandVTKFileReaderWriter *vrml_rw;

string filename_seg_input = &quot;mri_auto_seg.hdr&quot;;		//the result of automatic segmentation
string filename_edt = &quot;mri_auto_seg_edt.hdr&quot;; 
string filename_first_seg = &quot;mri_seg.hdr&quot;;			//the result of region-growing step
string filename_seg_edt = &quot;mri_edt.hdr&quot;; 
string filename_ridge_file = &quot;firstRidge.txt&quot;; 
string filename_vesselness = &quot;mri_vssl.nii&quot;; 
string filename_at_body = &quot;mri_at_body_edt.nii&quot;;
string filename_ridgeness = &quot;mri_ridgeness.nii&quot;; 
string filename_bcmap = &quot;mri_bcmap.hdr&quot;; 


// callback prototypes
void xSlice_selector_cb(Fl_Widget* widget, void*); 
void zSlice_selector_cb(Fl_Widget* widget, void*);
void ySlice_selector_cb(Fl_Widget* widget, void*);
void lookUpTable_selector_cb(Fl_Widget* widget, void*);
void opacity_selector_for_z_slice_cb(Fl_Widget* widget, void* p);
void high_threshold_selector_cb(Fl_Widget* widget, void* p	); 
void low_threshold_selector_cb(Fl_Widget* widget, void* p	);
void opacity_selector_cb(Fl_Widget* widget, void* p);
void quit_cb(Fl_Widget*, void*); 
void open_segmented_cb(Fl_Widget* w, void* vptr); 
void open_scar_cb(Fl_Widget* w, void* vptr); 
void keyPressedFunction(vtkObject* obj, unsigned long,void *sr, void *); 
void superimpose_cb(Fl_Widget*, void*);
void redraw_scar_cb(Fl_Widget*, void* v);
void compute_graphcut_segmentation(Fl_Widget* w, void* v);
void render_scar(); 
void showOrthoPlanes(); 
void threshold_scar(); 

void init(); 
void destroy(); 

/*************************************************************
* MAY 2010: For votlage map sliders and voltage maps in general  
**************************************************************/
double currHueForV=0.3, currMaxV=0.05, currPtInfl;		
double maxV=4.0, maxH=0.9, maxPtInfl=100;
vector&lt;vtkIdType&gt; voltageNodeList; 
vtkPolyDataMapper *isochroneMapper ; 
vtkActor* isochroneActor; 
vtkLookupTable* isochroneLut; 
vector&lt;double&gt; voltageTraceIsochrone;
double currISOTime=0, currISOScalar=0.001, currISOHue=0.3, currISOPtInfl=5.0;
double maxISOTime=50, maxISOScalar=0.01, maxISOHue=0.8, maxISOPtInfl=100, minISOScalar=-0.001;
bool isVoltageDataLoaded= false; 
bool isISOTimeSliderTouched=false; 
vtkActor** isochroneActors;
vtkLookupTable** isochroneLuts; 
int prev_iso_actor_index;
bool isShowScarActor = true;
vtkScalarBarActor* scalarBarForVoltage; 
vtkScalarBarActor* scalarBarForIsochrone; 
bool isLeftButtonHeld=false, isAllowSync=false;
double currStdDevForVoltage, currdistThreshForVoltage; 
double maxStdDevForVoltage=25.0, maxdistThreshForVoltage=20.0; 
int maxkNearestForVoltage=20, currkNearestForVoltage; 
bool isNoVoltageActorPresent=false; 

/***********************************************************
* MAY 2010: For scar maps UI 
**************************************************************/
double maxScarHue=1.0, maxScarScalar=5.0;
double currHueForScar, currScalarForScar;
vtkLookupTable* Scarlut;
vtkScalarBarActor* scalarBarForScar; 
ofstream _debugOutput;

/******************************************************************
* MAT 2010: Thresholding scars and exporting scar surfaces for ensite 
********************************************************************/
vtkPolyData* thresholdedScar; 
vtkActor* thresholdedScarActor; 
bool isThresholdScarActorDisplayed=false, isScarAppear=false;
double thresholdt2, thresholdt1;

/************************************************************
* FOR peak arrival time 
************************************************************/
double maxPeakArrivalHue=0.9, maxPeakArrivalScalar, currPeakArrivalHue, currPeakArrivalScalar; 
vtkPolyData* polys_2, *polys_3, *polys_4, *polys_5, *polys_6, *polys_7;
vtkActor* peakTimeActor, *peakTimeContourActor, *noVoltageActor; 
vtkActor2D* peakTimeContourLabels; 
vtkLookupTable* peakTimeLut;
vtkScalarBarActor* peakTimeScalarBar; 
int curr_display_status=-1; 
vtkTextActor* winStats; 
bool labelOn = false; 
vtkCellLocator* cell_locator; 
bool isCellLocatorComputed = false; 
vector&lt;vtkFollower*&gt; contour3DLabels; 

int recursive_neighbour_order=5, cellIdProbed=100;
double voltage_threshold=0;

bool isRadiologicallyOriented = false; 

/************************************
*
* For new ostial diameter computation 
*
*************************************/
vector&lt;irtkPoint*&gt; intersec_points_container, best_fit_ellipse_points_container, max_diam_range, min_diam_range;
double ellipse_a, ellipse_b, max_diameter, min_diameter, mean_diameter, circumference, 	ellipse_circumference;
vtkActor* bestFitEllipseActor;
bool PlaneWidgetPlaced=false; 

/********************************************
*	For scar binary segmentation 
*	and its projection on cardiac surface
**********************************************/
vtkActor* scarProjectionActor; 
bool isScarProjectActorShowing=false; 

/**********************************************
*	For assessing voltage-scar correlation 
*	on a region of interest defined by a bounding box 
**********************************************/
bool isCroppedGeometryDisplayPreviously=false;  
int toggleScarVoltageROI = 1;
vtkActor *croppedGeomActor_Scar, *croppedGeomActor_Voltage;
vtkPolyData* clippedPoly_Scar, *clippedPoly_Voltage; 
irtkGreyImage blood_pool;

/********************************************************
*	AT KCL, for saving thresholded surface polydata
**********************************************************/
vtkThreshold* thresholder;
double myo_mean, myo_stdev;
bool isNormalMyocardiumComputed = false; 
double _max_std_dev_in_scar=5.0; 
ofstream normalFileWriteStream;

/***********************
*	For Endosense FTI maps
************************/
vector&lt;vtkIdType&gt; _pointsInPolyWithFTI;
bool _e1=false, _e2=false, _e3=false, _e4=false, _e5=false, _onlyPrimaryPoints=true;
char* _efti, *_eAB, *_eSurf, *_output; 
double _et=5;
int _EndosenseInterpolationType = 1;			// by default constant interpolation, see EndosenseToolbox

// for loading multiple shells for endosense FTI analysis (29 April 2011) 
vector&lt;vtkPolyData* &gt; n_polydata; 
vtkActor* firstShellActor; 


// @kcl for writing normal profiles to file for PCA test
void getProfilesToFile(double* vals, int size, ofstream&amp; out);
vtkSmartPointer&lt;vtkPolyData&gt; _scar_stdev_poly, _scar_multiplier_poly, _scar_original_poly; 

/*********************************
*	command line args June 2011
*********************************/
char* _input_f1, *_input_f2, *_surf_input=&quot;&quot;; 

int useAtlasMode;
bool benAutoMode;


/******************************
*	For hafiz measuring angles 
*******************************/

int angle_point_num;
double** selected_angle_points; 
vtkCellPicker* cell_picker;		
vtkActor *sphereActor3;			// for marking angle points 
vtkSphereSource* sphere3; 
vtkPolyDataMapper *sphereMapper3;

vtkActor *sphereActor4;			// for showing LA centroid 
vtkSphereSource* sphere4; 
vtkPolyDataMapper *sphereMapper4;

vtkActor *sphereActor5;			// for showing LA centroid 
vtkSphereSource* sphere5; 
vtkPolyDataMapper *sphereMapper5;
double LA_centroid[3], angle_point_1[3], angle_point_2[3];
bool isCentroidComputed, angle_relative_position_reset;

/****
*	For converting cell data to point data
*/
void CellDataToPointData(vtkPolyData* cell_poly, vtkPolyData* point_poly); 

/*******************
*	For encircler
**********************/
Scar3DTools* enc; 
Scar3DTools* tools; 


bool isShellOn, isXSliceOn, isYSliceOn, isZSliceOn;


irtkEuclideanDistanceTransform&lt;irtkRealPixel&gt; *edtTransformer; 

double _setUserWorkingMean, _setUserWorkingVar;

bool isScarNormalExtentChanged;

bool isImageFolderSet;
vtkSmartPointer&lt;vtkPolyData&gt; LA_surface_poly;
&lt;/pre&gt;</textarea><div class='templatesUsed'>

</div>
<p>Return to <a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6" title="Scar3d v6">Scar3d v6</a>.</p>
<div class="printfooter">
Retrieved from "<a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6">http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Talk:Scar3d_v6&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource" class="selected"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-anonuserpage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User:159.92.151.128" title="The user page for the ip you&#039;re editing as [.]" accesskey="." class="new">159.92.151.128</a></li>
				<li id="pt-anontalk"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=User_talk:159.92.151.128" title="Discussion about edits from this IP address [n]" accesskey="n" class="new">Talk for this IP</a></li>
				<li id="pt-anonlogin"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:UserLogin&amp;returnto=Scar3d_v6" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/images/myWikiLogo.gif);" href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Research_Wiki">Main Page</a></li>
				<li id="n-Home"><a href="http://www.doc.ic.ac.uk/~rkarim/">Home</a></li>
				<li id="n-currentevents"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Rashed Karim Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:WhatLinksHere/Scar3d_v6" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:RecentChangesLinked/Scar3d_v6" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="privacy"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:Privacy_policy" title="Rashed Karim Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:About" title="Rashed Karim Wiki:About">About Rashed Karim Wiki</a></li>
					<li id="disclaimer"><a href="http://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Rashed_Karim_Wiki:General_disclaimer" title="Rashed Karim Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.450 secs. --></body>
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Scar3d_v6&action=edit by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:48:30 GMT -->
</html>
