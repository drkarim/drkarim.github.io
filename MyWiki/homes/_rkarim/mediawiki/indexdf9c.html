<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Carto_fuse_v2a&printable=yes by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:43:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15.1" />
		<meta name="robots" content="noindex,follow" />
		<meta name="keywords" content="Carto fuse v2a" />
		<link rel="shortcut icon" href="https://wwwhomes.doc.ic.ac.uk/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.html" title="Rashed Karim Wiki (en)" />
		<link rel="alternate" type="application/rss+xml" title="Rashed Karim Wiki RSS Feed" href="index2ffe.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Rashed Karim Wiki Atom Feed" href="index890f.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Carto fuse v2a - Rashed Karim Wiki</title>
		<link rel="stylesheet" href="skins/common/commonPrint69ad.css?207" type="text/css" />
		<link rel="stylesheet" href="index31a6.css?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="index663f.css?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="index6e6d.css?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000" type="text/css" />
		<link rel="stylesheet" href="indexd70f.css?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/~rkarim/mediawiki/skins/common/IEFixes.js?207"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/~rkarim/mediawiki/skins";
		var wgArticlePath = "indexafc5.html?title=$1";
		var wgScriptPath = "/~rkarim/mediawiki";
		var wgScript = "indexb3c9.html";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "https://wwwhomes.doc.ic.ac.uk/";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Carto_fuse_v2a";
		var wgTitle = "Carto fuse v2a";
		var wgAction = "view";
		var wgArticleId = "458";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 3973;
		var wgVersion = "1.15.1";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="skins/common/wikibits69ad.js?207"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="skins/common/ajax69ad.js?207"></script>
		<script type="text/javascript" src="index6e36.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Carto_fuse_v2a skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 id="firstHeading" class="firstHeading">Carto fuse v2a</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Rashed Karim Wiki</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p><i><a href="index6260.html?title=Carto_fuse" class="external text" title="https://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Carto_fuse" rel="nofollow">Back to other version</a></i>
</p>
<a name="Introduction" id="Introduction"></a><h2> <span class="mw-headline"> Introduction </span></h2>
<p>The new Cartofuse with the following capabilities:
</p>
<ul><li> Specify threshold for both source and target
</li><li> Displays binarized color map shells
</li></ul>
<p>The following options are now available as command-line parameters
</p>
<ul><li> -source N (source shell threshold as N)
</li><li> -target N (target shell threshold as N)
</li><li> --colors  (displays binarized color maps)
</li><li> --nd (expects target shell to be multi array-ed)
</li></ul>
<p>For example typing the following command:
</p>
<pre>cartofuse.exe -source 200 -target 0.1 --colors x --nd x</pre>
<p>Will enable a threshold for source and target shells at 200 and 0.1
respectively. Additionally the --nd and --colors switches will enable
multi-array target shells and binarized color maps.
</p>
<a name="Code" id="Code"></a><h1> <span class="mw-headline"> Code </span></h1>
<a name="Header" id="Header"></a><h2> <span class="mw-headline"> Header </span></h2>
<pre>
#define HAS_VTK 1
#include &quot;vtkRenderer.h&quot;
#include &quot;vtkRenderWindow.h&quot;
#include &quot;vtkRenderWindowInteractor.h&quot;
#include &lt;vtkPiecewiseFunction.h&gt;
#include &lt;vtkColorTransferFunction.h&gt;
#include &lt;vtkVolumeProperty.h&gt;
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include &lt;vtkVolumeRayCastMIPFunction.h&gt;
#include &lt;vtkVolumeRayCastMapper.h&gt;
#include &lt;vtkVolume.h&gt;
#include &lt;vtkVolumeTextureMapper2D.h&gt;
#include &lt;vtkImageReader.h&gt;
#include &lt;vtkImageImport.h&gt;
#include &lt;vtkImageCast.h&gt;
#include &lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include &lt;vtkStructuredPoints.h&gt;
#include &lt;vtkStructuredGrid.h&gt;
#include &lt;vtkFloatArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &quot;vtkPointData.h&quot;
#include &lt;vtkPointPicker.h&gt;
#include &lt;vtkCommand.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkContourFilter.h&gt;
#include &lt;vtkPolyDataNormals.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkMarchingCubes.h&gt;
#include &lt;vtkVectorNorm.h&gt;
#include &lt;vtkDataSetMapper.h&gt;
#include &lt;vtkImageToPolyDataFilter.h&gt;
#include &lt;vtkPolyDataReader.h&gt;
#include &lt;vtkLookupTable.h&gt;
#include &lt;vtkSphereSource.h&gt;
#include &lt;vtkCallbackCommand.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkImagePlaneWidget.h&gt;
#include &lt;vtkImageActor.h&gt;

#include &lt;vtkImageMapToColors.h&gt;
#include &lt;vtkInteractorStyleTrackballCamera.h&gt;
#include &lt;vtkInteractorStyleFlight.h&gt;
#include &lt;vtkPropPicker.h&gt;
#include &lt;vtkBoxWidget.h&gt;
#include &lt;vtkPlanes.h&gt;
#include &lt;vtkRendererCollection.h&gt;
#include &lt;vtkWindowedSincPolyDataFilter.h&gt;
#include &lt;vtkDiscreteMarchingCubes.h&gt;
#include &lt;vtkImageThreshold.h&gt;
#include &lt;vtkWindowToImageFilter.h&gt;
#include &lt;vtkAVIWriter.h&gt;
#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkOBJExporter.h&gt;
#include &lt;vtkMaskPoints.h&gt;
#include &lt;vtkConeSource.h&gt;
#include &lt;vtkCellData.h&gt;
#include &lt;vtkTriangle.h&gt;
#include &lt;vtkThreshold.h&gt;
#include &lt;vtkDataSetSurfaceFilter.h&gt;
#include &lt;vtkTextActor.h&gt;
#include &lt;vtkTextProperty.h&gt;
#include &lt;vtkCellLocator.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &quot;vtkGenericCell.h&quot;
#include &quot;vtkOrientationMarkerWidget.h&quot;
#include &quot;vtkAxesActor.h&quot;
#include &quot;vtkAnnotatedCubeActor.h&quot;
#include &quot;vtkPropAssembly.h&quot;
#include &quot;vtkPlaneWidget.h&quot;
#include &quot;vtkCellPicker.h&quot;
#include &quot;vtkLandmarkTransform.h&quot;
#include &lt;vtkMatrix4x4.h&gt;
#include &lt;vtkTransformPolyDataFilter.h&gt;
#include &lt;vtkIterativeClosestPointTransform.h&gt;

// fltk
#include &lt;FL/Fl.H&gt;
#include &lt;FL/Fl_Window.H&gt;
#include &lt;FL/Fl_Button.H&gt;
#include &lt;FL/Fl_Slider.H&gt;
#include &lt;FL/Fl_Output.H&gt;
#include &lt;FL/Fl_Menu_Item.H&gt;
#include &lt;FL/Fl_Menu_Bar.H&gt;
#include &lt;FL/Fl_File_Chooser.H&gt;
#include &lt;FL/Fl_Progress.H&gt;
#include &lt;FL/Fl_Text_Display.H&gt;
#include &lt;FL/Fl_Text_Buffer.H&gt;
#include &lt;FL/Fl_Check_Button.H&gt;
#include &lt;FL/Fl_Round_Button.H&gt;
#include &lt;FL/Fl_Group.H&gt;
#include &lt;FL/Fl_Text_Display.H&gt;
#include &lt;FL/Fl_Text_Buffer.H&gt;


#include &lt;irtkImage.h&gt;
#include &lt;vtkFlRenderWindowInteractor.h&gt;

#define _IS_SPLIT_SCREEN 0


#define _ENCIRCLEMENT_CONTROLS 1		// the sliders and control buttons for encirclement computations 

// mylibs 
#include &lt;Encircler.h&gt;
#include &lt;iblSurfaceUnfold.h&gt;
#include &lt;iblVTKAdapters.h&gt;


// literal types
char* dir_path; 
float screenX, screenY;
double* pick_position;
bool isEncirclementPointPicked;
int _flip;

double xPos=0,yPos=0, zPos=0;
double im_maxX, im_maxY, im_maxZ;
double xyz_plane_picker_pos[3]; 
bool isXSliceOn, isYSliceOn, isZSliceOn; 

vtkRenderWindow* renWin1;
vtkRenderWindow* renWin2;
vtkRenderWindow* renWin3;


vtkRenderer* renderer1; 
vtkRenderer* renderer2; 
vtkRenderer* renderer3; 

vtkImageActor* xSlice;
vtkImageActor* ySlice;
vtkImageActor* zSlice;

vtkInteractorStyleTrackballCamera* interactorStyle1; 
vtkInteractorStyleTrackballCamera* interactorStyle2;
vtkInteractorStyleTrackballCamera* interactorStyle3;

vtkCamera* camera1; 
vtkCamera* camera2;
vtkCamera* camera3;


Encircler* enc; 	
iblSurfaceUnfold* unfold;
 
vtkFlRenderWindowInteractor *fl_vtk_window_1;
vtkFlRenderWindowInteractor *fl_vtk_window_2;
vtkFlRenderWindowInteractor *fl_vtk_window_3;

vtkPointPicker *point_picker; 
vtkPropPicker *xyz_plane_picker; 
vtkCellPicker *cell_picker, *cell_picker2; 

vtkImageActor** XYZSliceArray;

irtkRealImage* im1; 

vtkActor* xyzPlanePickerSphere;

ofstream points_out; 

typedef enum CONFIG_SYSTEM_SETTING
{
	DEFAULT_SETTING = 1, 
	USE_FOR_CARTO_REGISTRATION = 2
} CONFIG_SYSTEM_SETTING;

typedef enum SCREEN_STYLE
{
	DEFAULT_SPLIT_SCREEN = 1, 
	REGISTRATION_SURFACE_SPLIT_SCREEN = 2
} SCREEN_STYLE;


/********************************
*	All functions go here
*********************************/
void create_window(vtkFlRenderWindowInteractor *&amp;flrwi_1, vtkFlRenderWindowInteractor *&amp;flrwi_2, vtkFlRenderWindowInteractor *&amp;flrwi_3,
				   vtkInteractorStyleTrackballCamera *interactorStyle1, vtkInteractorStyleTrackballCamera *interactorStyle2, vtkInteractorStyleTrackballCamera *interactorStyle3, 
				    Fl_Window *&amp;flw, char* title, SCREEN_STYLE sty);
void init(SCREEN_STYLE s); 
void destroy();

// GUI stuff
void encirclementControls(Fl_Window *&amp;flw);
void reigstrationControls(Fl_Window *&amp;flw);

// callbacks 
void keyPressedFunction_window1(vtkObject* obj, unsigned long,void *sr, void *);
void keyPressedFunction_window2(vtkObject* obj, unsigned long,void *sr, void *);
void open_LA_shell_cb(Fl_Widget*, void* v); 
void zSlice_selector_cb(Fl_Widget* widget, void*); 
void ySlice_selector_cb(Fl_Widget* widget, void*); 
void xSlice_selector_cb(Fl_Widget* widget, void*); 
void quit_cb(Fl_Widget*, void*);	

void enc_neighbourhood_change_cb(Fl_Widget*, void* v);			/*	Encirclement computation callbacks				*/
void enc_threshold_change_cb(Fl_Widget*, void*);
void encirclement_computebutton_cb(Fl_Widget*, void*);
void encirclement_reset_cb(Fl_Widget*, void*);
void open_img_as_ortho_cb(Fl_Widget*, void* v);
void slice_onoff(Fl_Widget*, void*);
void writePickedPointsToFile_cb(Fl_Widget*, void* v);


void open_LA_shells_for_carto_cb(Fl_Widget*, void*);
void open_2nd_shell_cb(Fl_Widget*, void* v);
void hide2ndShell_cb(Fl_Widget*, void* v);
void cartoShell_transparency_cb(Fl_Widget*, void*); 
void turnBoxWidgetOnOff_cb(Fl_Widget*, void*);
void setROI_cb(Fl_Widget*, void*);
void landmarkRegistration_cb(Fl_Widget*, void*);
void icpAfterLandmarkRegistration_cb(Fl_Widget*, void*);
void transferDataToTarget_cb(Fl_Widget*, void*);
void export_target_shell_cb(Fl_Widget*, void*);
void export_finalTransformedSource_shell_cb(Fl_Widget*, void*);


// Carto handlers
iblVTKAdapters* carto1, *carto2; 
vtkPolyData* sourcePolyhedron, *targetPolyhedron, *targetPolyhedron_ND, *sourcePolyhedron_copy;
vtkActor* targetPolyhedronActor, *sourcePolyhedronActor;
vtkBoxWidget *targetBox, *sourceBox;
bool boxesAreOff, isOnlyLandmark, isICP;
vtkSmartPointer&lt;vtkPoints&gt; sourcePoints_lmreg;			// the source point set for landmark registration
vtkSmartPointer&lt;vtkPoints&gt; targetPoints_lmreg;			// the target point set for landmark registration
Fl_Text_Buffer *ptDisplayBuffer;
Fl_Text_Display *lmrkPtDisp;
int lmp_count;
vector&lt;vtkActor*&gt; lmPtActorsTarget, lmPtActorsSource; 
vtkSmartPointer&lt;vtkActor&gt; sphereActorTarget,sphereActorSource, transformedSourceActor, transformedSourceActor_postICP, targetPolyhedronWithSourceDataActor;
vtkSmartPointer&lt;vtkPolyData&gt; transformedSourcePolyhedron, transformedSourcePolyhedron_postICP, targetPolyhedron_WithSourceData;


// Unfolding 
vtkActor* referenceSurfaceActor; 
bool is2ndReferenceActorShowing;
int pointsPickedFileNum;
int pointsPickedCounter;
int indexOfLastPointWrittenToFile;


// new for henry 
double targetPoly_scalar_threshold=0, sourcePoly_scalar_threshold=0; 
bool isMultiPointDataArray = false; 
bool isDisplayColorMap = false; 
</pre>
<a name="Source" id="Source"></a><h2> <span class="mw-headline"> Source </span></h2>
<pre>
#include &quot;rkapp1.h&quot;

int main (int argc, char* argv[])
{
	bool foundArgs = false; 
	//CONFIG_SYSTEM_SETTING config_setting = DEFAULT_SETTING; 
	CONFIG_SYSTEM_SETTING config_setting = USE_FOR_CARTO_REGISTRATION;
	if (argc &gt;= 1)
	{
		for (int i = 1; i &lt; argc; i++) {
			if (i + 1&nbsp;!= argc) { 
				 if (string(argv[i]) == &quot;-w&quot;) {
					dir_path = argv[i+1]; 
					foundArgs = true;
				 }

				 if (string(argv[i]) == &quot;-target&quot;) {
					targetPoly_scalar_threshold = atof(argv[i+1]);
					foundArgs = true;
				 }

				 if (string(argv[i]) == &quot;-source&quot;) {
					sourcePoly_scalar_threshold = atof(argv[i+1]); 
					foundArgs = true;
				 }
				 if (string(argv[i]) == &quot;--colors&quot;) {
					isDisplayColorMap = true; 
					foundArgs = true;
				 }
				 if (string(argv[i]) == &quot;--nd&quot;) {
					isMultiPointDataArray = true; 
					foundArgs = true;
				 }
			}
		}
	}
	dir_path = &quot;.&quot;;
	Fl_Window *main_window = NULL;
	
	switch (config_setting) 
	{
		case USE_FOR_CARTO_REGISTRATION: 
			init(REGISTRATION_SURFACE_SPLIT_SCREEN);
			create_window(fl_vtk_window_1, fl_vtk_window_2, fl_vtk_window_3,
		interactorStyle1, interactorStyle2, interactorStyle3,  main_window,&quot;Unfold 3D&nbsp;:: Rashed karim (c) 2011&quot;, REGISTRATION_SURFACE_SPLIT_SCREEN);
		break; 
		
		case DEFAULT_SETTING: 
			init(DEFAULT_SPLIT_SCREEN);
			create_window(fl_vtk_window_1, fl_vtk_window_2, fl_vtk_window_3,
		interactorStyle1, interactorStyle2, interactorStyle3,  main_window,&quot;Unfold 3D&nbsp;:: Rashed karim (c) 2011&quot;, DEFAULT_SPLIT_SCREEN);
		break; 
	}
	

	main_window-&gt;show();
	fl_vtk_window_1-&gt;show();
	fl_vtk_window_2-&gt;show();
	fl_vtk_window_3-&gt;show();

	renderer1-&gt;SetBackground(0.22,0.23,0.32);	// this is the preferred background color (violet)
	//renderer1-&gt;SetBackground(1,1,1);	
	renWin1-&gt;AddRenderer(renderer1);
	fl_vtk_window_1-&gt;SetRenderWindow(renWin1);

	renderer2-&gt;SetBackground(0.22,0.23,0.32);
	renWin2-&gt;AddRenderer(renderer2);
	fl_vtk_window_2-&gt;SetRenderWindow(renWin2);

	renderer3-&gt;SetBackground(0.22,0.23,0.32);	
	renWin3-&gt;AddRenderer(renderer3);
	fl_vtk_window_3-&gt;SetRenderWindow(renWin3);

	
	fl_vtk_window_1-&gt;Initialize();
	fl_vtk_window_2-&gt;Initialize();
	fl_vtk_window_3-&gt;Initialize();
	
	// point pickers (they must go here after everything has been initialized)
	point_picker = vtkPointPicker::New();
	point_picker-&gt;SetTolerance(0.005); 
	fl_vtk_window_1-&gt;SetPicker(point_picker); 

	// point pickers (they must go here after everything has been initialized)
	cell_picker = vtkCellPicker::New();
	cell_picker-&gt;SetTolerance(0.005); 
	fl_vtk_window_1-&gt;SetPicker(cell_picker); 

	cell_picker2 = vtkCellPicker::New();
	cell_picker2-&gt;SetTolerance(0.005); 
	fl_vtk_window_2-&gt;SetPicker(cell_picker2);
	
	
	//points_out.open(&quot;points_selected.txt&quot;, ios::app); 
	int fl_ret = Fl::run();

	return fl_ret;
}

void init(SCREEN_STYLE style)
{
	renWin1 = vtkRenderWindow::New();
	renWin2 = vtkRenderWindow::New();
	renWin3 = vtkRenderWindow::New();
	
	renderer1 = vtkRenderer::New();
	renderer2 = vtkRenderer::New();
	renderer3 = vtkRenderer::New();
	
	xSlice = vtkImageActor::New();
	ySlice = vtkImageActor::New();
	zSlice = vtkImageActor::New();
	
	interactorStyle1 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle2 = vtkInteractorStyleTrackballCamera::New();
	interactorStyle3 = vtkInteractorStyleTrackballCamera::New();
	
	camera1 = vtkCamera::New();
	camera2 = vtkCamera::New();
	camera3 = vtkCamera::New();

	// some literals 
	isEncirclementPointPicked = false; 
	_flip=1;

	xyz_plane_picker = vtkPropPicker::New();
	
	isXSliceOn = true; isYSliceOn = true; isZSliceOn = true; 
	pointsPickedFileNum = 0;
	pointsPickedCounter = 0;
	indexOfLastPointWrittenToFile=0;
	

	if (style == REGISTRATION_SURFACE_SPLIT_SCREEN)
	{
		carto1 = new iblVTKAdapters(); 
		carto2 = new iblVTKAdapters();

		targetPolyhedron = vtkPolyData::New(); 
		targetPolyhedron_ND = vtkPolyData::New();
		sourcePolyhedron = vtkPolyData::New(); 
		sourcePolyhedron_copy = vtkPolyData::New(); 

		targetPolyhedronActor = vtkActor::New(); 
		sourcePolyhedronActor = vtkActor::New(); 

		targetBox = vtkBoxWidget::New();
		sourceBox = vtkBoxWidget::New();

		targetBox-&gt;SetProp3D(ySlice);	// appears on z slice, but can be moved using interactor other slices
		targetBox-&gt;SetPlaceFactor(40.0);
		targetBox-&gt;PlaceWidget();

		sourceBox-&gt;SetProp3D(ySlice);	// appears on z slice, but can be moved using interactor other slices
		sourceBox-&gt;SetPlaceFactor(40.0);
		sourceBox-&gt;PlaceWidget();
		boxesAreOff = true;
		
		sourcePoints_lmreg = vtkSmartPointer&lt;vtkPoints&gt;::New();
		targetPoints_lmreg = vtkSmartPointer&lt;vtkPoints&gt;::New();
		
		lmp_count = 0;		// counter to keep track of points selected for landmark registration
		isOnlyLandmark = false; 
		isICP = false; 
	}
}

void destroy()
{
	renWin1-&gt;Delete();
	renWin2-&gt;Delete();
	renWin3-&gt;Delete();
	
	renderer1-&gt;Delete();
	renderer2-&gt;Delete();
	renderer3-&gt;Delete();
	
	xSlice-&gt;Delete();
	ySlice-&gt;Delete();
	zSlice-&gt;Delete();
	
	interactorStyle1-&gt;Delete();
	interactorStyle2-&gt;Delete();
	interactorStyle3-&gt;Delete();

	camera1-&gt;Delete();
	camera2-&gt;Delete();	
	camera3-&gt;Delete();
	
	
}


void ConvertMultiDimensionalForceShell(vtkPolyData* in_poly, vtkPolyData* out_poly)
{
	int n, k=-1; 
	out_poly-&gt;CopyStructure(in_poly); 
	
	vtkIdType numberOfPointArrays = in_poly-&gt;GetPointData()-&gt;GetNumberOfArrays();

	for(vtkIdType i = 0; i &lt; numberOfPointArrays; i++)
    {
		cout &lt;&lt; &quot;Array &quot; &lt;&lt; i &lt;&lt; &quot;, name = &quot; &lt;&lt; in_poly-&gt;GetPointData()-&gt;GetArray(i)-&gt;GetName() &lt;&lt; endl;
		if (strcmp(in_poly-&gt;GetPointData()-&gt;GetArray(i)-&gt;GetName(), &quot;Force1000&quot;) == 0) {
			cout &lt;&lt; &quot;Found array at location &quot; &lt;&lt; i &lt;&lt; endl;
			k = i; 
		}
	}

	if (k==-1) k = 0;
	
	vtkSmartPointer&lt;vtkFloatArray&gt; scalars = vtkSmartPointer&lt;vtkFloatArray&gt;::New(); 
	scalars = vtkFloatArray::SafeDownCast(in_poly-&gt;GetPointData()-&gt;GetArray(k));
	
	out_poly-&gt;GetPointData()-&gt;SetScalars(scalars); 

	
	
}

void encirclementControls(Fl_Window *&amp;flw) 
{
	// sliders
	int slider2_x=900, slider2_y=650, slider2_h=20, slider2_w=100, slider2_sep=30; 
	int num_sliders=2; 
	Fl_Slider* enc_neighbourhood_selector = new Fl_Slider(slider2_x, slider2_y+0, slider2_w, slider2_h, &quot;width&quot;);
	Fl_Slider* enc_threshold_selector = new Fl_Slider(slider2_x, slider2_y+slider2_sep+slider2_h, slider2_w, slider2_h, &quot;threshold&nbsp;%&quot;);

	enc_neighbourhood_selector-&gt;type(FL_HORIZONTAL);
	enc_threshold_selector-&gt;type(FL_HORIZONTAL);

	// buttons
	int button_x=slider2_x, button_y=slider2_y+(num_sliders*(slider2_sep+slider2_h)), button_h=20, button_w=70, button_sep=20;
	Fl_Button* computeBut = new Fl_Button(button_x, button_y, button_w, button_h, &quot;&amp;Encircle&quot;);
	Fl_Button* resetBut = new Fl_Button(button_x+(button_w+button_sep), button_y, button_w, button_h, &quot;&amp;Reset&quot;);
	Fl_Button* tempBut = new Fl_Button(button_x+(button_w+button_sep), button_y+button_h+5, button_w+10, button_h, &quot;&amp;TempFunc&quot;);
	Fl_Button* tempBut2 = new Fl_Button(button_x+(button_w+button_sep), button_y+(button_h*2)+5, button_w+10, button_h, &quot;&amp;TempFunc2&quot;);

	// textbox 
	int textbox_y=slider2_y, textbox_x=slider2_x+slider2_w+20, textbox_w=40, textbox_h=20;
	Fl_Output* enc_neighbourhood_selector_TXB = new Fl_Output(textbox_x, textbox_y, textbox_w, textbox_h);
	Fl_Output* enc_threshold_selector_TXB = new Fl_Output(textbox_x, textbox_y+slider2_sep+slider2_h, textbox_w, textbox_h);

	// callbacks
	enc_neighbourhood_selector-&gt;callback(enc_neighbourhood_change_cb, enc_neighbourhood_selector_TXB);
	enc_threshold_selector-&gt;callback(enc_threshold_change_cb, enc_threshold_selector_TXB);
	computeBut-&gt;callback(encirclement_computebutton_cb, NULL); 
	resetBut-&gt;callback(encirclement_reset_cb, NULL); 
	tempBut-&gt;callback(hide2ndShell_cb, NULL);
	tempBut2-&gt;callback(writePickedPointsToFile_cb, NULL);

	computeBut-&gt;callback(); 
	resetBut-&gt;callback();
}

void reigstrationControls(Fl_Window *&amp;flw) 
{
	int x=875, y=65, size_x=100, size_y=200, but_size_x = 100, but_size_y=30, but_sep=5; 
	Fl_Group* regButtonGroup = new Fl_Group(x, y, size_x, size_y, &quot;Registration&quot;); 
	Fl_Button* regBox_onoff = new Fl_Button(x+20, y+(but_sep*1), but_size_x, but_size_y, &quot;ROI-BOX&quot;); 
	Fl_Button* set_roi = new Fl_Button(x+20, y+but_size_y+(but_sep), but_size_x, but_size_y, &quot;Set-ROI&quot;); 
	Fl_Button* register_landmark = new Fl_Button(x+20, y+(but_size_y*2)+(but_sep), but_size_x, but_size_y, &quot;LndMrk-Reg&quot;); 
	Fl_Button* register_ICP = new Fl_Button(x+20, y+(but_size_y*3)+(but_sep), but_size_x, but_size_y, &quot;ICP-Reg&quot;); 
	Fl_Button* transferDataToTarget = new Fl_Button(x+20, y+(but_size_y*4)+(but_sep), but_size_x, but_size_y, &quot;DataToTarget&quot;); 
	regBox_onoff-&gt;callback(turnBoxWidgetOnOff_cb, NULL); 
	
	set_roi-&gt;callback(setROI_cb, NULL); 
	register_landmark-&gt;callback(landmarkRegistration_cb, NULL); 
	register_ICP-&gt;callback(icpAfterLandmarkRegistration_cb, NULL);
	transferDataToTarget-&gt;callback(transferDataToTarget_cb,NULL); 
	regButtonGroup-&gt;end(); 

	x=1020; y=65; 
	int slider_size_x = 30, slider_size_y=150, slider_sep=5; 
	Fl_Text_Display *disp = new Fl_Text_Display(x, y, slider_size_x, slider_size_y, &quot;Shell-Viz&quot;);
	Fl_Slider* shellInWin1_transparency = new Fl_Slider(x, y+10, slider_size_x, slider_size_y, &quot;S1&quot;);
	Fl_Slider* shellInWin2_transparency = new Fl_Slider(x+slider_size_x+slider_sep, y+10, slider_size_x, slider_size_y, &quot;S2&quot;);
	shellInWin1_transparency-&gt;callback(cartoShell_transparency_cb, (void*)1);
	shellInWin2_transparency-&gt;callback(cartoShell_transparency_cb, (void*)2);

	x=900; y=y+(but_size_y*5)+(but_sep)+10; 
	int txtDisplayXSize = 200, txtDisplayYSize = 200; 
	Fl_Group* textBoxGroup = new Fl_Group(x-5, y+15, 100, 100, &quot;Landmark point list&quot;); 
	lmrkPtDisp = new Fl_Text_Display(x,y+20, txtDisplayXSize, txtDisplayYSize);
	ptDisplayBuffer = new Fl_Text_Buffer();
	lmrkPtDisp-&gt;buffer(ptDisplayBuffer);
	textBoxGroup-&gt;end();

	

}

void create_window(vtkFlRenderWindowInteractor *&amp;flrwi_1, vtkFlRenderWindowInteractor *&amp;flrwi_2, vtkFlRenderWindowInteractor *&amp;flrwi_3,
				   vtkInteractorStyleTrackballCamera *interactorStyle1, vtkInteractorStyleTrackballCamera *interactorStyle2, vtkInteractorStyleTrackballCamera *interactorStyle3, 
				   Fl_Window *&amp;flw, char* title, SCREEN_STYLE S_STY)
{
	
	flw = new Fl_Window(1135,920,title);

	if (S_STY == DEFAULT_SPLIT_SCREEN)
	{
		flrwi_1 = new vtkFlRenderWindowInteractor(5,30,870,875, NULL);
		flrwi_2 = new vtkFlRenderWindowInteractor(890,35,200,200,NULL);
		flrwi_3 = new vtkFlRenderWindowInteractor(890,240,200,200,NULL);
	}
	else if (S_STY == REGISTRATION_SURFACE_SPLIT_SCREEN)
	{
		flrwi_1 = new vtkFlRenderWindowInteractor(5,30,435,467, NULL);
		flrwi_2 = new vtkFlRenderWindowInteractor(447,30,435,467,NULL);
		flrwi_3 = new vtkFlRenderWindowInteractor(5,503,875,407,NULL);
	}

	flrwi_1-&gt;SetInteractorStyle(interactorStyle1);
	flrwi_2-&gt;SetInteractorStyle(interactorStyle2);
	flrwi_3-&gt;SetInteractorStyle(interactorStyle3);

	// menu bar
		Fl_Menu_Item menuitems[] = {
			{ &quot;File&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;Open VTK shell&quot;,  FL_CTRL+'1', (Fl_Callback *)open_LA_shell_cb, 0 },
				{ &quot;Open 2nd VTK reference shell&quot;,  FL_CTRL+'2', (Fl_Callback *)open_2nd_shell_cb, 0 },
				{ &quot;Open image as orthoplanes&quot;,  FL_CTRL+'3', (Fl_Callback *)open_img_as_ortho_cb, 0 },
				{ &quot;Quit&quot;, NULL, (Fl_Callback *)quit_cb, 0, 0},
				{ 0 },
			{ &quot;Encircle&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;XXXXXXX&quot;,    NULL, (Fl_Callback *)open_LA_shell_cb, 0 },
				{ 0 },
			{ &quot;Unfold&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;XXXXXXX&quot;,    NULL, (Fl_Callback *)open_LA_shell_cb, 0 },
				{ 0 },
			{ &quot;Carto&quot;,              0, 0, 0, FL_SUBMENU },
				{ &quot;LM-registration&quot;,    NULL, (Fl_Callback *)open_LA_shells_for_carto_cb, 0 },
				{ &quot;Export target data shell&quot;,    NULL, (Fl_Callback *)export_target_shell_cb, 0 },
				{ &quot;Export transformed source data shell&quot;,    NULL, (Fl_Callback *)export_finalTransformedSource_shell_cb, 0 },
				{ 0 },
		{ 0 }};

	Fl_Menu_Bar *m = new Fl_Menu_Bar(0, 0, 1135, 30);
	m-&gt;copy(menuitems);

 	// buttons

	int button_x=1035, button_y=445, button_h=20, button_w=95, button_sep=30;

	// sliders
	int slider_x=920, slider_y=455, slider_h=100, slider_w=30, slider_sep=30; 
	Fl_Slider* xSlice_selector = new Fl_Slider(slider_x, slider_y+0, slider_w, slider_h+20, &quot;X&quot;);
	Fl_Slider* ySlice_selector = new Fl_Slider(slider_x+(slider_sep*1), slider_y, slider_w, slider_h+20, &quot;Y&quot;);
	Fl_Slider* zSlice_selector = new Fl_Slider(slider_x+(slider_sep*2), slider_y, slider_w, slider_h+20, &quot;Z&quot;);

	Fl_Button* xSlice_onoff = new Fl_Button(slider_x, slider_y+slider_h+35, slider_w, 25, &quot;+-X&quot;);
	Fl_Button* ySlice_onoff = new Fl_Button(slider_x+(slider_sep*1), slider_y+slider_h+35, slider_w, 25, &quot;+-Y&quot;);
	Fl_Button* zSlice_onoff = new Fl_Button(slider_x+(slider_sep*2), slider_y+slider_h+35, slider_w, 25, &quot;+-Z&quot;);
	
	
	if (S_STY == DEFAULT_SPLIT_SCREEN) { 
		encirclementControls(flw);
	}
	else if (S_STY == REGISTRATION_SURFACE_SPLIT_SCREEN) 
	{
		reigstrationControls(flw);
		targetBox-&gt;SetInteractor(fl_vtk_window_1);
		sourceBox-&gt;SetInteractor(fl_vtk_window_2);
	}


	zSlice_selector-&gt;type(FL_VERTICAL);
	ySlice_selector-&gt;type(FL_VERTICAL);
	xSlice_selector-&gt;type(FL_VERTICAL);
	
	// sliders
	zSlice_selector-&gt;callback(zSlice_selector_cb, NULL);
	xSlice_selector-&gt;callback(xSlice_selector_cb, NULL);
	ySlice_selector-&gt;callback(ySlice_selector_cb, NULL);

	xSlice_onoff-&gt;callback(slice_onoff, (void*)0);
	ySlice_onoff-&gt;callback(slice_onoff, (void*)1);
	zSlice_onoff-&gt;callback(slice_onoff, (void*)2);

	
	// This is the callback for allowing users to press a letter on the keyboard 
	vtkCallbackCommand *callback = vtkCallbackCommand::New();			// only for events in fl_vtk_window_2
    callback-&gt;SetCallback(keyPressedFunction_window1);
    flrwi_1-&gt;AddObserver(vtkCommand::KeyPressEvent, callback);

	vtkCallbackCommand *callback2 = vtkCallbackCommand::New();			// if there are events occuring in fl_vtk_window_2
    callback2-&gt;SetCallback(keyPressedFunction_window2);
    flrwi_2-&gt;AddObserver(vtkCommand::KeyPressEvent, callback2);

	
	/*
	vtkCallbackCommand *callback_2 = vtkCallbackCommand::New();
	vtkCallbackCommand *callback_3 = vtkCallbackCommand::New();
	vtkCallbackCommand *callback_4 = vtkCallbackCommand::New();
    callback_2-&gt;SetCallback(LeftMouseButtonPressedFunction);
	callback_3-&gt;SetCallback(LeftMouseButtonReleasedFunction);
	callback_4-&gt;SetCallback(mouseMovedFunction);
	flrwi_1-&gt;AddObserver(vtkCommand::LeftButtonPressEvent, callback_2);
	flrwi_1-&gt;AddObserver(vtkCommand::LeftButtonReleaseEvent, callback_3);
	flrwi_1-&gt;AddObserver(vtkCommand::MouseMoveEvent, callback_4);
	*/
	flw-&gt;resizable(flrwi_3);
	
	
	flw-&gt;end();
	
}





void zSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (im_maxZ-1)*slider-&gt;value();
	vtkImageActor *zSl = XYZSliceArray[2];
	zPos = v;
	zSl-&gt;SetDisplayExtent(0,im_maxX-1,0,im_maxY-1,zPos,zPos);
	fl_vtk_window_1-&gt;Render();
	
}

void ySlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (im_maxY-1)*slider-&gt;value();
	vtkImageActor *ySl = XYZSliceArray[1];
	yPos = v;
	ySl-&gt;SetDisplayExtent(0,im_maxX-1,yPos, yPos, 0,im_maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void xSlice_selector_cb(Fl_Widget* widget, void*)
{
	Fl_Slider* slider = (Fl_Slider*)(widget);
	float v = (im_maxX-1)*slider-&gt;value();
	vtkImageActor *xSl = XYZSliceArray[0];
	xPos = v;
	xSl-&gt;SetDisplayExtent(xPos,xPos,0,im_maxY-1,0,im_maxZ-1);
	fl_vtk_window_1-&gt;Render();
}

void slice_onoff(Fl_Widget*, void* xyz)
{
	int which_xyz; 
	bool isRemoveActor;
	int sliceIndex; 

	which_xyz = (int)xyz; 
	
	if (which_xyz==0) { isRemoveActor = isXSliceOn; isXSliceOn =&nbsp;!isXSliceOn; sliceIndex = 0; } 
	if (which_xyz==1) { isRemoveActor = isYSliceOn; isYSliceOn =&nbsp;!isYSliceOn; sliceIndex = 1; } 
	if (which_xyz==2) { isRemoveActor = isZSliceOn; isZSliceOn =&nbsp;!isZSliceOn; sliceIndex = 2; }

	if (isRemoveActor)
		renderer1-&gt;RemoveActor(XYZSliceArray[sliceIndex]);
	else 
		renderer1-&gt;AddActor(XYZSliceArray[sliceIndex]);

	fl_vtk_window_1-&gt;Render();

}

void quit_cb(Fl_Widget*, void* v)
{
	destroy();
	exit(0);
}

void open_img_as_ortho_cb(Fl_Widget*, void* v) 
{
	char* fn, *fn2; 
	fn = fl_file_chooser(&quot;Open grey scale image&quot;, &quot;*.nii|*.hdr|*.gipl&quot;, dir_path);

	if (fn&nbsp;!= NULL)
	{
		unfold = new iblSurfaceUnfold(80, 20, true);
		unfold-&gt;SetImage(fn); 
		im1 = unfold-&gt;GetImage();
		XYZSliceArray = new vtkImageActor*[3]; 

		for (int i=0;i&lt;3;i++) XYZSliceArray[i] = vtkImageActor::New();

		VizBoxCore::VBC_showImageAsOrthogonalPlanes(fl_vtk_window_1, im1, XYZSliceArray);
		
		im_maxX = im1-&gt;GetX(); 
		im_maxY = im1-&gt;GetY(); 
		im_maxZ = im1-&gt;GetZ();

		fn2 = fl_file_chooser(&quot;Open LA shell for transferring colors?&quot;, &quot;*.vtk&quot;, dir_path);
		if (fn2&nbsp;!= NULL)
		{
			unfold-&gt;SetScalarShell(fn2); 
		}
	}

}

void open_LA_shell_cb(Fl_Widget*, void* v)
{
	char* fn; 
	double t=-1; 
	fn = fl_file_chooser(&quot;Open VTK file&quot;, &quot;*.vtk&quot;, dir_path);

	if (fn&nbsp;!= NULL) 
	{
		enc = new Encircler(); 
		enc-&gt;setVTKPoly(fn); 
		enc-&gt;SetNeighbourhoodOrder(4); 
		cout &lt;&lt; &quot;\nWhat is the threshold value for scar in this shell you are loading, ignore this question if you are not going to measure encirclement&gt;&quot; &lt;&lt; endl;
		cin &gt;&gt; t; 
		if (t==-1) t=0.5;
		enc-&gt;SetThresholdOnScalars(t); 
		enc-&gt;SetResolution(20);
		
		enc-&gt;DisplaySurfaceToScreen(fl_vtk_window_1); 
		camera1-&gt;SetPosition(0,0,500);
		camera1-&gt;SetFocalPoint(0,0,0);
		renderer1-&gt;SetActiveCamera(camera1);
	}
}

void open_2nd_shell_cb(Fl_Widget*, void* v)
{
	char* fn; 
	double t=-1; 
	fn = fl_file_chooser(&quot;Open VTK file&quot;, &quot;*.vtk&quot;, dir_path);

	if (fn&nbsp;!= NULL) 
	{
		referenceSurfaceActor = vtkActor::New(); 
		vtkSmartPointer&lt;vtkPolyDataReader&gt; reader1 = vtkSmartPointer&lt;vtkPolyDataReader&gt;::New();
		reader1-&gt;SetFileName(fn); 
		reader1-&gt;Update(); 
		VizBoxCore::VBC_DisplayPolyNoFieldData(fl_vtk_window_1, reader1-&gt;GetOutput(), referenceSurfaceActor); 
		referenceSurfaceActor-&gt;GetProperty()-&gt;SetOpacity(0.3); 
		fl_vtk_window_1-&gt;Render();
		is2ndReferenceActorShowing = true; 
	}
}

void hide2ndShell_cb(Fl_Widget*, void* v)
{
	if (is2ndReferenceActorShowing) { 
		VizBoxCore::VBC_removeActorFromDisplay(fl_vtk_window_1, referenceSurfaceActor); 
		is2ndReferenceActorShowing =&nbsp;!is2ndReferenceActorShowing;
	}
	else {
		VizBoxCore::VBC_DisplayActor(fl_vtk_window_1, referenceSurfaceActor);
		is2ndReferenceActorShowing =&nbsp;!is2ndReferenceActorShowing;
	}
}

void turnBoxWidgetOnOff_cb(Fl_Widget*, void*) 
{
	if (boxesAreOff) { 
		targetBox-&gt;On();
		sourceBox-&gt;On();
	}
	else { 
		targetBox-&gt;Off();
		sourceBox-&gt;Off();
	}
	boxesAreOff =&nbsp;!boxesAreOff;
}

void setROI_cb(Fl_Widget*, void*) 
{
	double target_centre[3], source_centre[3]; 
	stringstream ss; 
	double rd1, rd2; 

	if (!boxesAreOff)
	{
		VizBoxCore::VBC_centroidOfROIWithinPolyhedron(targetBox, targetPolyhedron, target_centre); 
		VizBoxCore::VBC_centroidOfROIWithinPolyhedron(sourceBox, sourcePolyhedron, source_centre); 
		ss &lt;&lt; ++lmp_count &lt;&lt; &quot;) &quot; &lt;&lt; &quot;(&quot; &lt;&lt; setprecision(2) &lt;&lt; target_centre[0] &lt;&lt; &quot;,&quot; &lt;&lt; target_centre[1] &lt;&lt; &quot;,&quot; &lt;&lt; target_centre[2] &lt;&lt; &quot;) and (&quot; &lt;&lt; source_centre[0] 
		&lt;&lt; &quot;,&quot; &lt;&lt; source_centre[1] &lt;&lt; &quot;,&quot; &lt;&lt; source_centre[2] &lt;&lt; &quot;)\n&quot;;
		cout &lt;&lt; ss.str().c_str() &lt;&lt; endl;
		lmrkPtDisp-&gt;insert(ss.str().c_str());

		// insert into target and source point list
		// see example in http://www.vtk.org/Wiki/VTK/Examples/Cxx/Widgets/BoxWidget
		
		sphereActorTarget = vtkSmartPointer&lt;vtkActor&gt;::New(); 
		sphereActorSource = vtkSmartPointer&lt;vtkActor&gt;::New(); 
		sourcePoints_lmreg-&gt;InsertNextPoint(source_centre);
		targetPoints_lmreg-&gt;InsertNextPoint(target_centre);
	
		rd1 = MathBox::getRand(1); 
		rd2 = MathBox::getRand(1); 
		VizBoxCore::VBC_drawSphere(target_centre[0], target_centre[1], target_centre[2], 1.5, rd1, rd2, rd1, sphereActorTarget); 
		VizBoxCore::VBC_drawSphere(source_centre[0], source_centre[1], source_centre[2], 1.5, rd1, rd2, rd1, sphereActorSource); 
		VizBoxCore::VBC_DisplayActor(fl_vtk_window_1, sphereActorTarget);
		VizBoxCore::VBC_DisplayActor(fl_vtk_window_2, sphereActorSource);
		
		lmPtActorsTarget.push_back(sphereActorTarget);
		lmPtActorsSource.push_back(sphereActorSource);
	}
	else
	{
		cerr &lt;&lt; &quot;ERROR: Please turn the box widget on by pressing on the appropriate button&quot; &lt;&lt; endl;
	}
}

void landmarkRegistration_cb(Fl_Widget*, void*)
{
	vtkSmartPointer&lt;vtkLandmarkTransform&gt; landmarkTransform = vtkSmartPointer&lt;vtkLandmarkTransform&gt;::New();
	landmarkTransform-&gt;SetSourceLandmarks(sourcePoints_lmreg);
	landmarkTransform-&gt;SetTargetLandmarks(targetPoints_lmreg);
	landmarkTransform-&gt;SetModeToAffine();
	landmarkTransform-&gt;Update(); 

	vtkSmartPointer&lt;vtkMatrix4x4&gt; m = landmarkTransform-&gt;GetMatrix();
	std::cout &lt;&lt; &quot;The resulting matrix after landmark transform is: &quot; &lt;&lt; *m &lt;&lt; std::endl;
 
	// Transform the source points by the ICP solution
	vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; lmtFilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
	lmtFilter-&gt;SetInput(sourcePolyhedron);
	lmtFilter-&gt;SetTransform(landmarkTransform);
	lmtFilter-&gt;Update();
	
	transformedSourcePolyhedron = vtkSmartPointer&lt;vtkPolyData&gt;::New();
	transformedSourceActor = vtkSmartPointer&lt;vtkActor&gt;::New();
	transformedSourcePolyhedron-&gt;DeepCopy(lmtFilter-&gt;GetOutput());
	sourcePolyhedronActor-&gt;GetProperty()-&gt;SetOpacity(0.0);
	VizBoxCore::VBC_DisplayPolyNoFieldData(fl_vtk_window_3, transformedSourcePolyhedron, transformedSourceActor);

	vtkSmartPointer&lt;vtkCamera&gt; camera = vtkSmartPointer&lt;vtkCamera&gt;::New(); 
	double* bounds = new double[6]; 
	transformedSourceActor-&gt;GetBounds(bounds); 
	camera = fl_vtk_window_3-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;GetActiveCamera(); 
	camera-&gt;SetPosition(100+bounds[1], 100+bounds[3], 100+bounds[5]);
	bounds = transformedSourceActor-&gt;GetCenter(); 
	camera-&gt;SetFocalPoint(bounds[0], bounds[1], bounds[2]);
	fl_vtk_window_3-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;SetActiveCamera(camera);
	fl_vtk_window_3-&gt;Render();

	// and set the flags to indicate that LM registration took place
	isOnlyLandmark = true;
	
}

void icpAfterLandmarkRegistration_cb(Fl_Widget*, void*)
{
	transformedSourceActor_postICP = vtkSmartPointer&lt;vtkActor&gt;::New();
	transformedSourcePolyhedron_postICP = vtkSmartPointer&lt;vtkPolyData&gt;::New();
	vtkSmartPointer&lt;vtkIterativeClosestPointTransform&gt; icp = vtkSmartPointer&lt;vtkIterativeClosestPointTransform&gt;::New();
	icp-&gt;SetSource(transformedSourcePolyhedron);
	icp-&gt;SetTarget(targetPolyhedron);
	icp-&gt;GetLandmarkTransform()-&gt;SetModeToAffine();
	icp-&gt;SetMaximumNumberOfIterations(1000);
	//icp-&gt;StartByMatchingCentroidsOn();
	icp-&gt;Modified();
	icp-&gt;Update();
	vtkSmartPointer&lt;vtkMatrix4x4&gt; m = icp-&gt;GetMatrix();
	std::cout &lt;&lt; &quot;The resulting matrix after ICP is: &quot; &lt;&lt; *m &lt;&lt; std::endl;
 
	vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt; icpFilter = vtkSmartPointer&lt;vtkTransformPolyDataFilter&gt;::New();
	icpFilter-&gt;SetInput(transformedSourcePolyhedron);
	icpFilter-&gt;SetTransform(icp);
	icpFilter-&gt;Update();
	
	transformedSourcePolyhedron_postICP-&gt;DeepCopy(icpFilter-&gt;GetOutput());
	transformedSourceActor-&gt;GetProperty()-&gt;SetOpacity(0.0);
	VizBoxCore::VBC_DisplayPolyNoFieldData(fl_vtk_window_3, transformedSourcePolyhedron_postICP, transformedSourceActor_postICP);

	// and set the flags to indicate that ICP took place
	isOnlyLandmark = false; 
	isICP = true; 
}

void transferDataToTarget_cb(Fl_Widget*, void*)
{
	targetPolyhedronWithSourceDataActor = vtkSmartPointer&lt;vtkActor&gt;::New(); 
	targetPolyhedron_WithSourceData = vtkSmartPointer&lt;vtkPolyData&gt;::New();
	targetPolyhedron_WithSourceData-&gt;DeepCopy(targetPolyhedron);
	// If you would like to not use ICP and just landmark registration and transfer scalars, switch off this line, and the line marked below
	VizBoxCore::VBC_TransferPointDataToTargetPoly(transformedSourcePolyhedron_postICP, targetPolyhedron_WithSourceData);

	//VizBoxCore::VBC_TransferPointDataToTargetPoly(transformedSourcePolyhedron, targetPolyhedron_WithSourceData);
	// also switch off this line below
	transformedSourceActor_postICP-&gt;GetProperty()-&gt;SetOpacity(0.0);
	VizBoxCore::VBC_DisplayPoly(fl_vtk_window_3, targetPolyhedron_WithSourceData, false, targetPolyhedronWithSourceDataActor);
}

void writePickedPointsToFile_cb(Fl_Widget*, void* v) 
{
	double xyz[3];
	const char* newfile; 
	ofstream outputToFile; 
	stringstream ss; 
	ss &lt;&lt; &quot;&quot;;
	ss &lt;&lt; &quot;pointsPicked_&quot; &lt;&lt; pointsPickedFileNum &lt;&lt; &quot;.txt&quot;; 
	cout &lt;&lt; &quot;Writing to file &quot; &lt;&lt; ss.str().c_str() &lt;&lt; endl;
	outputToFile.open(ss.str().c_str());	
	
	// now write the points that were picked since the last time writePickedPointsToFile_cb was called  
	outputToFile &lt;&lt; &quot;Picked points x, y and z co-ordinates in world CS&quot; &lt;&lt; endl;
	for (int i=indexOfLastPointWrittenToFile; i&lt;enc-&gt;_ptSeq; i++) 
	{
		 enc-&gt;_pointList-&gt;GetPoint(i, xyz); 
		 outputToFile &lt;&lt; setprecision(3) &lt;&lt; xyz[0] &lt;&lt; &quot; &quot; &lt;&lt; xyz[1] &lt;&lt; &quot; &quot; &lt;&lt; xyz[2] &lt;&lt; endl;

	}
	outputToFile.close(); 
	indexOfLastPointWrittenToFile = pointsPickedCounter; 
	pointsPickedFileNum++;

}

void open_LA_shells_for_carto_cb(Fl_Widget*, void* v)
{
	char* fn, *fn2; 
	fn = fl_file_chooser(&quot;Open target shell&quot;, &quot;*.vtk&quot;, dir_path);
	stringstream filenamestrstr; 
	string filenamestr; 
	filenamestrstr &lt;&lt; fn; 
	filenamestr = filenamestrstr.str(); 

	if (fn&nbsp;!= NULL) // the first file loaded is the target
	{
		if (filenamestr.substr(filenamestr.find_last_of(&quot;.&quot;) + 1) == &quot;csv&quot;) {			// check file extension 
			carto1-&gt;SetExternalAndGetVTK(fn, &quot;carto.vtk&quot;, MatlabTriRep, comma_delimiter); 
		} else if (filenamestr.substr(filenamestr.find_last_of(&quot;.&quot;) + 1) == &quot;vtk&quot;) {
			carto1-&gt;SetExternalAndGetVTK(fn, &quot;carto.vtk&quot;, VTKNativePolyhedra, comma_delimiter); 
		}

		if (isMultiPointDataArray){
			carto1-&gt;GetVTKPolyData(targetPolyhedron_ND, 1); 
			ConvertMultiDimensionalForceShell(targetPolyhedron_ND, targetPolyhedron);
		}
		else 
			carto1-&gt;GetVTKPolyData(targetPolyhedron, 1); 

		targetPolyhedronActor-&gt;GetProperty()-&gt;SetColor(0.5,0.1,1.0);
		
		// Display binarized color map based on threshold, threshold the scalar data
		if (targetPoly_scalar_threshold &gt; 0) {
			cout &lt;&lt; &quot;Thresholding target data .. &quot; &lt;&lt; endl;
			VizBoxCore::VBC_thresholdScalarsOnShell(targetPolyhedron, false, targetPoly_scalar_threshold, 0, 1, true);  
		}
		
		if (!isDisplayColorMap) 
			VizBoxCore::VBC_DisplayPolyNoFieldData(fl_vtk_window_1, targetPolyhedron, targetPolyhedronActor); 
		else 
			VizBoxCore::VBC_DisplayPoly(fl_vtk_window_1, targetPolyhedron, false, targetPolyhedronActor); 

		VizBoxCore::VBC_DisplayActor(fl_vtk_window_3, targetPolyhedronActor); 
		
		fn2 = fl_file_chooser(&quot;Open source shell&quot;, &quot;*.vtk&quot;, dir_path);
		
		filenamestrstr.str(&quot;&quot;);
		filenamestrstr.clear();
		filenamestrstr &lt;&lt; fn2; 
		filenamestr = filenamestrstr.str();
		if (fn2&nbsp;!= NULL)
		{
			if (filenamestr.substr(filenamestr.find_last_of(&quot;.&quot;) + 1) == &quot;csv&quot;) { 
				carto2-&gt;SetExternalAndGetVTK(fn2, &quot;mri.vtk&quot;, MatlabTriRep, comma_delimiter); 
			} else if (filenamestr.substr(filenamestr.find_last_of(&quot;.&quot;) + 1) == &quot;vtk&quot;) {
				carto2-&gt;SetExternalAndGetVTK(fn2, &quot;mri.vtk&quot;, VTKNativePolyhedra, comma_delimiter); 
			}
			
			carto2-&gt;GetVTKPolyData(sourcePolyhedron, 1); 
			sourcePolyhedronActor-&gt;GetProperty()-&gt;SetColor(1,1,0);
			
			sourcePolyhedron_copy-&gt;DeepCopy(sourcePolyhedron); 	
		
			// Display binarized color map based on threshold, threshold the scalar data
			if (sourcePoly_scalar_threshold &gt; 0) { 
				VizBoxCore::VBC_thresholdScalarsOnShell(sourcePolyhedron_copy, false, sourcePoly_scalar_threshold, 0, 1, true);  
			}
			
			if (!isDisplayColorMap)
				VizBoxCore::VBC_DisplayPolyNoFieldData(fl_vtk_window_2, sourcePolyhedron,  sourcePolyhedronActor); 
			else 
				VizBoxCore::VBC_DisplayPoly(fl_vtk_window_2, sourcePolyhedron_copy, false, sourcePolyhedronActor); 

			VizBoxCore::VBC_DisplayActor(fl_vtk_window_3, sourcePolyhedronActor); 

			// set the cameras (first for target and then for source)
			vtkSmartPointer&lt;vtkCamera&gt; camera1 =  vtkSmartPointer&lt;vtkCamera&gt;::New();
			double* bounds = new double[6]; 
			targetPolyhedronActor-&gt;GetBounds(bounds); 
			camera1 = fl_vtk_window_1-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;GetActiveCamera(); 
			camera1-&gt;SetPosition(100+bounds[1], 100+bounds[3], 100+bounds[5]);
			bounds = targetPolyhedronActor-&gt;GetCenter(); 
			cout &lt;&lt; &quot;Center of target = (&quot; &lt;&lt; bounds[0] &lt;&lt; &quot;,&quot; &lt;&lt; bounds[1] &lt;&lt; &quot;,&quot; &lt;&lt; bounds[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
			camera1-&gt;SetFocalPoint(bounds[0], bounds[1], bounds[2]);
			fl_vtk_window_1-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;SetActiveCamera(camera1);
			
			vtkSmartPointer&lt;vtkCamera&gt; camera2 =  vtkSmartPointer&lt;vtkCamera&gt;::New();
			bounds = new double[6]; 
			sourcePolyhedronActor-&gt;GetBounds(bounds); 
			camera2 = fl_vtk_window_2-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;GetActiveCamera(); 
			camera2-&gt;SetPosition(100+bounds[1], 100+bounds[3], 100+bounds[5]);
			bounds = sourcePolyhedronActor-&gt;GetCenter(); 
			cout &lt;&lt; &quot;Center of source = (&quot; &lt;&lt; bounds[0] &lt;&lt; &quot;,&quot; &lt;&lt; bounds[1] &lt;&lt; &quot;,&quot; &lt;&lt; bounds[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;
			camera2-&gt;SetFocalPoint(bounds[0], bounds[1], bounds[2]); 
			fl_vtk_window_2-&gt;GetRenderWindow()-&gt;GetRenderers()-&gt;GetFirstRenderer()-&gt;SetActiveCamera(camera2);

		}
	}
}

void export_target_shell_cb(Fl_Widget* widget, void* v)
{
	char* fn;
	fn = fl_file_chooser(&quot;Save target shell&quot;, &quot;*.vtk&quot;, dir_path);
	
	if (fn&nbsp;!= NULL) // the first file loaded is the target
	{
		vtkSmartPointer&lt;vtkPolyDataWriter&gt; writer = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New(); 
		writer-&gt;SetInput(targetPolyhedron_WithSourceData);
		writer-&gt;SetFileName(fn); 
		writer-&gt;Update(); 
	}
}


void export_finalTransformedSource_shell_cb(Fl_Widget* widget, void* v)
{
	char* fn;
	fn = fl_file_chooser(&quot;Save transformed source shell&quot;, &quot;*.vtk&quot;, dir_path);
	
	if (fn&nbsp;!= NULL) // the first file loaded is the target
	{
		vtkSmartPointer&lt;vtkPolyDataWriter&gt; writer = vtkSmartPointer&lt;vtkPolyDataWriter&gt;::New(); 
		if (isICP) writer-&gt;SetInput(transformedSourcePolyhedron_postICP);
		else if (isOnlyLandmark) writer-&gt;SetInput(transformedSourcePolyhedron);
		writer-&gt;SetFileName(fn); 
		writer-&gt;Update(); 
	}
}

void cartoShell_transparency_cb(Fl_Widget* widget, void* v)
{
	int whichShell; 
	double transparency;

	Fl_Slider* slider = (Fl_Slider*)(widget);
	transparency = slider-&gt;value();
	whichShell = (int)v; 

	if (whichShell == 1) 
	{
		targetPolyhedronActor-&gt;GetProperty()-&gt;SetOpacity(1-transparency);	
		fl_vtk_window_1-&gt;Render();
		fl_vtk_window_3-&gt;Render();
	}
	else if (whichShell == 2)
	{
		sourcePolyhedronActor-&gt;GetProperty()-&gt;SetOpacity(1-transparency);
		fl_vtk_window_2-&gt;Render();
		fl_vtk_window_3-&gt;Render();
	}
	
}

void enc_neighbourhood_change_cb(Fl_Widget* widget, void* v)
{
	
}

void enc_threshold_change_cb(Fl_Widget*, void* v)
{

}

void encirclement_computebutton_cb(Fl_Widget*, void* v)
{
	if (isEncirclementPointPicked)
		enc-&gt;EncirclementDriver(6, 20, fl_vtk_window_1);
	else
		cout &lt;&lt; &quot;You must select points on the select with 's' on the keyboard&quot; &lt;&lt; endl;
}

void encirclement_reset_cb(Fl_Widget*, void*) 
{
	enc-&gt;FullReset();
	isEncirclementPointPicked = false; 
}

void keyPressedFunction_window1(vtkObject* obj, unsigned long,void *sr, void *)
{
	double vert_xyz[3];
	vtkIdType cellID; 
	vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::SafeDownCast(obj);
	xyzPlanePickerSphere = vtkActor::New(); 
	stringstream ss; 


	switch (iren-&gt;GetKeyCode())
	{
		case 'x':			/*	For selecting Encircler's points on shell		*/ 
			cout &lt;&lt; &quot;Selecting new points on surface .. &quot; &lt;&lt; endl;
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			point_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			//s = cell_picker-&gt;GetSelectionPoint(); 
			pick_position = point_picker-&gt;GetPickPosition(); 
			cout &lt;&lt; &quot;You picked point with ID&quot; &lt;&lt; point_picker-&gt;GetPointId() &lt;&lt; &quot; with (xyz) = &quot; &lt;&lt; pick_position[0] &lt;&lt; &quot;,&quot; &lt;&lt; pick_position[1] &lt;&lt; &quot;,&quot; &lt;&lt; pick_position[2] &lt;&lt; endl; 
			
			enc-&gt;RegisterPoints(fl_vtk_window_1, point_picker-&gt;GetPointId(), true);
		break; 
		case 'y': 
			cout &lt;&lt; &quot;Modifying old point .. &quot; &lt;&lt; endl;
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			point_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			//s = cell_picker-&gt;GetSelectionPoint(); 
			pick_position = point_picker-&gt;GetPickPosition(); 
			cout &lt;&lt; &quot;You picked point with ID&quot; &lt;&lt; point_picker-&gt;GetPointId() &lt;&lt; &quot; with (xyz) = &quot; &lt;&lt; pick_position[0] &lt;&lt; &quot;,&quot; &lt;&lt; pick_position[1] &lt;&lt; &quot;,&quot; &lt;&lt; pick_position[2] &lt;&lt; endl;
			enc-&gt;RegisterPoints(fl_vtk_window_1, point_picker-&gt;GetPointId(), false);

		break;
		case 'h':		/*	Use this to pick points for encirclement	*/	
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			cell_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			pick_position = cell_picker-&gt;GetPickPosition(); 
			//enc-&gt;justPicker(fl_vtk_window_1,pick_position);
			cellID = cell_picker-&gt;GetCellId(); 
			if (cellID&nbsp;!= -1) { 
					isEncirclementPointPicked = true; 
					enc-&gt;justCellVertexPicker(fl_vtk_window_1, cellID); 
					pointsPickedCounter++;
			}
		break;
	
		

		case 'g': 
			enc-&gt;CropPolygonalMesh(fl_vtk_window_1);
			enc-&gt;resetForCroppingPolygonalMesh(fl_vtk_window_1);
			break;
		case 't': 
			
			enc-&gt;resetForCroppingPolygonalMesh(fl_vtk_window_1);
			break;
		case 'c': 
			//enc-&gt;CropPolygonalMesh(fl_vtk_window_1);
			//enc-&gt;TesterShortestPath(fl_vtk_window_1);
			//enc-&gt;DisplayRecursiveNeighboursAlongComputedShortestPath(fl_vtk_window_1);
			
			//enc-&gt;ComputeGravityCenterOfSelection();
			//enc-&gt;CollectPointsAtDegreeIntervals(30);
			if (_flip == 1) {
				enc-&gt;ShowNeighbourOrder(fl_vtk_window_1);
				_flip *= -1; 
			}
			else  {
				enc-&gt;HideNeighbourOrder();
				_flip *= -1;

			}
			break; 
		case 'l': 
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			xyz_plane_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			xyz_plane_picker-&gt;GetPickPosition(xyz_plane_picker_pos);
			VizBoxCore::VBC_drawSphere(xyz_plane_picker_pos[0],xyz_plane_picker_pos[1],xyz_plane_picker_pos[2], 1.0, 0.5,0,0.5, xyzPlanePickerSphere);
			VizBoxCore::VBC_DisplayActor(fl_vtk_window_1, xyzPlanePickerSphere);
			unfold-&gt;RegisterSurfaceCutPoint(xyz_plane_picker_pos, false, false, true);
			unfold-&gt;TestDrive(fl_vtk_window_1);
			fl_vtk_window_1-&gt;Render();
			break;
		
		case '1':			/*	To (optionally) select points on source shell in landmark based registration of carto to mri maps	*/ 
			screenX = fl_vtk_window_1-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_1-&gt;GetEventPosition()[1];
			cell_picker-&gt;Pick(screenX,screenY,0.0, renderer1);
			pick_position = cell_picker-&gt;GetPickPosition(); 
			//enc-&gt;justPicker(fl_vtk_window_1,pick_position);
			cellID = cell_picker-&gt;GetCellId(); 
			if (cellID&nbsp;!= -1) { 
				cout &lt;&lt; &quot;Cell id = &quot; &lt;&lt; cellID &lt;&lt; endl;
				vtkActor* targetLMSphereActor = vtkActor::New(); 
				VizBoxCore::MarkPolyCellVertexWithSphere(fl_vtk_window_1, targetPolyhedron, cellID, targetLMSphereActor, vert_xyz); 
				lmPtActorsTarget.push_back(targetLMSphereActor);
				targetPoints_lmreg-&gt;InsertNextPoint(vert_xyz);

				//points_out &lt;&lt; vert_xyz[0] &lt;&lt; &quot;\t&quot; &lt;&lt; vert_xyz[1] &lt;&lt; &quot;\t&quot; &lt;&lt; vert_xyz[2] &lt;&lt; endl;
			}
		break; 
		default: 
			
		break; 
	}

}

void keyPressedFunction_window2(vtkObject* obj, unsigned long,void *sr, void *)
{
	double vert_xyz[3];
	vtkIdType cellID; 
	vtkRenderWindowInteractor* iren = vtkRenderWindowInteractor::SafeDownCast(obj);
	xyzPlanePickerSphere = vtkActor::New(); 
	stringstream ss; 
	switch (iren-&gt;GetKeyCode())
	{
	
		case '2':			/*	To (optionally) select points on source shell in landmark based registration of carto to mri maps	*/ 
			screenX = fl_vtk_window_2-&gt;GetEventPosition()[0];
			screenY = fl_vtk_window_2-&gt;GetEventPosition()[1];
			cell_picker2-&gt;Pick(screenX,screenY,0.0, renderer2);
			pick_position = cell_picker2-&gt;GetPickPosition(); 
			//enc-&gt;justPicker(fl_vtk_window_1,pick_position);
			cellID = cell_picker2-&gt;GetCellId(); 
			if (cellID&nbsp;!= -1) { 
				vtkActor* sourceLMSphereActor = vtkActor::New(); 
				VizBoxCore::MarkPolyCellVertexWithSphere(fl_vtk_window_2, sourcePolyhedron, cellID, sourceLMSphereActor, vert_xyz); 
				lmPtActorsSource.push_back(sourceLMSphereActor);
				sourcePoints_lmreg-&gt;InsertNextPoint(vert_xyz);

				//points_out &lt;&lt; vert_xyz[0] &lt;&lt; &quot;\t&quot; &lt;&lt; vert_xyz[1] &lt;&lt; &quot;\t&quot; &lt;&lt; vert_xyz[2] &lt;&lt; endl;
			}
		break; 
		
	}

}
</pre>

<!-- 
NewPP limit report
Preprocessor node count: 14/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key rkarim:pcache:idhash:458-0!1!0!!en!2!edit=0!printable=1 and timestamp 20180312082422 -->
<div class="printfooter">
Retrieved from "<a href="index92f2.html?title=Carto_fuse_v2a">https://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Carto_fuse_v2a</a>"</div>
						<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="index92f2.html?title=Carto_fuse_v2a" title="View the content page [c]" accesskey="c">Page</a></li>
				 <li id="ca-talk" class="new"><a href="indexbc47.html?title=Talk:Carto_fuse_v2a&amp;action=edit&amp;redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-viewsource"><a href="indexc9be.html?title=Carto_fuse_v2a&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></li>
				 <li id="ca-history"><a href="indexa1ee.html?title=Carto_fuse_v2a&amp;action=history" title="Past revisions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-anonuserpage"><a href="indexd3f8.html?title=User:159.92.151.128" title="The user page for the ip you&#039;re editing as [.]" accesskey="." class="new">159.92.151.128</a></li>
				<li id="pt-anontalk"><a href="index7a1b.html?title=User_talk:159.92.151.128" title="Discussion about edits from this IP address [n]" accesskey="n" class="new">Talk for this IP</a></li>
				<li id="pt-anonlogin"><a href="index79a3.html?title=Special:UserLogin&amp;returnto=Carto_fuse_v2a" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(images/myWikiLogo.gif);" href="indexb3c9.html?title=Research_Wiki" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="indexb3c9.html?title=Research_Wiki">Main Page</a></li>
				<li id="n-Home"><a href="http://www.doc.ic.ac.uk/~rkarim/">Home</a></li>
				<li id="n-currentevents"><a href="index8cfe.html?title=Rashed_Karim_Wiki:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-recentchanges"><a href="indexa414.html?title=Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-randompage"><a href="index3455.html?title=Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
				<li id="n-help"><a href="index3cd6.html?title=Help:Contents" title="The place to find out">Help</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="https://wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Rashed Karim Wiki [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search the pages for this text" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="indexa634.html?title=Special:WhatLinksHere/Carto_fuse_v2a" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="indexe1cd.html?title=Special:RecentChangesLinked/Carto_fuse_v2a" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-specialpages"><a href="indexc7ac.html?title=Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="indexd719.html?title=Carto_fuse_v2a&amp;printable=yes&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="indexc015.html?title=Carto_fuse_v2a&amp;oldid=3973" title="Permanent link to this revision of the page">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 20 September 2017, at 10:55.</li>
					<li id="viewcount">This page has been accessed 892 times.</li>
					<li id="privacy"><a href="index2a71.html?title=Rashed_Karim_Wiki:Privacy_policy" title="Rashed Karim Wiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="index1436.html?title=Rashed_Karim_Wiki:About" title="Rashed Karim Wiki:About">About Rashed Karim Wiki</a></li>
					<li id="disclaimer"><a href="index2f3a.html?title=Rashed_Karim_Wiki:General_disclaimer" title="Rashed Karim Wiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.453 secs. --></body>
<!-- Mirrored from wwwhomes.doc.ic.ac.uk/~rkarim/mediawiki/index.php?title=Carto_fuse_v2a&printable=yes by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 12 Mar 2018 13:43:50 GMT -->
</html>
